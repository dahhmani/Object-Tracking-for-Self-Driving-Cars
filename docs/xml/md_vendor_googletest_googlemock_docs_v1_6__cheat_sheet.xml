<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="md_vendor_googletest_googlemock_docs_v1_6__cheat_sheet" kind="page">
    <compoundname>md_vendor_googletest_googlemock_docs_v1_6_CheatSheet</compoundname>
    <title>Defining a Mock Class</title>
    <detaileddescription>
<para><heading level="2">Mocking a Normal Class</heading>
</para><para>Given <programlisting><codeline><highlight class="normal">class<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~Foo();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>int<sp/>GetSize()<sp/>const<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>string<sp/>Describe(const<sp/>char*<sp/>name)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>string<sp/>Describe(int<sp/>type)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>bool<sp/>Process(Bar<sp/>elem,<sp/>int<sp/>count)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting> (note that <computeroutput>~Foo()</computeroutput> <bold>must</bold> be virtual) we can define its mock as <programlisting><codeline><highlight class="normal">#include<sp/>&quot;gmock/gmock.h&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_CONST_METHOD0(GetSize,<sp/>int());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(Describe,<sp/>string(const<sp/>char*<sp/>name));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(Describe,<sp/>string(int<sp/>type));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD2(Process,<sp/>bool(Bar<sp/>elem,<sp/>int<sp/>count));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>To create a &quot;nice&quot; mock object which ignores all uninteresting calls, or a &quot;strict&quot; mock object, which treats them as failures: <programlisting><codeline><highlight class="normal">NiceMock&lt;MockFoo&gt;<sp/>nice_foo;<sp/><sp/><sp/><sp/><sp/>//<sp/>The<sp/>type<sp/>is<sp/>a<sp/>subclass<sp/>of<sp/>MockFoo.</highlight></codeline>
<codeline><highlight class="normal">StrictMock&lt;MockFoo&gt;<sp/>strict_foo;<sp/>//<sp/>The<sp/>type<sp/>is<sp/>a<sp/>subclass<sp/>of<sp/>MockFoo.</highlight></codeline>
</programlisting></para><para><heading level="2">Mocking a Class Template</heading>
</para><para>To mock <programlisting><codeline><highlight class="normal">template<sp/>&lt;typename<sp/>Elem&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>StackInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~StackInterface();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>int<sp/>GetSize()<sp/>const<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>Push(const<sp/>Elem&amp;<sp/>x)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting> (note that <computeroutput>~StackInterface()</computeroutput> <bold>must</bold> be virtual) just append <computeroutput>_T</computeroutput> to the <computeroutput>MOCK_*</computeroutput> macros: <programlisting><codeline><highlight class="normal">template<sp/>&lt;typename<sp/>Elem&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockStack<sp/>:<sp/>public<sp/>StackInterface&lt;Elem&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_CONST_METHOD0_T(GetSize,<sp/>int());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1_T(Push,<sp/>void(const<sp/>Elem&amp;<sp/>x));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para><heading level="2">Specifying Calling Conventions for <ref refid="class_mock" kindref="compound">Mock</ref> Functions</heading>
</para><para>If your mock function doesn&apos;t use the default calling convention, you can specify it by appending <computeroutput>_WITH_CALLTYPE</computeroutput> to any of the macros described in the previous two sections and supplying the calling convention as the first argument to the macro. For example, <programlisting><codeline><highlight class="normal">MOCK_METHOD_1_WITH_CALLTYPE(STDMETHODCALLTYPE,<sp/>Foo,<sp/>bool(int<sp/>n));</highlight></codeline>
<codeline><highlight class="normal">MOCK_CONST_METHOD2_WITH_CALLTYPE(STDMETHODCALLTYPE,<sp/>Bar,<sp/>int(double<sp/>x,<sp/>double<sp/>y));</highlight></codeline>
</programlisting> where <computeroutput>STDMETHODCALLTYPE</computeroutput> is defined by <computeroutput>&lt;objbase.h&gt;</computeroutput> on Windows.</para><para><heading level="1">Using Mocks in Tests</heading>
</para><para>The typical flow is:<orderedlist>
<listitem><para>Import the Google <ref refid="class_mock" kindref="compound">Mock</ref> names you need to use. All Google <ref refid="class_mock" kindref="compound">Mock</ref> names are in the <computeroutput>testing</computeroutput> namespace unless they are macros or otherwise noted.</para></listitem></orderedlist>
<orderedlist>
<listitem><para>Create the mock objects.</para></listitem></orderedlist>
<orderedlist>
<listitem><para>Optionally, set the default actions of the mock objects.</para></listitem></orderedlist>
<orderedlist>
<listitem><para>Set your expectations on the mock objects (How will they be called? What wil they do?).</para></listitem></orderedlist>
<orderedlist>
<listitem><para>Exercise code that uses the mock objects; if necessary, check the result using <ulink url="http://code.google.com/p/googletest/">Google Test</ulink> assertions.</para></listitem></orderedlist>
<orderedlist>
<listitem><para>When a mock objects is destructed, Google <ref refid="class_mock" kindref="compound">Mock</ref> automatically verifies that all expectations on it have been satisfied.</para></listitem></orderedlist>
</para><para>Here is an example: <programlisting><codeline><highlight class="normal">using<sp/>::testing::Return;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>#1</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TEST(BarTest,<sp/>DoesThis)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>#2</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>ON_CALL(foo,<sp/>GetSize())<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>#3</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillByDefault(Return(1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>...<sp/>other<sp/>default<sp/>actions<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Describe(5))<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>#4</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(3)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(&quot;Category<sp/>5&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>...<sp/>other<sp/>expectations<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_EQ(&quot;good&quot;,<sp/>MyProductionFunction(&amp;foo));<sp/><sp/>//<sp/>#5</highlight></codeline>
<codeline><highlight class="normal">}<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>#6</highlight></codeline>
</programlisting></para><para><heading level="1">Setting Default Actions</heading>
</para><para>Google <ref refid="class_mock" kindref="compound">Mock</ref> has a <bold>built-in default action</bold> for any function that returns <computeroutput>void</computeroutput>, <computeroutput>bool</computeroutput>, a numeric value, or a pointer.</para><para>To customize the default action for functions with return type <computeroutput>T</computeroutput> globally: <programlisting><codeline><highlight class="normal">using<sp/>::testing::DefaultValue;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">DefaultValue&lt;T&gt;::Set(value);<sp/><sp/>//<sp/>Sets<sp/>the<sp/>default<sp/>value<sp/>to<sp/>be<sp/>returned.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>...<sp/>use<sp/>the<sp/>mocks<sp/>...</highlight></codeline>
<codeline><highlight class="normal">DefaultValue&lt;T&gt;::Clear();<sp/><sp/><sp/><sp/><sp/>//<sp/>Resets<sp/>the<sp/>default<sp/>value.</highlight></codeline>
</programlisting></para><para>To customize the default action for a particular method, use <computeroutput>ON_CALL()</computeroutput>: <programlisting><codeline><highlight class="normal">ON_CALL(mock_object,<sp/>method(matchers))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.With(multi_argument_matcher)<sp/><sp/>?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.WillByDefault(action);</highlight></codeline>
</programlisting></para><para><heading level="1">Setting Expectations</heading>
</para><para><computeroutput>EXPECT_CALL()</computeroutput> sets <bold>expectations</bold> on a mock method (How will it be called? What will it do?): <programlisting><codeline><highlight class="normal">EXPECT_CALL(mock_object,<sp/>method(matchers))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.With(multi_argument_matcher)<sp/><sp/>?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.Times(cardinality)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.InSequence(sequences)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.After(expectations)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.WillOnce(action)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.WillRepeatedly(action)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.RetiresOnSaturation();<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>?</highlight></codeline>
</programlisting></para><para>If <computeroutput>Times()</computeroutput> is omitted, the cardinality is assumed to be:</para><para><itemizedlist>
<listitem><para><computeroutput>Times(1)</computeroutput> when there is neither <computeroutput>WillOnce()</computeroutput> nor <computeroutput>WillRepeatedly()</computeroutput>;</para></listitem><listitem><para><computeroutput>Times(n)</computeroutput> when there are <computeroutput>n WillOnce()</computeroutput>s but no <computeroutput>WillRepeatedly()</computeroutput>, where <computeroutput>n</computeroutput> &gt;= 1; or</para></listitem><listitem><para><computeroutput>Times(AtLeast(n))</computeroutput> when there are <computeroutput>n WillOnce()</computeroutput>s and a <computeroutput>WillRepeatedly()</computeroutput>, where <computeroutput>n</computeroutput> &gt;= 0.</para></listitem></itemizedlist>
</para><para>A method with no <computeroutput>EXPECT_CALL()</computeroutput> is free to be invoked <emphasis>any number of times</emphasis>, and the default action will be taken each time.</para><para><heading level="1">Matchers</heading>
</para><para>A <bold>matcher</bold> matches a <emphasis>single</emphasis> argument. You can use it inside <computeroutput>ON_CALL()</computeroutput> or <computeroutput>EXPECT_CALL()</computeroutput>, or use it to validate a value directly:</para><para><table rows="2" cols="2"><row>
<entry thead="yes"><para><computeroutput>EXPECT_THAT(value, matcher)</computeroutput> </para></entry><entry thead="yes"><para>Asserts that <computeroutput>value</computeroutput> matches <computeroutput>matcher</computeroutput>.  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>ASSERT_THAT(value, matcher)</computeroutput> </para></entry><entry thead="no"><para>The same as <computeroutput>EXPECT_THAT(value, matcher)</computeroutput>, except that it generates a <bold>fatal</bold> failure. </para></entry></row>
</table>
Built-in matchers (where <computeroutput>argument</computeroutput> is the function argument) are divided into several categories:</para><para><heading level="2">Wildcard</heading>
</para><para><table rows="2" cols="2"><row>
<entry thead="yes"><para><computeroutput>_</computeroutput></para></entry><entry thead="yes"><para><computeroutput>argument</computeroutput> can be any value of the correct type.  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>A&lt;type&gt;()</computeroutput> or <computeroutput>An&lt;type&gt;()</computeroutput></para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> can be any value of type <computeroutput>type</computeroutput>. </para></entry></row>
</table>
<heading level="2">Generic Comparison</heading>
</para><para><table rows="10" cols="2"><row>
<entry thead="yes"><para><computeroutput>Eq(value)</computeroutput> or <computeroutput>value</computeroutput></para></entry><entry thead="yes"><para><computeroutput>argument == value</computeroutput>  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Ge(value)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument &gt;= value</computeroutput> </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Gt(value)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument &gt; value</computeroutput> </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Le(value)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument &lt;= value</computeroutput> </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Lt(value)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument &lt; value</computeroutput> </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Ne(value)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument != value</computeroutput> </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>IsNull()</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> is a <computeroutput>NULL</computeroutput> pointer (raw or smart). </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>NotNull()</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> is a non-null pointer (raw or smart). </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Ref(variable)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> is a reference to <computeroutput>variable</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>TypedEq&lt;type&gt;(value)</computeroutput></para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> has type <computeroutput>type</computeroutput> and is equal to <computeroutput>value</computeroutput>. You may need to use this instead of <computeroutput>Eq(value)</computeroutput> when the mock function is overloaded. </para></entry></row>
</table>
Except <computeroutput>Ref()</computeroutput>, these matchers make a <emphasis>copy</emphasis> of <computeroutput>value</computeroutput> in case it&apos;s modified or destructed later. If the compiler complains that <computeroutput>value</computeroutput> doesn&apos;t have a public copy constructor, try wrap it in <computeroutput>ByRef()</computeroutput>, e.g. <computeroutput>Eq(ByRef(non_copyable_value))</computeroutput>. If you do that, make sure <computeroutput>non_copyable_value</computeroutput> is not changed afterwards, or the meaning of your matcher will be changed.</para><para><heading level="2">Floating-Point Matchers</heading>
</para><para><table rows="4" cols="2"><row>
<entry thead="yes"><para><computeroutput>DoubleEq(a_double)</computeroutput></para></entry><entry thead="yes"><para><computeroutput>argument</computeroutput> is a <computeroutput>double</computeroutput> value approximately equal to <computeroutput>a_double</computeroutput>, treating two NaNs as unequal.  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>FloatEq(a_float)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> is a <computeroutput>float</computeroutput> value approximately equal to <computeroutput>a_float</computeroutput>, treating two NaNs as unequal. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>NanSensitiveDoubleEq(a_double)</computeroutput></para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> is a <computeroutput>double</computeroutput> value approximately equal to <computeroutput>a_double</computeroutput>, treating two NaNs as equal. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>NanSensitiveFloatEq(a_float)</computeroutput></para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> is a <computeroutput>float</computeroutput> value approximately equal to <computeroutput>a_float</computeroutput>, treating two NaNs as equal. </para></entry></row>
</table>
These matchers use ULP-based comparison (the same as used in <ulink url="http://code.google.com/p/googletest/">Google Test</ulink>). They automatically pick a reasonable error bound based on the absolute value of the expected value. <computeroutput>DoubleEq()</computeroutput> and <computeroutput>FloatEq()</computeroutput> conform to the IEEE standard, which requires comparing two NaNs for equality to return false. The <computeroutput>NanSensitive*</computeroutput> version instead treats two NaNs as equal, which is often what a user wants.</para><para><heading level="2">String Matchers</heading>
</para><para>The <computeroutput>argument</computeroutput> can be either a C string or a C++ string object:</para><para><table rows="9" cols="2"><row>
<entry thead="yes"><para><computeroutput>ContainsRegex(string)</computeroutput></para></entry><entry thead="yes"><para><computeroutput>argument</computeroutput> matches the given regular expression.  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>EndsWith(suffix)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> ends with string <computeroutput>suffix</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>HasSubstr(string)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> contains <computeroutput>string</computeroutput> as a sub-string. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>MatchesRegex(string)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> matches the given regular expression with the match starting at the first character and ending at the last character. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>StartsWith(prefix)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> starts with string <computeroutput>prefix</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>StrCaseEq(string)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> is equal to <computeroutput>string</computeroutput>, ignoring case. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>StrCaseNe(string)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> is not equal to <computeroutput>string</computeroutput>, ignoring case. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>StrEq(string)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> is equal to <computeroutput>string</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>StrNe(string)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> is not equal to <computeroutput>string</computeroutput>. </para></entry></row>
</table>
<computeroutput>ContainsRegex()</computeroutput> and <computeroutput>MatchesRegex()</computeroutput> use the regular expression syntax defined <ulink url="http://code.google.com/p/googletest/wiki/V1_6_AdvancedGuide#Regular_Expression_Syntax">here</ulink>. <computeroutput>StrCaseEq()</computeroutput>, <computeroutput>StrCaseNe()</computeroutput>, <computeroutput>StrEq()</computeroutput>, and <computeroutput>StrNe()</computeroutput> work for wide strings as well.</para><para><heading level="2">Container Matchers</heading>
</para><para>Most STL-style containers support <computeroutput>==</computeroutput>, so you can use <computeroutput>Eq(expected_container)</computeroutput> or simply <computeroutput>expected_container</computeroutput> to match a container exactly. If you want to write the elements in-line, match them more flexibly, or get more informative messages, you can use:</para><para><table rows="6" cols="2"><row>
<entry thead="yes"><para><computeroutput>Contains(e)</computeroutput> </para></entry><entry thead="yes"><para><computeroutput>argument</computeroutput> contains an element that matches <computeroutput>e</computeroutput>, which can be either a value or a matcher.  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Each(e)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> is a container where <emphasis>every</emphasis> element matches <computeroutput>e</computeroutput>, which can be either a value or a matcher. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>ElementsAre(e0, e1, ..., en)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> has <computeroutput>n + 1</computeroutput> elements, where the i-th element matches <computeroutput>ei</computeroutput>, which can be a value or a matcher. 0 to 10 arguments are allowed. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>ElementsAreArray(array)</computeroutput> or <computeroutput>ElementsAreArray(array, count)</computeroutput> </para></entry><entry thead="no"><para>The same as <computeroutput>ElementsAre()</computeroutput> except that the expected element values/matchers come from a C-style array. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>ContainerEq(container)</computeroutput> </para></entry><entry thead="no"><para>The same as <computeroutput>Eq(container)</computeroutput> except that the failure message also includes which elements are in one container but not the other. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Pointwise(m, container)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> contains the same number of elements as in <computeroutput>container</computeroutput>, and for all i, (the i-th element in <computeroutput>argument</computeroutput>, the i-th element in <computeroutput>container</computeroutput>) match <computeroutput>m</computeroutput>, which is a matcher on 2-tuples. E.g. <computeroutput>Pointwise(Le(), upper_bounds)</computeroutput> verifies that each element in <computeroutput>argument</computeroutput> doesn&apos;t exceed the corresponding element in <computeroutput>upper_bounds</computeroutput>. </para></entry></row>
</table>
These matchers can also match:</para><para><orderedlist>
<listitem><para>a native array passed by reference (e.g. in <computeroutput>Foo(const int (&amp;a)[5])</computeroutput>), and</para></listitem></orderedlist>
<orderedlist>
<listitem><para>an array passed as a pointer and a count (e.g. in <computeroutput>Bar(const T* buffer, int len)</computeroutput> <ndash/> see Multi-argument Matchers).</para></listitem></orderedlist>
</para><para>where the array may be multi-dimensional (i.e. its elements can be arrays).</para><para><heading level="2">Member Matchers</heading>
</para><para><table rows="4" cols="2"><row>
<entry thead="yes"><para><computeroutput>Field(&amp;class::field, m)</computeroutput></para></entry><entry thead="yes"><para><computeroutput>argument.field</computeroutput> (or <computeroutput>argument-&gt;field</computeroutput> when <computeroutput>argument</computeroutput> is a plain pointer) matches matcher <computeroutput>m</computeroutput>, where <computeroutput>argument</computeroutput> is an object of type <emphasis>class</emphasis>.  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Key(e)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument.first</computeroutput> matches <computeroutput>e</computeroutput>, which can be either a value or a matcher. E.g. <computeroutput>Contains(Key(Le(5)))</computeroutput> can verify that a <computeroutput>map</computeroutput> contains a key <computeroutput>&lt;= 5</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Pair(m1, m2)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> is an <computeroutput>std::pair</computeroutput> whose <computeroutput>first</computeroutput> field matches <computeroutput>m1</computeroutput> and <computeroutput>second</computeroutput> field matches <computeroutput>m2</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Property(&amp;class::property, m)</computeroutput></para></entry><entry thead="no"><para><computeroutput>argument.property()</computeroutput> (or <computeroutput>argument-&gt;property()</computeroutput> when <computeroutput>argument</computeroutput> is a plain pointer) matches matcher <computeroutput>m</computeroutput>, where <computeroutput>argument</computeroutput> is an object of type <emphasis>class</emphasis>. </para></entry></row>
</table>
<heading level="2">Matching the Result of a Function or Functor</heading>
</para><para>|<computeroutput>ResultOf(f, m)</computeroutput>|<computeroutput>f(argument)</computeroutput> matches matcher <computeroutput>m</computeroutput>, where <computeroutput>f</computeroutput> is a function or functor.| |:------------<mdash/>|:------------------------------------------------------------------<mdash/>|</para><para><heading level="2">Pointer Matchers</heading>
</para><para>|<computeroutput>Pointee(m)</computeroutput>|<computeroutput>argument</computeroutput> (either a smart pointer or a raw pointer) points to a value that matches matcher <computeroutput>m</computeroutput>.| |:--------<mdash/>|:--------------------------------------------------------------------------------------------<mdash/>|</para><para><heading level="2">Multiargument Matchers</heading>
</para><para>Technically, all matchers match a <emphasis>single</emphasis> value. A &quot;multi-argument&quot; matcher is just one that matches a <emphasis>tuple</emphasis>. The following matchers can be used to match a tuple <computeroutput>(x, y)</computeroutput>:</para><para><table rows="6" cols="2"><row>
<entry thead="yes"><para><computeroutput>Eq()</computeroutput></para></entry><entry thead="yes"><para><computeroutput>x == y</computeroutput>  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Ge()</computeroutput></para></entry><entry thead="no"><para><computeroutput>x &gt;= y</computeroutput> </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Gt()</computeroutput></para></entry><entry thead="no"><para><computeroutput>x &gt; y</computeroutput> </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Le()</computeroutput></para></entry><entry thead="no"><para><computeroutput>x &lt;= y</computeroutput> </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Lt()</computeroutput></para></entry><entry thead="no"><para><computeroutput>x &lt; y</computeroutput> </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Ne()</computeroutput></para></entry><entry thead="no"><para><computeroutput>x != y</computeroutput> </para></entry></row>
</table>
You can use the following selectors to pick a subset of the arguments (or reorder them) to participate in the matching:</para><para><table rows="2" cols="2"><row>
<entry thead="yes"><para><computeroutput>AllArgs(m)</computeroutput></para></entry><entry thead="yes"><para>Equivalent to <computeroutput>m</computeroutput>. Useful as syntactic sugar in <computeroutput>.With(AllArgs(m))</computeroutput>.  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Args&lt;N1, N2, ..., Nk&gt;(m)</computeroutput></para></entry><entry thead="no"><para>The tuple of the <computeroutput>k</computeroutput> selected (using 0-based indices) arguments matches <computeroutput>m</computeroutput>, e.g. <computeroutput>Args&lt;1, 2&gt;(Eq())</computeroutput>. </para></entry></row>
</table>
<heading level="2">Composite Matchers</heading>
</para><para>You can make a matcher from one or more other matchers:</para><para><table rows="3" cols="2"><row>
<entry thead="yes"><para><computeroutput>AllOf(m1, m2, ..., mn)</computeroutput></para></entry><entry thead="yes"><para><computeroutput>argument</computeroutput> matches all of the matchers <computeroutput>m1</computeroutput> to <computeroutput>mn</computeroutput>.  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>AnyOf(m1, m2, ..., mn)</computeroutput></para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> matches at least one of the matchers <computeroutput>m1</computeroutput> to <computeroutput>mn</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Not(m)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>argument</computeroutput> doesn&apos;t match matcher <computeroutput>m</computeroutput>. </para></entry></row>
</table>
<heading level="2">Adapters for Matchers</heading>
</para><para><table rows="3" cols="2"><row>
<entry thead="yes"><para><computeroutput>MatcherCast&lt;T&gt;(m)</computeroutput></para></entry><entry thead="yes"><para>casts matcher <computeroutput>m</computeroutput> to type <computeroutput>Matcher&lt;T&gt;</computeroutput>.  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>SafeMatcherCast&lt;T&gt;(m)</computeroutput></para></entry><entry thead="no"><para><ulink url="http://code.google.com/p/googlemock/wiki/V1_6_CookBook#Casting_Matchers">safely casts</ulink> matcher <computeroutput>m</computeroutput> to type <computeroutput>Matcher&lt;T&gt;</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Truly(predicate)</computeroutput> </para></entry><entry thead="no"><para><computeroutput>predicate(argument)</computeroutput> returns something considered by C++ to be true, where <computeroutput>predicate</computeroutput> is a function or functor. </para></entry></row>
</table>
<heading level="2">Matchers as Predicates</heading>
</para><para><table rows="3" cols="2"><row>
<entry thead="yes"><para><computeroutput>Matches(m)(value)</computeroutput></para></entry><entry thead="yes"><para>evaluates to <computeroutput>true</computeroutput> if <computeroutput>value</computeroutput> matches <computeroutput>m</computeroutput>. You can use <computeroutput>Matches(m)</computeroutput> alone as a unary functor.  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>ExplainMatchResult(m, value, result_listener)</computeroutput></para></entry><entry thead="no"><para>evaluates to <computeroutput>true</computeroutput> if <computeroutput>value</computeroutput> matches <computeroutput>m</computeroutput>, explaining the result to <computeroutput>result_listener</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Value(value, m)</computeroutput> </para></entry><entry thead="no"><para>evaluates to <computeroutput>true</computeroutput> if <computeroutput>value</computeroutput> matches <computeroutput>m</computeroutput>. </para></entry></row>
</table>
<heading level="2">Defining Matchers</heading>
</para><para><table rows="3" cols="2"><row>
<entry thead="yes"><para><computeroutput>MATCHER(IsEven, &quot;&quot;) { return (arg % 2) == 0; }</computeroutput> </para></entry><entry thead="yes"><para>Defines a matcher <computeroutput>IsEven()</computeroutput> to match an even number.  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>MATCHER_P(IsDivisibleBy, n, &quot;&quot;) { *result_listener &lt;&lt; &quot;where the remainder is &quot; &lt;&lt; (arg % n); return (arg % n) == 0; }</computeroutput> </para></entry><entry thead="no"><para>Defines a macher <computeroutput>IsDivisibleBy(n)</computeroutput> to match a number divisible by <computeroutput>n</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>MATCHER_P2(IsBetween, a, b, std::string(negation ? &quot;isn&apos;t&quot; : &quot;is&quot;) + &quot; between &quot; + PrintToString(a) + &quot; and &quot; + PrintToString(b)) { return a &lt;= arg &amp;&amp; arg &lt;= b; }</computeroutput> </para></entry><entry thead="no"><para>Defines a matcher <computeroutput>IsBetween(a, b)</computeroutput> to match a value in the range [<computeroutput>a</computeroutput>, <computeroutput>b</computeroutput>]. </para></entry></row>
</table>
<bold>Notes:</bold></para><para><orderedlist>
<listitem><para>The <computeroutput>MATCHER*</computeroutput> macros cannot be used inside a function or class.</para></listitem></orderedlist>
<orderedlist>
<listitem><para>The matcher body must be <emphasis>purely functional</emphasis> (i.e. it cannot have any side effect, and the result must not depend on anything other than the value being matched and the matcher parameters).</para></listitem></orderedlist>
<orderedlist>
<listitem><para>You can use <computeroutput>PrintToString(x)</computeroutput> to convert a value <computeroutput>x</computeroutput> of any type to a string.</para></listitem></orderedlist>
</para><para><heading level="2">Matchers as Test Assertions</heading>
</para><para><table rows="2" cols="2"><row>
<entry thead="yes"><para><computeroutput>ASSERT_THAT(expression, m)</computeroutput></para></entry><entry thead="yes"><para>Generates a <ulink url="http://code.google.com/p/googletest/wiki/V1_6_Primer#Assertions">fatal failure</ulink> if the value of <computeroutput>expression</computeroutput> doesn&apos;t match matcher <computeroutput>m</computeroutput>.  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>EXPECT_THAT(expression, m)</computeroutput></para></entry><entry thead="no"><para>Generates a non-fatal failure if the value of <computeroutput>expression</computeroutput> doesn&apos;t match matcher <computeroutput>m</computeroutput>. </para></entry></row>
</table>
<heading level="1">Actions</heading>
</para><para><bold>Actions</bold> specify what a mock function should do when invoked.</para><para><heading level="2">Returning a Value</heading>
</para><para><table rows="8" cols="2"><row>
<entry thead="yes"><para><computeroutput>Return()</computeroutput></para></entry><entry thead="yes"><para>Return from a <computeroutput>void</computeroutput> mock function.  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Return(value)</computeroutput></para></entry><entry thead="no"><para>Return <computeroutput>value</computeroutput>. If the type of <computeroutput>value</computeroutput> is different to the mock function&apos;s return type, <computeroutput>value</computeroutput> is converted to the latter type <emphasis>at the time the expectation is set</emphasis>, not when the action is executed. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>ReturnArg&lt;N&gt;()</computeroutput></para></entry><entry thead="no"><para>Return the <computeroutput>N</computeroutput>-th (0-based) argument. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>ReturnNew&lt;T&gt;(a1, ..., ak)</computeroutput></para></entry><entry thead="no"><para>Return <computeroutput>new T(a1, ..., ak)</computeroutput>; a different object is created each time. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>ReturnNull()</computeroutput></para></entry><entry thead="no"><para>Return a null pointer. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>ReturnPointee(ptr)</computeroutput></para></entry><entry thead="no"><para>Return the value pointed to by <computeroutput>ptr</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>ReturnRef(variable)</computeroutput></para></entry><entry thead="no"><para>Return a reference to <computeroutput>variable</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>ReturnRefOfCopy(value)</computeroutput></para></entry><entry thead="no"><para>Return a reference to a copy of <computeroutput>value</computeroutput>; the copy lives as long as the action. </para></entry></row>
</table>
<heading level="2">Side Effects</heading>
</para><para><table rows="10" cols="2"><row>
<entry thead="yes"><para><computeroutput>Assign(&amp;variable, value)</computeroutput></para></entry><entry thead="yes"><para>Assign <computeroutput>value</computeroutput> to variable.  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>DeleteArg&lt;N&gt;()</computeroutput> </para></entry><entry thead="no"><para>Delete the <computeroutput>N</computeroutput>-th (0-based) argument, which must be a pointer. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>SaveArg&lt;N&gt;(pointer)</computeroutput> </para></entry><entry thead="no"><para>Save the <computeroutput>N</computeroutput>-th (0-based) argument to <computeroutput>*pointer</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>SaveArgPointee&lt;N&gt;(pointer)</computeroutput> </para></entry><entry thead="no"><para>Save the value pointed to by the <computeroutput>N</computeroutput>-th (0-based) argument to <computeroutput>*pointer</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>SetArgReferee&lt;N&gt;(value)</computeroutput> </para></entry><entry thead="no"><para>Assign value to the variable referenced by the <computeroutput>N</computeroutput>-th (0-based) argument. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>SetArgPointee&lt;N&gt;(value)</computeroutput> </para></entry><entry thead="no"><para>Assign <computeroutput>value</computeroutput> to the variable pointed by the <computeroutput>N</computeroutput>-th (0-based) argument. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>SetArgumentPointee&lt;N&gt;(value)</computeroutput></para></entry><entry thead="no"><para>Same as <computeroutput>SetArgPointee&lt;N&gt;(value)</computeroutput>. Deprecated. Will be removed in v1.7.0. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>SetArrayArgument&lt;N&gt;(first, last)</computeroutput></para></entry><entry thead="no"><para>Copies the elements in source range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) to the array pointed to by the <computeroutput>N</computeroutput>-th (0-based) argument, which can be either a pointer or an iterator. The action does not take ownership of the elements in the source range. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>SetErrnoAndReturn(error, value)</computeroutput></para></entry><entry thead="no"><para>Set <computeroutput>errno</computeroutput> to <computeroutput>error</computeroutput> and return <computeroutput>value</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Throw(exception)</computeroutput> </para></entry><entry thead="no"><para>Throws the given exception, which can be any copyable value. Available since v1.1.0. </para></entry></row>
</table>
<heading level="2">Using a Function or a Functor as an Action</heading>
</para><para><table rows="5" cols="2"><row>
<entry thead="yes"><para><computeroutput>Invoke(f)</computeroutput></para></entry><entry thead="yes"><para>Invoke <computeroutput>f</computeroutput> with the arguments passed to the mock function, where <computeroutput>f</computeroutput> can be a global/static function or a functor.  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Invoke(object_pointer, &amp;class::method)</computeroutput></para></entry><entry thead="no"><para>Invoke the {method on the object with the arguments passed to the mock function. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>InvokeWithoutArgs(f)</computeroutput></para></entry><entry thead="no"><para>Invoke <computeroutput>f</computeroutput>, which can be a global/static function or a functor. <computeroutput>f</computeroutput> must take no arguments. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>InvokeWithoutArgs(object_pointer, &amp;class::method)</computeroutput></para></entry><entry thead="no"><para>Invoke the method on the object, which takes no arguments. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>InvokeArgument&lt;N&gt;(arg1, arg2, ..., argk)</computeroutput></para></entry><entry thead="no"><para>Invoke the mock function&apos;s <computeroutput>N</computeroutput>-th (0-based) argument, which must be a function or a functor, with the <computeroutput>k</computeroutput> arguments. </para></entry></row>
</table>
The return value of the invoked function is used as the return value of the action.</para><para>When defining a function or functor to be used with <computeroutput>Invoke*()</computeroutput>, you can declare any unused parameters as <computeroutput>Unused</computeroutput>: <programlisting><codeline><highlight class="normal">double<sp/>Distance(Unused,<sp/>double<sp/>x,<sp/>double<sp/>y)<sp/>{<sp/>return<sp/>sqrt(x*x<sp/>+<sp/>y*y);<sp/>}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(mock,<sp/>Foo(&quot;Hi&quot;,<sp/>_,<sp/>_)).WillOnce(Invoke(Distance));</highlight></codeline>
</programlisting></para><para>In <computeroutput>InvokeArgument&lt;N&gt;(...)</computeroutput>, if an argument needs to be passed by reference, wrap it inside <computeroutput>ByRef()</computeroutput>. For example, <programlisting><codeline><highlight class="normal">InvokeArgument&lt;2&gt;(5,<sp/>string(&quot;Hi&quot;),<sp/>ByRef(foo))</highlight></codeline>
</programlisting> calls the mock function&apos;s #2 argument, passing to it <computeroutput>5</computeroutput> and <computeroutput>string(&quot;Hi&quot;)</computeroutput> by value, and <computeroutput>foo</computeroutput> by reference.</para><para><heading level="2">Default Action</heading>
</para><para>|<computeroutput>DoDefault()</computeroutput>|Do the default action (specified by <computeroutput>ON_CALL()</computeroutput> or the built-in one).| |:---------<mdash/>|:-----------------------------------------------------------------<mdash/>|</para><para><bold>Note:</bold> due to technical reasons, <computeroutput>DoDefault()</computeroutput> cannot be used inside a composite action - trying to do so will result in a run-time error.</para><para><heading level="2">Composite Actions</heading>
</para><para><table rows="5" cols="2"><row>
<entry thead="yes"><para><computeroutput>DoAll(a1, a2, ..., an)</computeroutput></para></entry><entry thead="yes"><para>Do all actions <computeroutput>a1</computeroutput> to <computeroutput>an</computeroutput> and return the result of <computeroutput>an</computeroutput> in each invocation. The first <computeroutput>n - 1</computeroutput> sub-actions must return void.  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>IgnoreResult(a)</computeroutput> </para></entry><entry thead="no"><para>Perform action <computeroutput>a</computeroutput> and ignore its result. <computeroutput>a</computeroutput> must not return void. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>WithArg&lt;N&gt;(a)</computeroutput> </para></entry><entry thead="no"><para>Pass the <computeroutput>N</computeroutput>-th (0-based) argument of the mock function to action <computeroutput>a</computeroutput> and perform it. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>WithArgs&lt;N1, N2, ..., Nk&gt;(a)</computeroutput></para></entry><entry thead="no"><para>Pass the selected (0-based) arguments of the mock function to action <computeroutput>a</computeroutput> and perform it. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>WithoutArgs(a)</computeroutput> </para></entry><entry thead="no"><para>Perform action <computeroutput>a</computeroutput> without any arguments. </para></entry></row>
</table>
<heading level="2">Defining Actions</heading>
</para><para><table rows="3" cols="2"><row>
<entry thead="yes"><para><computeroutput>ACTION(Sum) { return arg0 + arg1; }</computeroutput> </para></entry><entry thead="yes"><para>Defines an action <computeroutput>Sum()</computeroutput> to return the sum of the mock function&apos;s argument #0 and #1.  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>ACTION_P(Plus, n) { return arg0 + n; }</computeroutput> </para></entry><entry thead="no"><para>Defines an action <computeroutput>Plus(n)</computeroutput> to return the sum of the mock function&apos;s argument #0 and <computeroutput>n</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>ACTION_Pk(Foo, p1, ..., pk) { statements; }</computeroutput> </para></entry><entry thead="no"><para>Defines a parameterized action <computeroutput>Foo(p1, ..., pk)</computeroutput> to execute the given <computeroutput>statements</computeroutput>. </para></entry></row>
</table>
The <computeroutput>ACTION*</computeroutput> macros cannot be used inside a function or class.</para><para><heading level="1">Cardinalities</heading>
</para><para>These are used in <computeroutput>Times()</computeroutput> to specify how many times a mock function will be called:</para><para><table rows="5" cols="2"><row>
<entry thead="yes"><para><computeroutput>AnyNumber()</computeroutput></para></entry><entry thead="yes"><para>The function can be called any number of times.  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>AtLeast(n)</computeroutput> </para></entry><entry thead="no"><para>The call is expected at least <computeroutput>n</computeroutput> times. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>AtMost(n)</computeroutput> </para></entry><entry thead="no"><para>The call is expected at most <computeroutput>n</computeroutput> times. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Between(m, n)</computeroutput></para></entry><entry thead="no"><para>The call is expected between <computeroutput>m</computeroutput> and <computeroutput>n</computeroutput> (inclusive) times. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>Exactly(n) or n</computeroutput></para></entry><entry thead="no"><para>The call is expected exactly <computeroutput>n</computeroutput> times. In particular, the call should never happen when <computeroutput>n</computeroutput> is 0. </para></entry></row>
</table>
<heading level="1">Expectation Order</heading>
</para><para>By default, the expectations can be matched in <emphasis>any</emphasis> order. If some or all expectations must be matched in a given order, there are two ways to specify it. They can be used either independently or together.</para><para><heading level="2">The After Clause</heading>
</para><para><programlisting><codeline><highlight class="normal">using<sp/>::testing::Expectation;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">Expectation<sp/>init_x<sp/>=<sp/>EXPECT_CALL(foo,<sp/>InitX());</highlight></codeline>
<codeline><highlight class="normal">Expectation<sp/>init_y<sp/>=<sp/>EXPECT_CALL(foo,<sp/>InitY());</highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(foo,<sp/>Bar())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.After(init_x,<sp/>init_y);</highlight></codeline>
</programlisting> says that <computeroutput>Bar()</computeroutput> can be called only after both <computeroutput>InitX()</computeroutput> and <computeroutput>InitY()</computeroutput> have been called.</para><para>If you don&apos;t know how many pre-requisites an expectation has when you write it, you can use an <computeroutput>ExpectationSet</computeroutput> to collect them:</para><para><programlisting><codeline><highlight class="normal">using<sp/>::testing::ExpectationSet;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">ExpectationSet<sp/>all_inits;</highlight></codeline>
<codeline><highlight class="normal">for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>element_count;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>all_inits<sp/>+=<sp/>EXPECT_CALL(foo,<sp/>InitElement(i));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(foo,<sp/>Bar())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.After(all_inits);</highlight></codeline>
</programlisting> says that <computeroutput>Bar()</computeroutput> can be called only after all elements have been initialized (but we don&apos;t care about which elements get initialized before the others).</para><para>Modifying an <computeroutput>ExpectationSet</computeroutput> after using it in an <computeroutput>.After()</computeroutput> doesn&apos;t affect the meaning of the <computeroutput>.After()</computeroutput>.</para><para><heading level="2">Sequences</heading>
</para><para>When you have a long chain of sequential expectations, it&apos;s easier to specify the order using <bold>sequences</bold>, which don&apos;t require you to given each expectation in the chain a different name. <emphasis>All expected<linebreak/>
 calls</emphasis> in the same sequence must occur in the order they are specified.</para><para><programlisting><codeline><highlight class="normal">using<sp/>::testing::Sequence;</highlight></codeline>
<codeline><highlight class="normal">Sequence<sp/>s1,<sp/>s2;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(foo,<sp/>Reset())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.InSequence(s1,<sp/>s2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.WillOnce(Return(true));</highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(foo,<sp/>GetSize())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.InSequence(s1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.WillOnce(Return(1));</highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(foo,<sp/>Describe(A&lt;const<sp/>char*&gt;()))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.InSequence(s2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.WillOnce(Return(&quot;dummy&quot;));</highlight></codeline>
</programlisting> says that <computeroutput>Reset()</computeroutput> must be called before <emphasis>both</emphasis> <computeroutput>GetSize()</computeroutput> <emphasis>and</emphasis> <computeroutput>Describe()</computeroutput>, and the latter two can occur in any order.</para><para>To put many expectations in a sequence conveniently: <programlisting><codeline><highlight class="normal">using<sp/>::testing::InSequence;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>InSequence<sp/>dummy;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(...)...;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(...)...;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(...)...;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> says that all expected calls in the scope of <computeroutput>dummy</computeroutput> must occur in strict order. The name <computeroutput>dummy</computeroutput> is irrelevant.)</para><para><heading level="1">Verifying and Resetting a <ref refid="class_mock" kindref="compound">Mock</ref></heading>
</para><para>Google <ref refid="class_mock" kindref="compound">Mock</ref> will verify the expectations on a mock object when it is destructed, or you can do it earlier: <programlisting><codeline><highlight class="normal">using<sp/>::testing::Mock;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Verifies<sp/>and<sp/>removes<sp/>the<sp/>expectations<sp/>on<sp/>mock_obj;</highlight></codeline>
<codeline><highlight class="normal">//<sp/>returns<sp/>true<sp/>iff<sp/>successful.</highlight></codeline>
<codeline><highlight class="normal">Mock::VerifyAndClearExpectations(&amp;mock_obj);</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Verifies<sp/>and<sp/>removes<sp/>the<sp/>expectations<sp/>on<sp/>mock_obj;</highlight></codeline>
<codeline><highlight class="normal">//<sp/>also<sp/>removes<sp/>the<sp/>default<sp/>actions<sp/>set<sp/>by<sp/>ON_CALL();</highlight></codeline>
<codeline><highlight class="normal">//<sp/>returns<sp/>true<sp/>iff<sp/>successful.</highlight></codeline>
<codeline><highlight class="normal">Mock::VerifyAndClear(&amp;mock_obj);</highlight></codeline>
</programlisting></para><para>You can also tell Google <ref refid="class_mock" kindref="compound">Mock</ref> that a mock object can be leaked and doesn&apos;t need to be verified: <programlisting><codeline><highlight class="normal">Mock::AllowLeak(&amp;mock_obj);</highlight></codeline>
</programlisting></para><para><heading level="1"><ref refid="class_mock" kindref="compound">Mock</ref> Classes</heading>
</para><para>Google <ref refid="class_mock" kindref="compound">Mock</ref> defines a convenient mock class template <programlisting><codeline><highlight class="normal">class<sp/>MockFunction&lt;R(A1,<sp/>...,<sp/>An)&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHODn(Call,<sp/>R(A1,<sp/>...,<sp/>An));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting> See this <ulink url="http://code.google.com/p/googlemock/wiki/V1_6_CookBook#Using_Check_Points">recipe</ulink> for one application of it.</para><para><heading level="1">Flags</heading>
</para><para><table rows="2" cols="2"><row>
<entry thead="yes"><para><computeroutput>--gmock_catch_leaked_mocks=0</computeroutput> </para></entry><entry thead="yes"><para>Don&apos;t report leaked mock objects as failures.  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>--gmock_verbose=LEVEL</computeroutput> </para></entry><entry thead="no"><para>Sets the default verbosity level (<computeroutput>info</computeroutput>, <computeroutput>warning</computeroutput>, or <computeroutput>error</computeroutput>) of Google <ref refid="class_mock" kindref="compound">Mock</ref> messages. </para></entry></row>
</table>
</para>    </detaileddescription>
  </compounddef>
</doxygen>
