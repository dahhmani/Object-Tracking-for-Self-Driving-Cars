<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="_cook_book_8md" kind="file" language="Markdown">
    <compoundname>CookBook.md</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>find<sp/>recipes<sp/>for<sp/>using<sp/>Google<sp/>Mock<sp/>here.<sp/>If<sp/>you<sp/>haven&apos;t<sp/>yet,</highlight></codeline>
<codeline><highlight class="normal">please<sp/>read<sp/>the<sp/>[ForDummies](ForDummies.md)<sp/>document<sp/>first<sp/>to<sp/>make<sp/>sure<sp/>you<sp/>understand</highlight></codeline>
<codeline><highlight class="normal">the<sp/>basics.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**Note:**<sp/>Google<sp/>Mock<sp/>lives<sp/>in<sp/>the<sp/>`testing`<sp/>name<sp/>space.<sp/>For</highlight></codeline>
<codeline><highlight class="normal">readability,<sp/>it<sp/>is<sp/>recommended<sp/>to<sp/>write<sp/>`using<sp/>::testing::Foo;`<sp/>once<sp/>in</highlight></codeline>
<codeline><highlight class="normal">your<sp/>file<sp/>before<sp/>using<sp/>the<sp/>name<sp/>`Foo`<sp/>defined<sp/>by<sp/>Google<sp/>Mock.<sp/>We<sp/>omit</highlight></codeline>
<codeline><highlight class="normal">such<sp/>`using`<sp/>statements<sp/>in<sp/>this<sp/>page<sp/>for<sp/>brevity,<sp/>but<sp/>you<sp/>should<sp/>do<sp/>it</highlight></codeline>
<codeline><highlight class="normal">in<sp/>your<sp/>own<sp/>code.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#<sp/>Creating<sp/>Mock<sp/>Classes<sp/>#</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Mocking<sp/>Private<sp/>or<sp/>Protected<sp/>Methods<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>must<sp/>always<sp/>put<sp/>a<sp/>mock<sp/>method<sp/>definition<sp/>(`MOCK_METHOD*`)<sp/>in<sp/>a</highlight></codeline>
<codeline><highlight class="normal">`public:`<sp/>section<sp/>of<sp/>the<sp/>mock<sp/>class,<sp/>regardless<sp/>of<sp/>the<sp/>method<sp/>being</highlight></codeline>
<codeline><highlight class="normal">mocked<sp/>being<sp/>`public`,<sp/>`protected`,<sp/>or<sp/>`private`<sp/>in<sp/>the<sp/>base<sp/>class.</highlight></codeline>
<codeline><highlight class="normal">This<sp/>allows<sp/>`ON_CALL`<sp/>and<sp/>`EXPECT_CALL`<sp/>to<sp/>reference<sp/>the<sp/>mock<sp/>function</highlight></codeline>
<codeline><highlight class="normal">from<sp/>outside<sp/>of<sp/>the<sp/>mock<sp/>class.<sp/><sp/>(Yes,<sp/>C++<sp/>allows<sp/>a<sp/>subclass<sp/>to<sp/>change</highlight></codeline>
<codeline><highlight class="normal">the<sp/>access<sp/>level<sp/>of<sp/>a<sp/>virtual<sp/>function<sp/>in<sp/>the<sp/>base<sp/>class.)<sp/><sp/>Example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">class<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>bool<sp/>Transform(Gadget*<sp/>g)<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>protected:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>Resume();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>int<sp/>GetTimeOut();</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(Transform,<sp/>bool(Gadget*<sp/>g));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>following<sp/>must<sp/>be<sp/>in<sp/>the<sp/>public<sp/>section,<sp/>even<sp/>though<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>methods<sp/>are<sp/>protected<sp/>or<sp/>private<sp/>in<sp/>the<sp/>base<sp/>class.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD0(Resume,<sp/>void());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD0(GetTimeOut,<sp/>int());</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Mocking<sp/>Overloaded<sp/>Methods<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>mock<sp/>overloaded<sp/>functions<sp/>as<sp/>usual.<sp/>No<sp/>special<sp/>attention<sp/>is<sp/>required:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">class<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Must<sp/>be<sp/>virtual<sp/>as<sp/>we&apos;ll<sp/>inherit<sp/>from<sp/>Foo.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~Foo();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Overloaded<sp/>on<sp/>the<sp/>types<sp/>and/or<sp/>numbers<sp/>of<sp/>arguments.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>int<sp/>Add(Element<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>int<sp/>Add(int<sp/>times,<sp/>Element<sp/>x);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Overloaded<sp/>on<sp/>the<sp/>const-ness<sp/>of<sp/>this<sp/>object.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>Bar&amp;<sp/>GetBar();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>const<sp/>Bar&amp;<sp/>GetBar()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(Add,<sp/>int(Element<sp/>x));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD2(Add,<sp/>int(int<sp/>times,<sp/>Element<sp/>x);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD0(GetBar,<sp/>Bar&amp;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_CONST_METHOD0(GetBar,<sp/>const<sp/>Bar&amp;());</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**Note:**<sp/>if<sp/>you<sp/>don&apos;t<sp/>mock<sp/>all<sp/>versions<sp/>of<sp/>the<sp/>overloaded<sp/>method,<sp/>the</highlight></codeline>
<codeline><highlight class="normal">compiler<sp/>will<sp/>give<sp/>you<sp/>a<sp/>warning<sp/>about<sp/>some<sp/>methods<sp/>in<sp/>the<sp/>base<sp/>class</highlight></codeline>
<codeline><highlight class="normal">being<sp/>hidden.<sp/>To<sp/>fix<sp/>that,<sp/>use<sp/>`using`<sp/>to<sp/>bring<sp/>them<sp/>in<sp/>scope:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>Foo::Add;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(Add,<sp/>int(Element<sp/>x));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>We<sp/>don&apos;t<sp/>want<sp/>to<sp/>mock<sp/>int<sp/>Add(int<sp/>times,<sp/>Element<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Mocking<sp/>Class<sp/>Templates<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">To<sp/>mock<sp/>a<sp/>class<sp/>template,<sp/>append<sp/>`_T`<sp/>to<sp/>the<sp/>`MOCK_*`<sp/>macros:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>Elem&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>StackInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Must<sp/>be<sp/>virtual<sp/>as<sp/>we&apos;ll<sp/>inherit<sp/>from<sp/>StackInterface.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~StackInterface();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>int<sp/>GetSize()<sp/>const<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>Push(const<sp/>Elem&amp;<sp/>x)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>Elem&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockStack<sp/>:<sp/>public<sp/>StackInterface&lt;Elem&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_CONST_METHOD0_T(GetSize,<sp/>int());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1_T(Push,<sp/>void(const<sp/>Elem&amp;<sp/>x));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Mocking<sp/>Nonvirtual<sp/>Methods<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Google<sp/>Mock<sp/>can<sp/>mock<sp/>non-virtual<sp/>functions<sp/>to<sp/>be<sp/>used<sp/>in<sp/>what<sp/>we<sp/>call<sp/>_hi-perf</highlight></codeline>
<codeline><highlight class="normal">dependency<sp/>injection_.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">In<sp/>this<sp/>case,<sp/>instead<sp/>of<sp/>sharing<sp/>a<sp/>common<sp/>base<sp/>class<sp/>with<sp/>the<sp/>real</highlight></codeline>
<codeline><highlight class="normal">class,<sp/>your<sp/>mock<sp/>class<sp/>will<sp/>be<sp/>_unrelated_<sp/>to<sp/>the<sp/>real<sp/>class,<sp/>but</highlight></codeline>
<codeline><highlight class="normal">contain<sp/>methods<sp/>with<sp/>the<sp/>same<sp/>signatures.<sp/><sp/>The<sp/>syntax<sp/>for<sp/>mocking</highlight></codeline>
<codeline><highlight class="normal">non-virtual<sp/>methods<sp/>is<sp/>the<sp/>_same_<sp/>as<sp/>mocking<sp/>virtual<sp/>methods:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">//<sp/>A<sp/>simple<sp/>packet<sp/>stream<sp/>class.<sp/><sp/>None<sp/>of<sp/>its<sp/>members<sp/>is<sp/>virtual.</highlight></codeline>
<codeline><highlight class="normal">class<sp/>ConcretePacketStream<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>AppendPacket(Packet*<sp/>new_packet);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>Packet*<sp/>GetPacket(size_t<sp/>packet_number)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>NumberOfPackets()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>A<sp/>mock<sp/>packet<sp/>stream<sp/>class.<sp/><sp/>It<sp/>inherits<sp/>from<sp/>no<sp/>other,<sp/>but<sp/>defines</highlight></codeline>
<codeline><highlight class="normal">//<sp/>GetPacket()<sp/>and<sp/>NumberOfPackets().</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockPacketStream<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_CONST_METHOD1(GetPacket,<sp/>const<sp/>Packet*(size_t<sp/>packet_number));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_CONST_METHOD0(NumberOfPackets,<sp/>size_t());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>the<sp/>mock<sp/>class<sp/>doesn&apos;t<sp/>define<sp/>`AppendPacket()`,<sp/>unlike<sp/>the</highlight></codeline>
<codeline><highlight class="normal">real<sp/>class.<sp/>That&apos;s<sp/>fine<sp/>as<sp/>long<sp/>as<sp/>the<sp/>test<sp/>doesn&apos;t<sp/>need<sp/>to<sp/>call<sp/>it.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Next,<sp/>you<sp/>need<sp/>a<sp/>way<sp/>to<sp/>say<sp/>that<sp/>you<sp/>want<sp/>to<sp/>use</highlight></codeline>
<codeline><highlight class="normal">`ConcretePacketStream`<sp/>in<sp/>production<sp/>code,<sp/>and<sp/>use<sp/>`MockPacketStream`</highlight></codeline>
<codeline><highlight class="normal">in<sp/>tests.<sp/><sp/>Since<sp/>the<sp/>functions<sp/>are<sp/>not<sp/>virtual<sp/>and<sp/>the<sp/>two<sp/>classes<sp/>are</highlight></codeline>
<codeline><highlight class="normal">unrelated,<sp/>you<sp/>must<sp/>specify<sp/>your<sp/>choice<sp/>at<sp/>_compile<sp/>time_<sp/>(as<sp/>opposed</highlight></codeline>
<codeline><highlight class="normal">to<sp/>run<sp/>time).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">One<sp/>way<sp/>to<sp/>do<sp/>it<sp/>is<sp/>to<sp/>templatize<sp/>your<sp/>code<sp/>that<sp/>needs<sp/>to<sp/>use<sp/>a<sp/>packet</highlight></codeline>
<codeline><highlight class="normal">stream.<sp/><sp/>More<sp/>specifically,<sp/>you<sp/>will<sp/>give<sp/>your<sp/>code<sp/>a<sp/>template<sp/>type</highlight></codeline>
<codeline><highlight class="normal">argument<sp/>for<sp/>the<sp/>type<sp/>of<sp/>the<sp/>packet<sp/>stream.<sp/><sp/>In<sp/>production,<sp/>you<sp/>will</highlight></codeline>
<codeline><highlight class="normal">instantiate<sp/>your<sp/>template<sp/>with<sp/>`ConcretePacketStream`<sp/>as<sp/>the<sp/>type</highlight></codeline>
<codeline><highlight class="normal">argument.<sp/><sp/>In<sp/>tests,<sp/>you<sp/>will<sp/>instantiate<sp/>the<sp/>same<sp/>template<sp/>with</highlight></codeline>
<codeline><highlight class="normal">`MockPacketStream`.<sp/><sp/>For<sp/>example,<sp/>you<sp/>may<sp/>write:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>PacketStream&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>CreateConnection(PacketStream*<sp/>stream)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>PacketStream&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>PacketReader<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>ReadPackets(PacketStream*<sp/>stream,<sp/>size_t<sp/>packet_num);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Then<sp/>you<sp/>can<sp/>use<sp/>`CreateConnection&lt;ConcretePacketStream&gt;()`<sp/>and</highlight></codeline>
<codeline><highlight class="normal">`PacketReader&lt;ConcretePacketStream&gt;`<sp/>in<sp/>production<sp/>code,<sp/>and<sp/>use</highlight></codeline>
<codeline><highlight class="normal">`CreateConnection&lt;MockPacketStream&gt;()`<sp/>and</highlight></codeline>
<codeline><highlight class="normal">`PacketReader&lt;MockPacketStream&gt;`<sp/>in<sp/>tests.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockPacketStream<sp/>mock_stream;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_stream,<sp/>...)...;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>..<sp/>set<sp/>more<sp/>expectations<sp/>on<sp/>mock_stream<sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PacketReader&lt;MockPacketStream&gt;<sp/>reader(&amp;mock_stream);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>exercise<sp/>reader<sp/>...</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Mocking<sp/>Free<sp/>Functions<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">It&apos;s<sp/>possible<sp/>to<sp/>use<sp/>Google<sp/>Mock<sp/>to<sp/>mock<sp/>a<sp/>free<sp/>function<sp/>(i.e.<sp/>a</highlight></codeline>
<codeline><highlight class="normal">C-style<sp/>function<sp/>or<sp/>a<sp/>static<sp/>method).<sp/><sp/>You<sp/>just<sp/>need<sp/>to<sp/>rewrite<sp/>your</highlight></codeline>
<codeline><highlight class="normal">code<sp/>to<sp/>use<sp/>an<sp/>interface<sp/>(abstract<sp/>class).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Instead<sp/>of<sp/>calling<sp/>a<sp/>free<sp/>function<sp/>(say,<sp/>`OpenFile`)<sp/>directly,</highlight></codeline>
<codeline><highlight class="normal">introduce<sp/>an<sp/>interface<sp/>for<sp/>it<sp/>and<sp/>have<sp/>a<sp/>concrete<sp/>subclass<sp/>that<sp/>calls</highlight></codeline>
<codeline><highlight class="normal">the<sp/>free<sp/>function:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">class<sp/>FileInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>bool<sp/>Open(const<sp/>char*<sp/>path,<sp/>const<sp/>char*<sp/>mode)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>File<sp/>:<sp/>public<sp/>FileInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>bool<sp/>Open(const<sp/>char*<sp/>path,<sp/>const<sp/>char*<sp/>mode)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>OpenFile(path,<sp/>mode);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Your<sp/>code<sp/>should<sp/>talk<sp/>to<sp/>`FileInterface`<sp/>to<sp/>open<sp/>a<sp/>file.<sp/><sp/>Now<sp/>it&apos;s</highlight></codeline>
<codeline><highlight class="normal">easy<sp/>to<sp/>mock<sp/>out<sp/>the<sp/>function.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>may<sp/>seem<sp/>much<sp/>hassle,<sp/>but<sp/>in<sp/>practice<sp/>you<sp/>often<sp/>have<sp/>multiple</highlight></codeline>
<codeline><highlight class="normal">related<sp/>functions<sp/>that<sp/>you<sp/>can<sp/>put<sp/>in<sp/>the<sp/>same<sp/>interface,<sp/>so<sp/>the</highlight></codeline>
<codeline><highlight class="normal">per-function<sp/>syntactic<sp/>overhead<sp/>will<sp/>be<sp/>much<sp/>lower.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>are<sp/>concerned<sp/>about<sp/>the<sp/>performance<sp/>overhead<sp/>incurred<sp/>by</highlight></codeline>
<codeline><highlight class="normal">virtual<sp/>functions,<sp/>and<sp/>profiling<sp/>confirms<sp/>your<sp/>concern,<sp/>you<sp/>can</highlight></codeline>
<codeline><highlight class="normal">combine<sp/>this<sp/>with<sp/>the<sp/>recipe<sp/>for<sp/>[mocking<sp/>non-virtual<sp/>methods](#mocking-nonvirtual-methods).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>The<sp/>Nice,<sp/>the<sp/>Strict,<sp/>and<sp/>the<sp/>Naggy<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>a<sp/>mock<sp/>method<sp/>has<sp/>no<sp/>`EXPECT_CALL`<sp/>spec<sp/>but<sp/>is<sp/>called,<sp/>Google<sp/>Mock</highlight></codeline>
<codeline><highlight class="normal">will<sp/>print<sp/>a<sp/>warning<sp/>about<sp/>the<sp/>&quot;uninteresting<sp/>call&quot;.<sp/>The<sp/>rationale<sp/>is:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>New<sp/>methods<sp/>may<sp/>be<sp/>added<sp/>to<sp/>an<sp/>interface<sp/>after<sp/>a<sp/>test<sp/>is<sp/>written.<sp/>We<sp/>shouldn&apos;t<sp/>fail<sp/>a<sp/>test<sp/>just<sp/>because<sp/>a<sp/>method<sp/>it<sp/>doesn&apos;t<sp/>know<sp/>about<sp/>is<sp/>called.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>However,<sp/>this<sp/>may<sp/>also<sp/>mean<sp/>there&apos;s<sp/>a<sp/>bug<sp/>in<sp/>the<sp/>test,<sp/>so<sp/>Google<sp/>Mock<sp/>shouldn&apos;t<sp/>be<sp/>silent<sp/>either.<sp/>If<sp/>the<sp/>user<sp/>believes<sp/>these<sp/>calls<sp/>are<sp/>harmless,<sp/>he<sp/>can<sp/>add<sp/>an<sp/>`EXPECT_CALL()`<sp/>to<sp/>suppress<sp/>the<sp/>warning.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">However,<sp/>sometimes<sp/>you<sp/>may<sp/>want<sp/>to<sp/>suppress<sp/>all<sp/>&quot;uninteresting<sp/>call&quot;</highlight></codeline>
<codeline><highlight class="normal">warnings,<sp/>while<sp/>sometimes<sp/>you<sp/>may<sp/>want<sp/>the<sp/>opposite,<sp/>i.e.<sp/>to<sp/>treat<sp/>all</highlight></codeline>
<codeline><highlight class="normal">of<sp/>them<sp/>as<sp/>errors.<sp/>Google<sp/>Mock<sp/>lets<sp/>you<sp/>make<sp/>the<sp/>decision<sp/>on<sp/>a</highlight></codeline>
<codeline><highlight class="normal">per-mock-object<sp/>basis.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Suppose<sp/>your<sp/>test<sp/>uses<sp/>a<sp/>mock<sp/>class<sp/>`MockFoo`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">TEST(...)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>mock_foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_foo,<sp/>DoThis());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>code<sp/>that<sp/>uses<sp/>mock_foo<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>a<sp/>method<sp/>of<sp/>`mock_foo`<sp/>other<sp/>than<sp/>`DoThis()`<sp/>is<sp/>called,<sp/>it<sp/>will<sp/>be</highlight></codeline>
<codeline><highlight class="normal">reported<sp/>by<sp/>Google<sp/>Mock<sp/>as<sp/>a<sp/>warning.<sp/>However,<sp/>if<sp/>you<sp/>rewrite<sp/>your</highlight></codeline>
<codeline><highlight class="normal">test<sp/>to<sp/>use<sp/>`NiceMock&lt;MockFoo&gt;`<sp/>instead,<sp/>the<sp/>warning<sp/>will<sp/>be<sp/>gone,</highlight></codeline>
<codeline><highlight class="normal">resulting<sp/>in<sp/>a<sp/>cleaner<sp/>test<sp/>output:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::NiceMock;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TEST(...)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>NiceMock&lt;MockFoo&gt;<sp/>mock_foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_foo,<sp/>DoThis());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>code<sp/>that<sp/>uses<sp/>mock_foo<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`NiceMock&lt;MockFoo&gt;`<sp/>is<sp/>a<sp/>subclass<sp/>of<sp/>`MockFoo`,<sp/>so<sp/>it<sp/>can<sp/>be<sp/>used</highlight></codeline>
<codeline><highlight class="normal">wherever<sp/>`MockFoo`<sp/>is<sp/>accepted.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">It<sp/>also<sp/>works<sp/>if<sp/>`MockFoo`&apos;s<sp/>constructor<sp/>takes<sp/>some<sp/>arguments,<sp/>as</highlight></codeline>
<codeline><highlight class="normal">`NiceMock&lt;MockFoo&gt;`<sp/>&quot;inherits&quot;<sp/>`MockFoo`&apos;s<sp/>constructors:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::NiceMock;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TEST(...)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>NiceMock&lt;MockFoo&gt;<sp/>mock_foo(5,<sp/>&quot;hi&quot;);<sp/><sp/>//<sp/>Calls<sp/>MockFoo(5,<sp/>&quot;hi&quot;).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_foo,<sp/>DoThis());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>code<sp/>that<sp/>uses<sp/>mock_foo<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>usage<sp/>of<sp/>`StrictMock`<sp/>is<sp/>similar,<sp/>except<sp/>that<sp/>it<sp/>makes<sp/>all</highlight></codeline>
<codeline><highlight class="normal">uninteresting<sp/>calls<sp/>failures:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::StrictMock;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TEST(...)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>StrictMock&lt;MockFoo&gt;<sp/>mock_foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_foo,<sp/>DoThis());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>code<sp/>that<sp/>uses<sp/>mock_foo<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>test<sp/>will<sp/>fail<sp/>if<sp/>a<sp/>method<sp/>of<sp/>mock_foo<sp/>other<sp/>than<sp/>DoThis()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>is<sp/>called.</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">There<sp/>are<sp/>some<sp/>caveats<sp/>though<sp/>(I<sp/>don&apos;t<sp/>like<sp/>them<sp/>just<sp/>as<sp/>much<sp/>as<sp/>the</highlight></codeline>
<codeline><highlight class="normal">next<sp/>guy,<sp/>but<sp/>sadly<sp/>they<sp/>are<sp/>side<sp/>effects<sp/>of<sp/>C++&apos;s<sp/>limitations):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>1.<sp/>`NiceMock&lt;MockFoo&gt;`<sp/>and<sp/>`StrictMock&lt;MockFoo&gt;`<sp/>only<sp/>work<sp/>for<sp/>mock<sp/>methods<sp/>defined<sp/>using<sp/>the<sp/>`MOCK_METHOD*`<sp/>family<sp/>of<sp/>macros<sp/>**directly**<sp/>in<sp/>the<sp/>`MockFoo`<sp/>class.<sp/>If<sp/>a<sp/>mock<sp/>method<sp/>is<sp/>defined<sp/>in<sp/>a<sp/>**base<sp/>class**<sp/>of<sp/>`MockFoo`,<sp/>the<sp/>&quot;nice&quot;<sp/>or<sp/>&quot;strict&quot;<sp/>modifier<sp/>may<sp/>not<sp/>affect<sp/>it,<sp/>depending<sp/>on<sp/>the<sp/>compiler.<sp/>In<sp/>particular,<sp/>nesting<sp/>`NiceMock`<sp/>and<sp/>`StrictMock`<sp/>(e.g.<sp/>`NiceMock&lt;StrictMock&lt;MockFoo&gt;<sp/>&gt;`)<sp/>is<sp/>**not**<sp/>supported.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>1.<sp/>The<sp/>constructors<sp/>of<sp/>the<sp/>base<sp/>mock<sp/>(`MockFoo`)<sp/>cannot<sp/>have<sp/>arguments<sp/>passed<sp/>by<sp/>non-const<sp/>reference,<sp/>which<sp/>happens<sp/>to<sp/>be<sp/>banned<sp/>by<sp/>the<sp/>[Google<sp/>C++<sp/>style<sp/>guide](http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>1.<sp/>During<sp/>the<sp/>constructor<sp/>or<sp/>destructor<sp/>of<sp/>`MockFoo`,<sp/>the<sp/>mock<sp/>object<sp/>is<sp/>_not_<sp/>nice<sp/>or<sp/>strict.<sp/><sp/>This<sp/>may<sp/>cause<sp/>surprises<sp/>if<sp/>the<sp/>constructor<sp/>or<sp/>destructor<sp/>calls<sp/>a<sp/>mock<sp/>method<sp/>on<sp/>`this`<sp/>object.<sp/>(This<sp/>behavior,<sp/>however,<sp/>is<sp/>consistent<sp/>with<sp/>C++&apos;s<sp/>general<sp/>rule:<sp/>if<sp/>a<sp/>constructor<sp/>or<sp/>destructor<sp/>calls<sp/>a<sp/>virtual<sp/>method<sp/>of<sp/>`this`<sp/>object,<sp/>that<sp/>method<sp/>is<sp/>treated<sp/>as<sp/>non-virtual.<sp/><sp/>In<sp/>other<sp/>words,<sp/>to<sp/>the<sp/>base<sp/>class&apos;s<sp/>constructor<sp/>or<sp/>destructor,<sp/>`this`<sp/>object<sp/>behaves<sp/>like<sp/>an<sp/>instance<sp/>of<sp/>the<sp/>base<sp/>class,<sp/>not<sp/>the<sp/>derived<sp/>class.<sp/><sp/>This<sp/>rule<sp/>is<sp/>required<sp/>for<sp/>safety.<sp/><sp/>Otherwise<sp/>a<sp/>base<sp/>constructor<sp/>may<sp/>use<sp/>members<sp/>of<sp/>a<sp/>derived<sp/>class<sp/>before<sp/>they<sp/>are<sp/>initialized,<sp/>or<sp/>a<sp/>base<sp/>destructor<sp/>may<sp/>use<sp/>members<sp/>of<sp/>a<sp/>derived<sp/>class<sp/>after<sp/>they<sp/>have<sp/>been<sp/>destroyed.)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Finally,<sp/>you<sp/>should<sp/>be<sp/>**very<sp/>cautious**<sp/>about<sp/>when<sp/>to<sp/>use<sp/>naggy<sp/>or<sp/>strict<sp/>mocks,<sp/>as<sp/>they<sp/>tend<sp/>to<sp/>make<sp/>tests<sp/>more<sp/>brittle<sp/>and<sp/>harder<sp/>to<sp/>maintain.<sp/>When<sp/>you<sp/>refactor<sp/>your<sp/>code<sp/>without<sp/>changing<sp/>its<sp/>externally<sp/>visible<sp/>behavior,<sp/>ideally<sp/>you<sp/>should&apos;t<sp/>need<sp/>to<sp/>update<sp/>any<sp/>tests.<sp/>If<sp/>your<sp/>code<sp/>interacts<sp/>with<sp/>a<sp/>naggy<sp/>mock,<sp/>however,<sp/>you<sp/>may<sp/>start<sp/>to<sp/>get<sp/>spammed<sp/>with<sp/>warnings<sp/>as<sp/>the<sp/>result<sp/>of<sp/>your<sp/>change.<sp/>Worse,<sp/>if<sp/>your<sp/>code<sp/>interacts<sp/>with<sp/>a<sp/>strict<sp/>mock,<sp/>your<sp/>tests<sp/>may<sp/>start<sp/>to<sp/>fail<sp/>and<sp/>you&apos;ll<sp/>be<sp/>forced<sp/>to<sp/>fix<sp/>them.<sp/>Our<sp/>general<sp/>recommendation<sp/>is<sp/>to<sp/>use<sp/>nice<sp/>mocks<sp/>(not<sp/>yet<sp/>the<sp/>default)<sp/>most<sp/>of<sp/>the<sp/>time,<sp/>use<sp/>naggy<sp/>mocks<sp/>(the<sp/>current<sp/>default)<sp/>when<sp/>developing<sp/>or<sp/>debugging<sp/>tests,<sp/>and<sp/>use<sp/>strict<sp/>mocks<sp/>only<sp/>as<sp/>the<sp/>last<sp/>resort.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Simplifying<sp/>the<sp/>Interface<sp/>without<sp/>Breaking<sp/>Existing<sp/>Code<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>a<sp/>method<sp/>has<sp/>a<sp/>long<sp/>list<sp/>of<sp/>arguments<sp/>that<sp/>is<sp/>mostly</highlight></codeline>
<codeline><highlight class="normal">uninteresting.<sp/>For<sp/>example,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">class<sp/>LogSink<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>send(LogSeverity<sp/>severity,<sp/>const<sp/>char*<sp/>full_filename,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>char*<sp/>base_filename,<sp/>int<sp/>line,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>struct<sp/>tm*<sp/>tm_time,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>char*<sp/>message,<sp/>size_t<sp/>message_len)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>method&apos;s<sp/>argument<sp/>list<sp/>is<sp/>lengthy<sp/>and<sp/>hard<sp/>to<sp/>work<sp/>with<sp/>(let&apos;s</highlight></codeline>
<codeline><highlight class="normal">say<sp/>that<sp/>the<sp/>`message`<sp/>argument<sp/>is<sp/>not<sp/>even<sp/>0-terminated).<sp/>If<sp/>we<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">it<sp/>as<sp/>is,<sp/>using<sp/>the<sp/>mock<sp/>will<sp/>be<sp/>awkward.<sp/>If,<sp/>however,<sp/>we<sp/>try<sp/>to</highlight></codeline>
<codeline><highlight class="normal">simplify<sp/>this<sp/>interface,<sp/>we&apos;ll<sp/>need<sp/>to<sp/>fix<sp/>all<sp/>clients<sp/>depending<sp/>on</highlight></codeline>
<codeline><highlight class="normal">it,<sp/>which<sp/>is<sp/>often<sp/>infeasible.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>trick<sp/>is<sp/>to<sp/>re-dispatch<sp/>the<sp/>method<sp/>in<sp/>the<sp/>mock<sp/>class:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">class<sp/>ScopedMockLog<sp/>:<sp/>public<sp/>LogSink<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>send(LogSeverity<sp/>severity,<sp/>const<sp/>char*<sp/>full_filename,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>char*<sp/>base_filename,<sp/>int<sp/>line,<sp/>const<sp/>tm*<sp/>tm_time,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>char*<sp/>message,<sp/>size_t<sp/>message_len)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>We<sp/>are<sp/>only<sp/>interested<sp/>in<sp/>the<sp/>log<sp/>severity,<sp/>full<sp/>file<sp/>name,<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>log<sp/>message.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Log(severity,<sp/>full_filename,<sp/>std::string(message,<sp/>message_len));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Implements<sp/>the<sp/>mock<sp/>method:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/><sp/><sp/>void<sp/>Log(LogSeverity<sp/>severity,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>string&amp;<sp/>file_path,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>string&amp;<sp/>message);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD3(Log,<sp/>void(LogSeverity<sp/>severity,<sp/>const<sp/>string&amp;<sp/>file_path,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>string&amp;<sp/>message));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">By<sp/>defining<sp/>a<sp/>new<sp/>mock<sp/>method<sp/>with<sp/>a<sp/>trimmed<sp/>argument<sp/>list,<sp/>we<sp/>make</highlight></codeline>
<codeline><highlight class="normal">the<sp/>mock<sp/>class<sp/>much<sp/>more<sp/>user-friendly.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Alternative<sp/>to<sp/>Mocking<sp/>Concrete<sp/>Classes<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Often<sp/>you<sp/>may<sp/>find<sp/>yourself<sp/>using<sp/>classes<sp/>that<sp/>don&apos;t<sp/>implement</highlight></codeline>
<codeline><highlight class="normal">interfaces.<sp/>In<sp/>order<sp/>to<sp/>test<sp/>your<sp/>code<sp/>that<sp/>uses<sp/>such<sp/>a<sp/>class<sp/>(let&apos;s</highlight></codeline>
<codeline><highlight class="normal">call<sp/>it<sp/>`Concrete`),<sp/>you<sp/>may<sp/>be<sp/>tempted<sp/>to<sp/>make<sp/>the<sp/>methods<sp/>of</highlight></codeline>
<codeline><highlight class="normal">`Concrete`<sp/>virtual<sp/>and<sp/>then<sp/>mock<sp/>it.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Try<sp/>not<sp/>to<sp/>do<sp/>that.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Making<sp/>a<sp/>non-virtual<sp/>function<sp/>virtual<sp/>is<sp/>a<sp/>big<sp/>decision.<sp/>It<sp/>creates<sp/>an</highlight></codeline>
<codeline><highlight class="normal">extension<sp/>point<sp/>where<sp/>subclasses<sp/>can<sp/>tweak<sp/>your<sp/>class&apos;<sp/>behavior.<sp/>This</highlight></codeline>
<codeline><highlight class="normal">weakens<sp/>your<sp/>control<sp/>on<sp/>the<sp/>class<sp/>because<sp/>now<sp/>it&apos;s<sp/>harder<sp/>to<sp/>maintain</highlight></codeline>
<codeline><highlight class="normal">the<sp/>class&apos;<sp/>invariants.<sp/>You<sp/>should<sp/>make<sp/>a<sp/>function<sp/>virtual<sp/>only<sp/>when</highlight></codeline>
<codeline><highlight class="normal">there<sp/>is<sp/>a<sp/>valid<sp/>reason<sp/>for<sp/>a<sp/>subclass<sp/>to<sp/>override<sp/>it.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Mocking<sp/>concrete<sp/>classes<sp/>directly<sp/>is<sp/>problematic<sp/>as<sp/>it<sp/>creates<sp/>a<sp/>tight</highlight></codeline>
<codeline><highlight class="normal">coupling<sp/>between<sp/>the<sp/>class<sp/>and<sp/>the<sp/>tests<sp/>-<sp/>any<sp/>small<sp/>change<sp/>in<sp/>the</highlight></codeline>
<codeline><highlight class="normal">class<sp/>may<sp/>invalidate<sp/>your<sp/>tests<sp/>and<sp/>make<sp/>test<sp/>maintenance<sp/>a<sp/>pain.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">To<sp/>avoid<sp/>such<sp/>problems,<sp/>many<sp/>programmers<sp/>have<sp/>been<sp/>practicing<sp/>&quot;coding</highlight></codeline>
<codeline><highlight class="normal">to<sp/>interfaces&quot;:<sp/>instead<sp/>of<sp/>talking<sp/>to<sp/>the<sp/>`Concrete`<sp/>class,<sp/>your<sp/>code</highlight></codeline>
<codeline><highlight class="normal">would<sp/>define<sp/>an<sp/>interface<sp/>and<sp/>talk<sp/>to<sp/>it.<sp/>Then<sp/>you<sp/>implement<sp/>that</highlight></codeline>
<codeline><highlight class="normal">interface<sp/>as<sp/>an<sp/>adaptor<sp/>on<sp/>top<sp/>of<sp/>`Concrete`.<sp/>In<sp/>tests,<sp/>you<sp/>can<sp/>easily</highlight></codeline>
<codeline><highlight class="normal">mock<sp/>that<sp/>interface<sp/>to<sp/>observe<sp/>how<sp/>your<sp/>code<sp/>is<sp/>doing.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>technique<sp/>incurs<sp/>some<sp/>overhead:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>You<sp/>pay<sp/>the<sp/>cost<sp/>of<sp/>virtual<sp/>function<sp/>calls<sp/>(usually<sp/>not<sp/>a<sp/>problem).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>There<sp/>is<sp/>more<sp/>abstraction<sp/>for<sp/>the<sp/>programmers<sp/>to<sp/>learn.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">However,<sp/>it<sp/>can<sp/>also<sp/>bring<sp/>significant<sp/>benefits<sp/>in<sp/>addition<sp/>to<sp/>better</highlight></codeline>
<codeline><highlight class="normal">testability:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>`Concrete`&apos;s<sp/>API<sp/>may<sp/>not<sp/>fit<sp/>your<sp/>problem<sp/>domain<sp/>very<sp/>well,<sp/>as<sp/>you<sp/>may<sp/>not<sp/>be<sp/>the<sp/>only<sp/>client<sp/>it<sp/>tries<sp/>to<sp/>serve.<sp/>By<sp/>designing<sp/>your<sp/>own<sp/>interface,<sp/>you<sp/>have<sp/>a<sp/>chance<sp/>to<sp/>tailor<sp/>it<sp/>to<sp/>your<sp/>need<sp/>-<sp/>you<sp/>may<sp/>add<sp/>higher-level<sp/>functionalities,<sp/>rename<sp/>stuff,<sp/>etc<sp/>instead<sp/>of<sp/>just<sp/>trimming<sp/>the<sp/>class.<sp/>This<sp/>allows<sp/>you<sp/>to<sp/>write<sp/>your<sp/>code<sp/>(user<sp/>of<sp/>the<sp/>interface)<sp/>in<sp/>a<sp/>more<sp/>natural<sp/>way,<sp/>which<sp/>means<sp/>it<sp/>will<sp/>be<sp/>more<sp/>readable,<sp/>more<sp/>maintainable,<sp/>and<sp/>you&apos;ll<sp/>be<sp/>more<sp/>productive.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>If<sp/>`Concrete`&apos;s<sp/>implementation<sp/>ever<sp/>has<sp/>to<sp/>change,<sp/>you<sp/>don&apos;t<sp/>have<sp/>to<sp/>rewrite<sp/>everywhere<sp/>it<sp/>is<sp/>used.<sp/>Instead,<sp/>you<sp/>can<sp/>absorb<sp/>the<sp/>change<sp/>in<sp/>your<sp/>implementation<sp/>of<sp/>the<sp/>interface,<sp/>and<sp/>your<sp/>other<sp/>code<sp/>and<sp/>tests<sp/>will<sp/>be<sp/>insulated<sp/>from<sp/>this<sp/>change.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Some<sp/>people<sp/>worry<sp/>that<sp/>if<sp/>everyone<sp/>is<sp/>practicing<sp/>this<sp/>technique,<sp/>they</highlight></codeline>
<codeline><highlight class="normal">will<sp/>end<sp/>up<sp/>writing<sp/>lots<sp/>of<sp/>redundant<sp/>code.<sp/>This<sp/>concern<sp/>is<sp/>totally</highlight></codeline>
<codeline><highlight class="normal">understandable.<sp/>However,<sp/>there<sp/>are<sp/>two<sp/>reasons<sp/>why<sp/>it<sp/>may<sp/>not<sp/>be<sp/>the</highlight></codeline>
<codeline><highlight class="normal">case:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>Different<sp/>projects<sp/>may<sp/>need<sp/>to<sp/>use<sp/>`Concrete`<sp/>in<sp/>different<sp/>ways,<sp/>so<sp/>the<sp/>best<sp/>interfaces<sp/>for<sp/>them<sp/>will<sp/>be<sp/>different.<sp/>Therefore,<sp/>each<sp/>of<sp/>them<sp/>will<sp/>have<sp/>its<sp/>own<sp/>domain-specific<sp/>interface<sp/>on<sp/>top<sp/>of<sp/>`Concrete`,<sp/>and<sp/>they<sp/>will<sp/>not<sp/>be<sp/>the<sp/>same<sp/>code.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>If<sp/>enough<sp/>projects<sp/>want<sp/>to<sp/>use<sp/>the<sp/>same<sp/>interface,<sp/>they<sp/>can<sp/>always<sp/>share<sp/>it,<sp/>just<sp/>like<sp/>they<sp/>have<sp/>been<sp/>sharing<sp/>`Concrete`.<sp/>You<sp/>can<sp/>check<sp/>in<sp/>the<sp/>interface<sp/>and<sp/>the<sp/>adaptor<sp/>somewhere<sp/>near<sp/>`Concrete`<sp/>(perhaps<sp/>in<sp/>a<sp/>`contrib`<sp/>sub-directory)<sp/>and<sp/>let<sp/>many<sp/>projects<sp/>use<sp/>it.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>need<sp/>to<sp/>weigh<sp/>the<sp/>pros<sp/>and<sp/>cons<sp/>carefully<sp/>for<sp/>your<sp/>particular</highlight></codeline>
<codeline><highlight class="normal">problem,<sp/>but<sp/>I&apos;d<sp/>like<sp/>to<sp/>assure<sp/>you<sp/>that<sp/>the<sp/>Java<sp/>community<sp/>has<sp/>been</highlight></codeline>
<codeline><highlight class="normal">practicing<sp/>this<sp/>for<sp/>a<sp/>long<sp/>time<sp/>and<sp/>it&apos;s<sp/>a<sp/>proven<sp/>effective<sp/>technique</highlight></codeline>
<codeline><highlight class="normal">applicable<sp/>in<sp/>a<sp/>wide<sp/>variety<sp/>of<sp/>situations.<sp/>:-)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Delegating<sp/>Calls<sp/>to<sp/>a<sp/>Fake<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Some<sp/>times<sp/>you<sp/>have<sp/>a<sp/>non-trivial<sp/>fake<sp/>implementation<sp/>of<sp/>an</highlight></codeline>
<codeline><highlight class="normal">interface.<sp/>For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">class<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~Foo()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>char<sp/>DoThis(int<sp/>n)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>DoThat(const<sp/>char*<sp/>s,<sp/>int*<sp/>p)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>FakeFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>char<sp/>DoThis(int<sp/>n)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(n<sp/>&gt;<sp/>0)<sp/>?<sp/>&apos;+&apos;<sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(n<sp/>&lt;<sp/>0)<sp/>?<sp/>&apos;-&apos;<sp/>:<sp/>&apos;0&apos;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>DoThat(const<sp/>char*<sp/>s,<sp/>int*<sp/>p)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*p<sp/>=<sp/>strlen(s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Now<sp/>you<sp/>want<sp/>to<sp/>mock<sp/>this<sp/>interface<sp/>such<sp/>that<sp/>you<sp/>can<sp/>set<sp/>expectations</highlight></codeline>
<codeline><highlight class="normal">on<sp/>it.<sp/>However,<sp/>you<sp/>also<sp/>want<sp/>to<sp/>use<sp/>`FakeFoo`<sp/>for<sp/>the<sp/>default</highlight></codeline>
<codeline><highlight class="normal">behavior,<sp/>as<sp/>duplicating<sp/>it<sp/>in<sp/>the<sp/>mock<sp/>object<sp/>is,<sp/>well,<sp/>a<sp/>lot<sp/>of</highlight></codeline>
<codeline><highlight class="normal">work.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>you<sp/>define<sp/>the<sp/>mock<sp/>class<sp/>using<sp/>Google<sp/>Mock,<sp/>you<sp/>can<sp/>have<sp/>it</highlight></codeline>
<codeline><highlight class="normal">delegate<sp/>its<sp/>default<sp/>action<sp/>to<sp/>a<sp/>fake<sp/>class<sp/>you<sp/>already<sp/>have,<sp/>using</highlight></codeline>
<codeline><highlight class="normal">this<sp/>pattern:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Normal<sp/>mock<sp/>method<sp/>definitions<sp/>using<sp/>Google<sp/>Mock.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(DoThis,<sp/>char(int<sp/>n));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD2(DoThat,<sp/>void(const<sp/>char*<sp/>s,<sp/>int*<sp/>p));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Delegates<sp/>the<sp/>default<sp/>actions<sp/>of<sp/>the<sp/>methods<sp/>to<sp/>a<sp/>FakeFoo<sp/>object.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>This<sp/>must<sp/>be<sp/>called<sp/>*before*<sp/>the<sp/>custom<sp/>ON_CALL()<sp/>statements.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>DelegateToFake()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ON_CALL(*this,<sp/>DoThis(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.WillByDefault(Invoke(&amp;fake_,<sp/>&amp;FakeFoo::DoThis));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ON_CALL(*this,<sp/>DoThat(_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.WillByDefault(Invoke(&amp;fake_,<sp/>&amp;FakeFoo::DoThat));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FakeFoo<sp/>fake_;<sp/><sp/>//<sp/>Keeps<sp/>an<sp/>instance<sp/>of<sp/>the<sp/>fake<sp/>in<sp/>the<sp/>mock.</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">With<sp/>that,<sp/>you<sp/>can<sp/>use<sp/>`MockFoo`<sp/>in<sp/>your<sp/>tests<sp/>as<sp/>usual.<sp/>Just<sp/>remember</highlight></codeline>
<codeline><highlight class="normal">that<sp/>if<sp/>you<sp/>don&apos;t<sp/>explicitly<sp/>set<sp/>an<sp/>action<sp/>in<sp/>an<sp/>`ON_CALL()`<sp/>or</highlight></codeline>
<codeline><highlight class="normal">`EXPECT_CALL()`,<sp/>the<sp/>fake<sp/>will<sp/>be<sp/>called<sp/>upon<sp/>to<sp/>do<sp/>it:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TEST(AbcTest,<sp/>Xyz)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DelegateToFake();<sp/>//<sp/>Enables<sp/>the<sp/>fake<sp/>for<sp/>delegation.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Put<sp/>your<sp/>ON_CALL(foo,<sp/>...)s<sp/>here,<sp/>if<sp/>any.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>No<sp/>action<sp/>specified,<sp/>meaning<sp/>to<sp/>use<sp/>the<sp/>default<sp/>action.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat(_,<sp/>_));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>n<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_EQ(&apos;+&apos;,<sp/>foo.DoThis(5));<sp/><sp/>//<sp/>FakeFoo::DoThis()<sp/>is<sp/>invoked.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThat(&quot;Hi&quot;,<sp/>&amp;n);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>FakeFoo::DoThat()<sp/>is<sp/>invoked.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_EQ(2,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**Some<sp/>tips:**</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>If<sp/>you<sp/>want,<sp/>you<sp/>can<sp/>still<sp/>override<sp/>the<sp/>default<sp/>action<sp/>by<sp/>providing<sp/>your<sp/>own<sp/>`ON_CALL()`<sp/>or<sp/>using<sp/>`.WillOnce()`<sp/>/<sp/>`.WillRepeatedly()`<sp/>in<sp/>`EXPECT_CALL()`.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>In<sp/>`DelegateToFake()`,<sp/>you<sp/>only<sp/>need<sp/>to<sp/>delegate<sp/>the<sp/>methods<sp/>whose<sp/>fake<sp/>implementation<sp/>you<sp/>intend<sp/>to<sp/>use.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>The<sp/>general<sp/>technique<sp/>discussed<sp/>here<sp/>works<sp/>for<sp/>overloaded<sp/>methods,<sp/>but<sp/>you&apos;ll<sp/>need<sp/>to<sp/>tell<sp/>the<sp/>compiler<sp/>which<sp/>version<sp/>you<sp/>mean.<sp/>To<sp/>disambiguate<sp/>a<sp/>mock<sp/>function<sp/>(the<sp/>one<sp/>you<sp/>specify<sp/>inside<sp/>the<sp/>parentheses<sp/>of<sp/>`ON_CALL()`),<sp/>see<sp/>the<sp/>&quot;Selecting<sp/>Between<sp/>Overloaded<sp/>Functions&quot;<sp/>section<sp/>on<sp/>this<sp/>page;<sp/>to<sp/>disambiguate<sp/>a<sp/>fake<sp/>function<sp/>(the<sp/>one<sp/>you<sp/>place<sp/>inside<sp/>`Invoke()`),<sp/>use<sp/>a<sp/>`static_cast`<sp/>to<sp/>specify<sp/>the<sp/>function&apos;s<sp/>type.<sp/>For<sp/>instance,<sp/>if<sp/>class<sp/>`Foo`<sp/>has<sp/>methods<sp/>`char<sp/>DoThis(int<sp/>n)`<sp/>and<sp/>`bool<sp/>DoThis(double<sp/>x)<sp/>const`,<sp/>and<sp/>you<sp/>want<sp/>to<sp/>invoke<sp/>the<sp/>latter,<sp/>you<sp/>need<sp/>to<sp/>write<sp/>`Invoke(&amp;fake_,<sp/>static_cast&lt;bool<sp/>(FakeFoo::*)(double)<sp/>const&gt;(&amp;FakeFoo::DoThis))`<sp/>instead<sp/>of<sp/>`Invoke(&amp;fake_,<sp/>&amp;FakeFoo::DoThis)`<sp/>(The<sp/>strange-looking<sp/>thing<sp/>inside<sp/>the<sp/>angled<sp/>brackets<sp/>of<sp/>`static_cast`<sp/>is<sp/>the<sp/>type<sp/>of<sp/>a<sp/>function<sp/>pointer<sp/>to<sp/>the<sp/>second<sp/>`DoThis()`<sp/>method.).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>Having<sp/>to<sp/>mix<sp/>a<sp/>mock<sp/>and<sp/>a<sp/>fake<sp/>is<sp/>often<sp/>a<sp/>sign<sp/>of<sp/>something<sp/>gone<sp/>wrong.<sp/>Perhaps<sp/>you<sp/>haven&apos;t<sp/>got<sp/>used<sp/>to<sp/>the<sp/>interaction-based<sp/>way<sp/>of<sp/>testing<sp/>yet.<sp/>Or<sp/>perhaps<sp/>your<sp/>interface<sp/>is<sp/>taking<sp/>on<sp/>too<sp/>many<sp/>roles<sp/>and<sp/>should<sp/>be<sp/>split<sp/>up.<sp/>Therefore,<sp/>**don&apos;t<sp/>abuse<sp/>this**.<sp/>We<sp/>would<sp/>only<sp/>recommend<sp/>to<sp/>do<sp/>it<sp/>as<sp/>an<sp/>intermediate<sp/>step<sp/>when<sp/>you<sp/>are<sp/>refactoring<sp/>your<sp/>code.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Regarding<sp/>the<sp/>tip<sp/>on<sp/>mixing<sp/>a<sp/>mock<sp/>and<sp/>a<sp/>fake,<sp/>here&apos;s<sp/>an<sp/>example<sp/>on</highlight></codeline>
<codeline><highlight class="normal">why<sp/>it<sp/>may<sp/>be<sp/>a<sp/>bad<sp/>sign:<sp/>Suppose<sp/>you<sp/>have<sp/>a<sp/>class<sp/>`System`<sp/>for</highlight></codeline>
<codeline><highlight class="normal">low-level<sp/>system<sp/>operations.<sp/>In<sp/>particular,<sp/>it<sp/>does<sp/>file<sp/>and<sp/>I/O</highlight></codeline>
<codeline><highlight class="normal">operations.<sp/>And<sp/>suppose<sp/>you<sp/>want<sp/>to<sp/>test<sp/>how<sp/>your<sp/>code<sp/>uses<sp/>`System`</highlight></codeline>
<codeline><highlight class="normal">to<sp/>do<sp/>I/O,<sp/>and<sp/>you<sp/>just<sp/>want<sp/>the<sp/>file<sp/>operations<sp/>to<sp/>work<sp/>normally.<sp/>If</highlight></codeline>
<codeline><highlight class="normal">you<sp/>mock<sp/>out<sp/>the<sp/>entire<sp/>`System`<sp/>class,<sp/>you&apos;ll<sp/>have<sp/>to<sp/>provide<sp/>a<sp/>fake</highlight></codeline>
<codeline><highlight class="normal">implementation<sp/>for<sp/>the<sp/>file<sp/>operation<sp/>part,<sp/>which<sp/>suggests<sp/>that</highlight></codeline>
<codeline><highlight class="normal">`System`<sp/>is<sp/>taking<sp/>on<sp/>too<sp/>many<sp/>roles.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Instead,<sp/>you<sp/>can<sp/>define<sp/>a<sp/>`FileOps`<sp/>interface<sp/>and<sp/>an<sp/>`IOOps`<sp/>interface</highlight></codeline>
<codeline><highlight class="normal">and<sp/>split<sp/>`System`&apos;s<sp/>functionalities<sp/>into<sp/>the<sp/>two.<sp/>Then<sp/>you<sp/>can<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">`IOOps`<sp/>without<sp/>mocking<sp/>`FileOps`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Delegating<sp/>Calls<sp/>to<sp/>a<sp/>Real<sp/>Object<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>using<sp/>testing<sp/>doubles<sp/>(mocks,<sp/>fakes,<sp/>stubs,<sp/>and<sp/>etc),<sp/>sometimes</highlight></codeline>
<codeline><highlight class="normal">their<sp/>behaviors<sp/>will<sp/>differ<sp/>from<sp/>those<sp/>of<sp/>the<sp/>real<sp/>objects.<sp/>This</highlight></codeline>
<codeline><highlight class="normal">difference<sp/>could<sp/>be<sp/>either<sp/>intentional<sp/>(as<sp/>in<sp/>simulating<sp/>an<sp/>error<sp/>such</highlight></codeline>
<codeline><highlight class="normal">that<sp/>you<sp/>can<sp/>test<sp/>the<sp/>error<sp/>handling<sp/>code)<sp/>or<sp/>unintentional.<sp/>If<sp/>your</highlight></codeline>
<codeline><highlight class="normal">mocks<sp/>have<sp/>different<sp/>behaviors<sp/>than<sp/>the<sp/>real<sp/>objects<sp/>by<sp/>mistake,<sp/>you</highlight></codeline>
<codeline><highlight class="normal">could<sp/>end<sp/>up<sp/>with<sp/>code<sp/>that<sp/>passes<sp/>the<sp/>tests<sp/>but<sp/>fails<sp/>in<sp/>production.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>use<sp/>the<sp/>_delegating-to-real_<sp/>technique<sp/>to<sp/>ensure<sp/>that<sp/>your</highlight></codeline>
<codeline><highlight class="normal">mock<sp/>has<sp/>the<sp/>same<sp/>behavior<sp/>as<sp/>the<sp/>real<sp/>object<sp/>while<sp/>retaining<sp/>the</highlight></codeline>
<codeline><highlight class="normal">ability<sp/>to<sp/>validate<sp/>calls.<sp/>This<sp/>technique<sp/>is<sp/>very<sp/>similar<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">delegating-to-fake<sp/>technique,<sp/>the<sp/>difference<sp/>being<sp/>that<sp/>we<sp/>use<sp/>a<sp/>real</highlight></codeline>
<codeline><highlight class="normal">object<sp/>instead<sp/>of<sp/>a<sp/>fake.<sp/>Here&apos;s<sp/>an<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::AtLeast;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>By<sp/>default,<sp/>all<sp/>calls<sp/>are<sp/>delegated<sp/>to<sp/>the<sp/>real<sp/>object.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ON_CALL(*this,<sp/>DoThis())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.WillByDefault(Invoke(&amp;real_,<sp/>&amp;Foo::DoThis));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ON_CALL(*this,<sp/>DoThat(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.WillByDefault(Invoke(&amp;real_,<sp/>&amp;Foo::DoThat));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD0(DoThis,<sp/>...);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(DoThat,<sp/>...);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Foo<sp/>real_;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>mock;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>DoThis())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>DoThat(&quot;Hi&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(AtLeast(1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>use<sp/>mock<sp/>in<sp/>test<sp/>...</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">With<sp/>this,<sp/>Google<sp/>Mock<sp/>will<sp/>verify<sp/>that<sp/>your<sp/>code<sp/>made<sp/>the<sp/>right<sp/>calls</highlight></codeline>
<codeline><highlight class="normal">(with<sp/>the<sp/>right<sp/>arguments,<sp/>in<sp/>the<sp/>right<sp/>order,<sp/>called<sp/>the<sp/>right<sp/>number</highlight></codeline>
<codeline><highlight class="normal">of<sp/>times,<sp/>etc),<sp/>and<sp/>a<sp/>real<sp/>object<sp/>will<sp/>answer<sp/>the<sp/>calls<sp/>(so<sp/>the</highlight></codeline>
<codeline><highlight class="normal">behavior<sp/>will<sp/>be<sp/>the<sp/>same<sp/>as<sp/>in<sp/>production).<sp/>This<sp/>gives<sp/>you<sp/>the<sp/>best</highlight></codeline>
<codeline><highlight class="normal">of<sp/>both<sp/>worlds.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Delegating<sp/>Calls<sp/>to<sp/>a<sp/>Parent<sp/>Class<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Ideally,<sp/>you<sp/>should<sp/>code<sp/>to<sp/>interfaces,<sp/>whose<sp/>methods<sp/>are<sp/>all<sp/>pure</highlight></codeline>
<codeline><highlight class="normal">virtual.<sp/>In<sp/>reality,<sp/>sometimes<sp/>you<sp/>do<sp/>need<sp/>to<sp/>mock<sp/>a<sp/>virtual<sp/>method</highlight></codeline>
<codeline><highlight class="normal">that<sp/>is<sp/>not<sp/>pure<sp/>(i.e,<sp/>it<sp/>already<sp/>has<sp/>an<sp/>implementation).<sp/>For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">class<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~Foo();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>Pure(int<sp/>n)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>int<sp/>Concrete(const<sp/>char*<sp/>str)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Mocking<sp/>a<sp/>pure<sp/>method.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(Pure,<sp/>void(int<sp/>n));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Mocking<sp/>a<sp/>concrete<sp/>method.<sp/><sp/>Foo::Concrete()<sp/>is<sp/>shadowed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(Concrete,<sp/>int(const<sp/>char*<sp/>str));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>you<sp/>may<sp/>want<sp/>to<sp/>call<sp/>`Foo::Concrete()`<sp/>instead<sp/>of</highlight></codeline>
<codeline><highlight class="normal">`MockFoo::Concrete()`.<sp/>Perhaps<sp/>you<sp/>want<sp/>to<sp/>do<sp/>it<sp/>as<sp/>part<sp/>of<sp/>a<sp/>stub</highlight></codeline>
<codeline><highlight class="normal">action,<sp/>or<sp/>perhaps<sp/>your<sp/>test<sp/>doesn&apos;t<sp/>need<sp/>to<sp/>mock<sp/>`Concrete()`<sp/>at<sp/>all</highlight></codeline>
<codeline><highlight class="normal">(but<sp/>it<sp/>would<sp/>be<sp/>oh-so<sp/>painful<sp/>to<sp/>have<sp/>to<sp/>define<sp/>a<sp/>new<sp/>mock<sp/>class</highlight></codeline>
<codeline><highlight class="normal">whenever<sp/>you<sp/>don&apos;t<sp/>need<sp/>to<sp/>mock<sp/>one<sp/>of<sp/>its<sp/>methods).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>trick<sp/>is<sp/>to<sp/>leave<sp/>a<sp/>back<sp/>door<sp/>in<sp/>your<sp/>mock<sp/>class<sp/>for<sp/>accessing<sp/>the</highlight></codeline>
<codeline><highlight class="normal">real<sp/>methods<sp/>in<sp/>the<sp/>base<sp/>class:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Mocking<sp/>a<sp/>pure<sp/>method.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(Pure,<sp/>void(int<sp/>n));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Mocking<sp/>a<sp/>concrete<sp/>method.<sp/><sp/>Foo::Concrete()<sp/>is<sp/>shadowed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(Concrete,<sp/>int(const<sp/>char*<sp/>str));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Use<sp/>this<sp/>to<sp/>call<sp/>Concrete()<sp/>defined<sp/>in<sp/>Foo.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>FooConcrete(const<sp/>char*<sp/>str)<sp/>{<sp/>return<sp/>Foo::Concrete(str);<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Now,<sp/>you<sp/>can<sp/>call<sp/>`Foo::Concrete()`<sp/>inside<sp/>an<sp/>action<sp/>by:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Concrete(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(&amp;foo,<sp/>&amp;MockFoo::FooConcrete));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">or<sp/>tell<sp/>the<sp/>mock<sp/>object<sp/>that<sp/>you<sp/>don&apos;t<sp/>want<sp/>to<sp/>mock<sp/>`Concrete()`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ON_CALL(foo,<sp/>Concrete(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillByDefault(Invoke(&amp;foo,<sp/>&amp;MockFoo::FooConcrete));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">(Why<sp/>don&apos;t<sp/>we<sp/>just<sp/>write<sp/>`Invoke(&amp;foo,<sp/>&amp;Foo::Concrete)`?<sp/>If<sp/>you<sp/>do</highlight></codeline>
<codeline><highlight class="normal">that,<sp/>`MockFoo::Concrete()`<sp/>will<sp/>be<sp/>called<sp/>(and<sp/>cause<sp/>an<sp/>infinite</highlight></codeline>
<codeline><highlight class="normal">recursion)<sp/>since<sp/>`Foo::Concrete()`<sp/>is<sp/>virtual.<sp/>That&apos;s<sp/>just<sp/>how<sp/>C++</highlight></codeline>
<codeline><highlight class="normal">works.)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#<sp/>Using<sp/>Matchers<sp/>#</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Matching<sp/>Argument<sp/>Values<sp/>Exactly<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>specify<sp/>exactly<sp/>which<sp/>arguments<sp/>a<sp/>mock<sp/>method<sp/>is<sp/>expecting:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(5))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Return(&apos;a&apos;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat(&quot;Hello&quot;,<sp/>bar));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Using<sp/>Simple<sp/>Matchers<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>use<sp/>matchers<sp/>to<sp/>match<sp/>arguments<sp/>that<sp/>have<sp/>a<sp/>certain<sp/>property:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Ge;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::NotNull;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(Ge(5)))<sp/><sp/>//<sp/>The<sp/>argument<sp/>must<sp/>be<sp/>&gt;=<sp/>5.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Return(&apos;a&apos;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat(&quot;Hello&quot;,<sp/>NotNull()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>second<sp/>argument<sp/>must<sp/>not<sp/>be<sp/>NULL.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>frequently<sp/>used<sp/>matcher<sp/>is<sp/>`_`,<sp/>which<sp/>matches<sp/>anything:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::NotNull;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat(_,<sp/>NotNull()));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Combining<sp/>Matchers<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>build<sp/>complex<sp/>matchers<sp/>from<sp/>existing<sp/>ones<sp/>using<sp/>`AllOf()`,</highlight></codeline>
<codeline><highlight class="normal">`AnyOf()`,<sp/>and<sp/>`Not()`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::AllOf;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Gt;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::HasSubstr;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Ne;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Not;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>argument<sp/>must<sp/>be<sp/>&gt;<sp/>5<sp/>and<sp/>!=<sp/>10.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(AllOf(Gt(5),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ne(10))));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>first<sp/>argument<sp/>must<sp/>not<sp/>contain<sp/>sub-string<sp/>&quot;blah&quot;.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat(Not(HasSubstr(&quot;blah&quot;)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NULL));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Casting<sp/>Matchers<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Google<sp/>Mock<sp/>matchers<sp/>are<sp/>statically<sp/>typed,<sp/>meaning<sp/>that<sp/>the<sp/>compiler</highlight></codeline>
<codeline><highlight class="normal">can<sp/>catch<sp/>your<sp/>mistake<sp/>if<sp/>you<sp/>use<sp/>a<sp/>matcher<sp/>of<sp/>the<sp/>wrong<sp/>type<sp/>(for</highlight></codeline>
<codeline><highlight class="normal">example,<sp/>if<sp/>you<sp/>use<sp/>`Eq(5)`<sp/>to<sp/>match<sp/>a<sp/>`string`<sp/>argument).<sp/>Good<sp/>for</highlight></codeline>
<codeline><highlight class="normal">you!</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes,<sp/>however,<sp/>you<sp/>know<sp/>what<sp/>you&apos;re<sp/>doing<sp/>and<sp/>want<sp/>the<sp/>compiler</highlight></codeline>
<codeline><highlight class="normal">to<sp/>give<sp/>you<sp/>some<sp/>slack.<sp/>One<sp/>example<sp/>is<sp/>that<sp/>you<sp/>have<sp/>a<sp/>matcher<sp/>for</highlight></codeline>
<codeline><highlight class="normal">`long`<sp/>and<sp/>the<sp/>argument<sp/>you<sp/>want<sp/>to<sp/>match<sp/>is<sp/>`int`.<sp/>While<sp/>the<sp/>two</highlight></codeline>
<codeline><highlight class="normal">types<sp/>aren&apos;t<sp/>exactly<sp/>the<sp/>same,<sp/>there<sp/>is<sp/>nothing<sp/>really<sp/>wrong<sp/>with</highlight></codeline>
<codeline><highlight class="normal">using<sp/>a<sp/>`Matcher&lt;long&gt;`<sp/>to<sp/>match<sp/>an<sp/>`int`<sp/>-<sp/>after<sp/>all,<sp/>we<sp/>can<sp/>first</highlight></codeline>
<codeline><highlight class="normal">convert<sp/>the<sp/>`int`<sp/>argument<sp/>to<sp/>a<sp/>`long`<sp/>before<sp/>giving<sp/>it<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">matcher.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">To<sp/>support<sp/>this<sp/>need,<sp/>Google<sp/>Mock<sp/>gives<sp/>you<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`SafeMatcherCast&lt;T&gt;(m)`<sp/>function.<sp/>It<sp/>casts<sp/>a<sp/>matcher<sp/>`m`<sp/>to<sp/>type</highlight></codeline>
<codeline><highlight class="normal">`Matcher&lt;T&gt;`.<sp/>To<sp/>ensure<sp/>safety,<sp/>Google<sp/>Mock<sp/>checks<sp/>that<sp/>(let<sp/>`U`<sp/>be<sp/>the</highlight></codeline>
<codeline><highlight class="normal">type<sp/>`m`<sp/>accepts):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>1.<sp/>Type<sp/>`T`<sp/>can<sp/>be<sp/>implicitly<sp/>cast<sp/>to<sp/>type<sp/>`U`;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>1.<sp/>When<sp/>both<sp/>`T`<sp/>and<sp/>`U`<sp/>are<sp/>built-in<sp/>arithmetic<sp/>types<sp/>(`bool`,<sp/>integers,<sp/>and<sp/>floating-point<sp/>numbers),<sp/>the<sp/>conversion<sp/>from<sp/>`T`<sp/>to<sp/>`U`<sp/>is<sp/>not<sp/>lossy<sp/>(in<sp/>other<sp/>words,<sp/>any<sp/>value<sp/>representable<sp/>by<sp/>`T`<sp/>can<sp/>also<sp/>be<sp/>represented<sp/>by<sp/>`U`);<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>1.<sp/>When<sp/>`U`<sp/>is<sp/>a<sp/>reference,<sp/>`T`<sp/>must<sp/>also<sp/>be<sp/>a<sp/>reference<sp/>(as<sp/>the<sp/>underlying<sp/>matcher<sp/>may<sp/>be<sp/>interested<sp/>in<sp/>the<sp/>address<sp/>of<sp/>the<sp/>`U`<sp/>value).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>code<sp/>won&apos;t<sp/>compile<sp/>if<sp/>any<sp/>of<sp/>these<sp/>conditions<sp/>isn&apos;t<sp/>met.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Here&apos;s<sp/>one<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SafeMatcherCast;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>A<sp/>base<sp/>class<sp/>and<sp/>a<sp/>child<sp/>class.</highlight></codeline>
<codeline><highlight class="normal">class<sp/>Base<sp/>{<sp/>...<sp/>};</highlight></codeline>
<codeline><highlight class="normal">class<sp/>Derived<sp/>:<sp/>public<sp/>Base<sp/>{<sp/>...<sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(DoThis,<sp/>void(Derived*<sp/>derived));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>m<sp/>is<sp/>a<sp/>Matcher&lt;Base*&gt;<sp/>we<sp/>got<sp/>from<sp/>somewhere.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(SafeMatcherCast&lt;Derived*&gt;(m)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>find<sp/>`SafeMatcherCast&lt;T&gt;(m)`<sp/>too<sp/>limiting,<sp/>you<sp/>can<sp/>use<sp/>a<sp/>similar</highlight></codeline>
<codeline><highlight class="normal">function<sp/>`MatcherCast&lt;T&gt;(m)`.<sp/>The<sp/>difference<sp/>is<sp/>that<sp/>`MatcherCast`<sp/>works</highlight></codeline>
<codeline><highlight class="normal">as<sp/>long<sp/>as<sp/>you<sp/>can<sp/>`static_cast`<sp/>type<sp/>`T`<sp/>to<sp/>type<sp/>`U`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`MatcherCast`<sp/>essentially<sp/>lets<sp/>you<sp/>bypass<sp/>C++&apos;s<sp/>type<sp/>system</highlight></codeline>
<codeline><highlight class="normal">(`static_cast`<sp/>isn&apos;t<sp/>always<sp/>safe<sp/>as<sp/>it<sp/>could<sp/>throw<sp/>away<sp/>information,</highlight></codeline>
<codeline><highlight class="normal">for<sp/>example),<sp/>so<sp/>be<sp/>careful<sp/>not<sp/>to<sp/>misuse/abuse<sp/>it.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Selecting<sp/>Between<sp/>Overloaded<sp/>Functions<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>expect<sp/>an<sp/>overloaded<sp/>function<sp/>to<sp/>be<sp/>called,<sp/>the<sp/>compiler<sp/>may</highlight></codeline>
<codeline><highlight class="normal">need<sp/>some<sp/>help<sp/>on<sp/>which<sp/>overloaded<sp/>version<sp/>it<sp/>is.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">To<sp/>disambiguate<sp/>functions<sp/>overloaded<sp/>on<sp/>the<sp/>const-ness<sp/>of<sp/>this<sp/>object,</highlight></codeline>
<codeline><highlight class="normal">use<sp/>the<sp/>`Const()`<sp/>argument<sp/>wrapper.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::ReturnRef;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD0(GetBar,<sp/>Bar&amp;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_CONST_METHOD0(GetBar,<sp/>const<sp/>Bar&amp;());</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Bar<sp/>bar1,<sp/>bar2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>GetBar())<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>The<sp/>non-const<sp/>GetBar().</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(ReturnRef(bar1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(Const(foo),<sp/>GetBar())<sp/><sp/>//<sp/>The<sp/>const<sp/>GetBar().</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(ReturnRef(bar2));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">(`Const()`<sp/>is<sp/>defined<sp/>by<sp/>Google<sp/>Mock<sp/>and<sp/>returns<sp/>a<sp/>`const`<sp/>reference</highlight></codeline>
<codeline><highlight class="normal">to<sp/>its<sp/>argument.)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">To<sp/>disambiguate<sp/>overloaded<sp/>functions<sp/>with<sp/>the<sp/>same<sp/>number<sp/>of<sp/>arguments</highlight></codeline>
<codeline><highlight class="normal">but<sp/>different<sp/>argument<sp/>types,<sp/>you<sp/>may<sp/>need<sp/>to<sp/>specify<sp/>the<sp/>exact<sp/>type</highlight></codeline>
<codeline><highlight class="normal">of<sp/>a<sp/>matcher,<sp/>either<sp/>by<sp/>wrapping<sp/>your<sp/>matcher<sp/>in<sp/>`Matcher&lt;type&gt;()`,<sp/>or</highlight></codeline>
<codeline><highlight class="normal">using<sp/>a<sp/>matcher<sp/>whose<sp/>type<sp/>is<sp/>fixed<sp/>(`TypedEq&lt;type&gt;`,<sp/>`An&lt;type&gt;()`,</highlight></codeline>
<codeline><highlight class="normal">etc):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::An;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Lt;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Matcher;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::TypedEq;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockPrinter<sp/>:<sp/>public<sp/>Printer<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(Print,<sp/>void(int<sp/>n));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(Print,<sp/>void(char<sp/>c));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TEST(PrinterTest,<sp/>Print)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockPrinter<sp/>printer;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(printer,<sp/>Print(An&lt;int&gt;()));<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>void<sp/>Print(int);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(printer,<sp/>Print(Matcher&lt;int&gt;(Lt(5))));<sp/><sp/>//<sp/>void<sp/>Print(int);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(printer,<sp/>Print(TypedEq&lt;char&gt;(&apos;a&apos;)));<sp/><sp/><sp/>//<sp/>void<sp/>Print(char);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>printer.Print(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printer.Print(6);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printer.Print(&apos;a&apos;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Performing<sp/>Different<sp/>Actions<sp/>Based<sp/>on<sp/>the<sp/>Arguments<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>a<sp/>mock<sp/>method<sp/>is<sp/>called,<sp/>the<sp/>_last_<sp/>matching<sp/>expectation<sp/>that&apos;s</highlight></codeline>
<codeline><highlight class="normal">still<sp/>active<sp/>will<sp/>be<sp/>selected<sp/>(think<sp/>&quot;newer<sp/>overrides<sp/>older&quot;).<sp/>So,<sp/>you</highlight></codeline>
<codeline><highlight class="normal">can<sp/>make<sp/>a<sp/>method<sp/>do<sp/>different<sp/>things<sp/>depending<sp/>on<sp/>its<sp/>argument<sp/>values</highlight></codeline>
<codeline><highlight class="normal">like<sp/>this:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Lt;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>default<sp/>case.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(&apos;b&apos;));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>more<sp/>specific<sp/>case.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(Lt(5)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(&apos;a&apos;));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Now,<sp/>if<sp/>`foo.DoThis()`<sp/>is<sp/>called<sp/>with<sp/>a<sp/>value<sp/>less<sp/>than<sp/>5,<sp/>`&apos;a&apos;`<sp/>will</highlight></codeline>
<codeline><highlight class="normal">be<sp/>returned;<sp/>otherwise<sp/>`&apos;b&apos;`<sp/>will<sp/>be<sp/>returned.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Matching<sp/>Multiple<sp/>Arguments<sp/>as<sp/>a<sp/>Whole<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>it&apos;s<sp/>not<sp/>enough<sp/>to<sp/>match<sp/>the<sp/>arguments<sp/>individually.<sp/>For</highlight></codeline>
<codeline><highlight class="normal">example,<sp/>we<sp/>may<sp/>want<sp/>to<sp/>say<sp/>that<sp/>the<sp/>first<sp/>argument<sp/>must<sp/>be<sp/>less<sp/>than</highlight></codeline>
<codeline><highlight class="normal">the<sp/>second<sp/>argument.<sp/>The<sp/>`With()`<sp/>clause<sp/>allows<sp/>us<sp/>to<sp/>match</highlight></codeline>
<codeline><highlight class="normal">all<sp/>arguments<sp/>of<sp/>a<sp/>mock<sp/>function<sp/>as<sp/>a<sp/>whole.<sp/>For<sp/>example,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Lt;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Ne;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>InRange(Ne(0),<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.With(Lt());</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">says<sp/>that<sp/>the<sp/>first<sp/>argument<sp/>of<sp/>`InRange()`<sp/>must<sp/>not<sp/>be<sp/>0,<sp/>and<sp/>must<sp/>be</highlight></codeline>
<codeline><highlight class="normal">less<sp/>than<sp/>the<sp/>second<sp/>argument.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>expression<sp/>inside<sp/>`With()`<sp/>must<sp/>be<sp/>a<sp/>matcher<sp/>of<sp/>type</highlight></codeline>
<codeline><highlight class="normal">`Matcher&lt;<sp/>::testing::tuple&lt;A1,<sp/>...,<sp/>An&gt;<sp/>&gt;`,<sp/>where<sp/>`A1`,<sp/>...,<sp/>`An`<sp/>are<sp/>the</highlight></codeline>
<codeline><highlight class="normal">types<sp/>of<sp/>the<sp/>function<sp/>arguments.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>also<sp/>write<sp/>`AllArgs(m)`<sp/>instead<sp/>of<sp/>`m`<sp/>inside<sp/>`.With()`.<sp/>The</highlight></codeline>
<codeline><highlight class="normal">two<sp/>forms<sp/>are<sp/>equivalent,<sp/>but<sp/>`.With(AllArgs(Lt()))`<sp/>is<sp/>more<sp/>readable</highlight></codeline>
<codeline><highlight class="normal">than<sp/>`.With(Lt())`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>use<sp/>`Args&lt;k1,<sp/>...,<sp/>kn&gt;(m)`<sp/>to<sp/>match<sp/>the<sp/>`n`<sp/>selected<sp/>arguments</highlight></codeline>
<codeline><highlight class="normal">(as<sp/>a<sp/>tuple)<sp/>against<sp/>`m`.<sp/>For<sp/>example,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::AllOf;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Args;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Lt;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Blah(_,<sp/>_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.With(AllOf(Args&lt;0,<sp/>1&gt;(Lt()),<sp/>Args&lt;1,<sp/>2&gt;(Lt())));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">says<sp/>that<sp/>`Blah()`<sp/>will<sp/>be<sp/>called<sp/>with<sp/>arguments<sp/>`x`,<sp/>`y`,<sp/>and<sp/>`z`<sp/>where</highlight></codeline>
<codeline><highlight class="normal">`x<sp/>&lt;<sp/>y<sp/>&lt;<sp/>z`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">As<sp/>a<sp/>convenience<sp/>and<sp/>example,<sp/>Google<sp/>Mock<sp/>provides<sp/>some<sp/>matchers<sp/>for</highlight></codeline>
<codeline><highlight class="normal">2-tuples,<sp/>including<sp/>the<sp/>`Lt()`<sp/>matcher<sp/>above.<sp/>See<sp/>the<sp/>[CheatSheet](CheatSheet.md)<sp/>for</highlight></codeline>
<codeline><highlight class="normal">the<sp/>complete<sp/>list.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>if<sp/>you<sp/>want<sp/>to<sp/>pass<sp/>the<sp/>arguments<sp/>to<sp/>a<sp/>predicate<sp/>of<sp/>your<sp/>own</highlight></codeline>
<codeline><highlight class="normal">(e.g.<sp/>`.With(Args&lt;0,<sp/>1&gt;(Truly(&amp;MyPredicate)))`),<sp/>that<sp/>predicate<sp/>MUST<sp/>be</highlight></codeline>
<codeline><highlight class="normal">written<sp/>to<sp/>take<sp/>a<sp/>`::testing::tuple`<sp/>as<sp/>its<sp/>argument;<sp/>Google<sp/>Mock<sp/>will<sp/>pass<sp/>the<sp/>`n`<sp/>selected<sp/>arguments<sp/>as<sp/>_one_<sp/>single<sp/>tuple<sp/>to<sp/>the<sp/>predicate.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Using<sp/>Matchers<sp/>as<sp/>Predicates<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Have<sp/>you<sp/>noticed<sp/>that<sp/>a<sp/>matcher<sp/>is<sp/>just<sp/>a<sp/>fancy<sp/>predicate<sp/>that<sp/>also</highlight></codeline>
<codeline><highlight class="normal">knows<sp/>how<sp/>to<sp/>describe<sp/>itself?<sp/>Many<sp/>existing<sp/>algorithms<sp/>take<sp/>predicates</highlight></codeline>
<codeline><highlight class="normal">as<sp/>arguments<sp/>(e.g.<sp/>those<sp/>defined<sp/>in<sp/>STL&apos;s<sp/>`&lt;algorithm&gt;`<sp/>header),<sp/>and</highlight></codeline>
<codeline><highlight class="normal">it<sp/>would<sp/>be<sp/>a<sp/>shame<sp/>if<sp/>Google<sp/>Mock<sp/>matchers<sp/>are<sp/>not<sp/>allowed<sp/>to</highlight></codeline>
<codeline><highlight class="normal">participate.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Luckily,<sp/>you<sp/>can<sp/>use<sp/>a<sp/>matcher<sp/>where<sp/>a<sp/>unary<sp/>predicate<sp/>functor<sp/>is</highlight></codeline>
<codeline><highlight class="normal">expected<sp/>by<sp/>wrapping<sp/>it<sp/>inside<sp/>the<sp/>`Matches()`<sp/>function.<sp/>For<sp/>example,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;algorithm&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;vector&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">std::vector&lt;int&gt;<sp/>v;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">//<sp/>How<sp/>many<sp/>elements<sp/>in<sp/>v<sp/>are<sp/>&gt;=<sp/>10?</highlight></codeline>
<codeline><highlight class="normal">const<sp/>int<sp/>count<sp/>=<sp/>count_if(v.begin(),<sp/>v.end(),<sp/>Matches(Ge(10)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Since<sp/>you<sp/>can<sp/>build<sp/>complex<sp/>matchers<sp/>from<sp/>simpler<sp/>ones<sp/>easily<sp/>using</highlight></codeline>
<codeline><highlight class="normal">Google<sp/>Mock,<sp/>this<sp/>gives<sp/>you<sp/>a<sp/>way<sp/>to<sp/>conveniently<sp/>construct<sp/>composite</highlight></codeline>
<codeline><highlight class="normal">predicates<sp/>(doing<sp/>the<sp/>same<sp/>using<sp/>STL&apos;s<sp/>`&lt;functional&gt;`<sp/>header<sp/>is<sp/>just</highlight></codeline>
<codeline><highlight class="normal">painful).<sp/>For<sp/>example,<sp/>here&apos;s<sp/>a<sp/>predicate<sp/>that&apos;s<sp/>satisfied<sp/>by<sp/>any</highlight></codeline>
<codeline><highlight class="normal">number<sp/>that<sp/>is<sp/>&gt;=<sp/>0,<sp/>&lt;=<sp/>100,<sp/>and<sp/>!=<sp/>50:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">Matches(AllOf(Ge(0),<sp/>Le(100),<sp/>Ne(50)))</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Using<sp/>Matchers<sp/>in<sp/>Google<sp/>Test<sp/>Assertions<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Since<sp/>matchers<sp/>are<sp/>basically<sp/>predicates<sp/>that<sp/>also<sp/>know<sp/>how<sp/>to<sp/>describe</highlight></codeline>
<codeline><highlight class="normal">themselves,<sp/>there<sp/>is<sp/>a<sp/>way<sp/>to<sp/>take<sp/>advantage<sp/>of<sp/>them<sp/>in</highlight></codeline>
<codeline><highlight class="normal">[Google<sp/>Test](../../googletest/)<sp/>assertions.<sp/>It&apos;s</highlight></codeline>
<codeline><highlight class="normal">called<sp/>`ASSERT_THAT`<sp/>and<sp/>`EXPECT_THAT`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ASSERT_THAT(value,<sp/>matcher);<sp/><sp/>//<sp/>Asserts<sp/>that<sp/>value<sp/>matches<sp/>matcher.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(value,<sp/>matcher);<sp/><sp/>//<sp/>The<sp/>non-fatal<sp/>version.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>example,<sp/>in<sp/>a<sp/>Google<sp/>Test<sp/>test<sp/>you<sp/>can<sp/>write:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;gmock/gmock.h&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">using<sp/>::testing::AllOf;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Ge;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Le;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MatchesRegex;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::StartsWith;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(Foo(),<sp/>StartsWith(&quot;Hello&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(Bar(),<sp/>MatchesRegex(&quot;Line<sp/>\\d+&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ASSERT_THAT(Baz(),<sp/>AllOf(Ge(5),<sp/>Le(10)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">which<sp/>(as<sp/>you<sp/>can<sp/>probably<sp/>guess)<sp/>executes<sp/>`Foo()`,<sp/>`Bar()`,<sp/>and</highlight></codeline>
<codeline><highlight class="normal">`Baz()`,<sp/>and<sp/>verifies<sp/>that:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>`Foo()`<sp/>returns<sp/>a<sp/>string<sp/>that<sp/>starts<sp/>with<sp/>`&quot;Hello&quot;`.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>`Bar()`<sp/>returns<sp/>a<sp/>string<sp/>that<sp/>matches<sp/>regular<sp/>expression<sp/>`&quot;Line<sp/>\\d+&quot;`.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>`Baz()`<sp/>returns<sp/>a<sp/>number<sp/>in<sp/>the<sp/>range<sp/>[5,<sp/>10].</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>nice<sp/>thing<sp/>about<sp/>these<sp/>macros<sp/>is<sp/>that<sp/>_they<sp/>read<sp/>like</highlight></codeline>
<codeline><highlight class="normal">English_.<sp/>They<sp/>generate<sp/>informative<sp/>messages<sp/>too.<sp/>For<sp/>example,<sp/>if<sp/>the</highlight></codeline>
<codeline><highlight class="normal">first<sp/>`EXPECT_THAT()`<sp/>above<sp/>fails,<sp/>the<sp/>message<sp/>will<sp/>be<sp/>something<sp/>like:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>of:<sp/>Foo()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Actual:<sp/>&quot;Hi,<sp/>world!&quot;</highlight></codeline>
<codeline><highlight class="normal">Expected:<sp/>starts<sp/>with<sp/>&quot;Hello&quot;</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**Credit:**<sp/>The<sp/>idea<sp/>of<sp/>`(ASSERT|EXPECT)_THAT`<sp/>was<sp/>stolen<sp/>from<sp/>the</highlight></codeline>
<codeline><highlight class="normal">[Hamcrest](https://github.com/hamcrest/)<sp/>project,<sp/>which<sp/>adds</highlight></codeline>
<codeline><highlight class="normal">`assertThat()`<sp/>to<sp/>JUnit.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Using<sp/>Predicates<sp/>as<sp/>Matchers<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Google<sp/>Mock<sp/>provides<sp/>a<sp/>built-in<sp/>set<sp/>of<sp/>matchers.<sp/>In<sp/>case<sp/>you<sp/>find<sp/>them</highlight></codeline>
<codeline><highlight class="normal">lacking,<sp/>you<sp/>can<sp/>use<sp/>an<sp/>arbitray<sp/>unary<sp/>predicate<sp/>function<sp/>or<sp/>functor</highlight></codeline>
<codeline><highlight class="normal">as<sp/>a<sp/>matcher<sp/>-<sp/>as<sp/>long<sp/>as<sp/>the<sp/>predicate<sp/>accepts<sp/>a<sp/>value<sp/>of<sp/>the<sp/>type</highlight></codeline>
<codeline><highlight class="normal">you<sp/>want.<sp/>You<sp/>do<sp/>this<sp/>by<sp/>wrapping<sp/>the<sp/>predicate<sp/>inside<sp/>the<sp/>`Truly()`</highlight></codeline>
<codeline><highlight class="normal">function,<sp/>for<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Truly;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/>IsEven(int<sp/>n)<sp/>{<sp/>return<sp/>(n<sp/>%<sp/>2)<sp/>==<sp/>0<sp/>?<sp/>1<sp/>:<sp/>0;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Bar()<sp/>must<sp/>be<sp/>called<sp/>with<sp/>an<sp/>even<sp/>number.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(Truly(IsEven)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>the<sp/>predicate<sp/>function<sp/>/<sp/>functor<sp/>doesn&apos;t<sp/>have<sp/>to<sp/>return</highlight></codeline>
<codeline><highlight class="normal">`bool`.<sp/>It<sp/>works<sp/>as<sp/>long<sp/>as<sp/>the<sp/>return<sp/>value<sp/>can<sp/>be<sp/>used<sp/>as<sp/>the</highlight></codeline>
<codeline><highlight class="normal">condition<sp/>in<sp/>statement<sp/>`if<sp/>(condition)<sp/>...`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Matching<sp/>Arguments<sp/>that<sp/>Are<sp/>Not<sp/>Copyable<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>you<sp/>do<sp/>an<sp/>`EXPECT_CALL(mock_obj,<sp/>Foo(bar))`,<sp/>Google<sp/>Mock<sp/>saves</highlight></codeline>
<codeline><highlight class="normal">away<sp/>a<sp/>copy<sp/>of<sp/>`bar`.<sp/>When<sp/>`Foo()`<sp/>is<sp/>called<sp/>later,<sp/>Google<sp/>Mock</highlight></codeline>
<codeline><highlight class="normal">compares<sp/>the<sp/>argument<sp/>to<sp/>`Foo()`<sp/>with<sp/>the<sp/>saved<sp/>copy<sp/>of<sp/>`bar`.<sp/>This</highlight></codeline>
<codeline><highlight class="normal">way,<sp/>you<sp/>don&apos;t<sp/>need<sp/>to<sp/>worry<sp/>about<sp/>`bar`<sp/>being<sp/>modified<sp/>or<sp/>destroyed</highlight></codeline>
<codeline><highlight class="normal">after<sp/>the<sp/>`EXPECT_CALL()`<sp/>is<sp/>executed.<sp/>The<sp/>same<sp/>is<sp/>true<sp/>when<sp/>you<sp/>use</highlight></codeline>
<codeline><highlight class="normal">matchers<sp/>like<sp/>`Eq(bar)`,<sp/>`Le(bar)`,<sp/>and<sp/>so<sp/>on.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">But<sp/>what<sp/>if<sp/>`bar`<sp/>cannot<sp/>be<sp/>copied<sp/>(i.e.<sp/>has<sp/>no<sp/>copy<sp/>constructor)?<sp/>You</highlight></codeline>
<codeline><highlight class="normal">could<sp/>define<sp/>your<sp/>own<sp/>matcher<sp/>function<sp/>and<sp/>use<sp/>it<sp/>with<sp/>`Truly()`,<sp/>as</highlight></codeline>
<codeline><highlight class="normal">the<sp/>previous<sp/>couple<sp/>of<sp/>recipes<sp/>have<sp/>shown.<sp/>Or,<sp/>you<sp/>may<sp/>be<sp/>able<sp/>to<sp/>get</highlight></codeline>
<codeline><highlight class="normal">away<sp/>from<sp/>it<sp/>if<sp/>you<sp/>can<sp/>guarantee<sp/>that<sp/>`bar`<sp/>won&apos;t<sp/>be<sp/>changed<sp/>after</highlight></codeline>
<codeline><highlight class="normal">the<sp/>`EXPECT_CALL()`<sp/>is<sp/>executed.<sp/>Just<sp/>tell<sp/>Google<sp/>Mock<sp/>that<sp/>it<sp/>should</highlight></codeline>
<codeline><highlight class="normal">save<sp/>a<sp/>reference<sp/>to<sp/>`bar`,<sp/>instead<sp/>of<sp/>a<sp/>copy<sp/>of<sp/>it.<sp/>Here&apos;s<sp/>how:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Eq;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::ByRef;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Lt;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Expects<sp/>that<sp/>Foo()&apos;s<sp/>argument<sp/>==<sp/>bar.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_obj,<sp/>Foo(Eq(ByRef(bar))));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Expects<sp/>that<sp/>Foo()&apos;s<sp/>argument<sp/>&lt;<sp/>bar.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_obj,<sp/>Foo(Lt(ByRef(bar))));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Remember:<sp/>if<sp/>you<sp/>do<sp/>this,<sp/>don&apos;t<sp/>change<sp/>`bar`<sp/>after<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`EXPECT_CALL()`,<sp/>or<sp/>the<sp/>result<sp/>is<sp/>undefined.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Validating<sp/>a<sp/>Member<sp/>of<sp/>an<sp/>Object<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Often<sp/>a<sp/>mock<sp/>function<sp/>takes<sp/>a<sp/>reference<sp/>to<sp/>object<sp/>as<sp/>an<sp/>argument.<sp/>When</highlight></codeline>
<codeline><highlight class="normal">matching<sp/>the<sp/>argument,<sp/>you<sp/>may<sp/>not<sp/>want<sp/>to<sp/>compare<sp/>the<sp/>entire<sp/>object</highlight></codeline>
<codeline><highlight class="normal">against<sp/>a<sp/>fixed<sp/>object,<sp/>as<sp/>that<sp/>may<sp/>be<sp/>over-specification.<sp/>Instead,</highlight></codeline>
<codeline><highlight class="normal">you<sp/>may<sp/>need<sp/>to<sp/>validate<sp/>a<sp/>certain<sp/>member<sp/>variable<sp/>or<sp/>the<sp/>result<sp/>of<sp/>a</highlight></codeline>
<codeline><highlight class="normal">certain<sp/>getter<sp/>method<sp/>of<sp/>the<sp/>object.<sp/>You<sp/>can<sp/>do<sp/>this<sp/>with<sp/>`Field()`</highlight></codeline>
<codeline><highlight class="normal">and<sp/>`Property()`.<sp/>More<sp/>specifically,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">Field(&amp;Foo::bar,<sp/>m)</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">is<sp/>a<sp/>matcher<sp/>that<sp/>matches<sp/>a<sp/>`Foo`<sp/>object<sp/>whose<sp/>`bar`<sp/>member<sp/>variable</highlight></codeline>
<codeline><highlight class="normal">satisfies<sp/>matcher<sp/>`m`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">Property(&amp;Foo::baz,<sp/>m)</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">is<sp/>a<sp/>matcher<sp/>that<sp/>matches<sp/>a<sp/>`Foo`<sp/>object<sp/>whose<sp/>`baz()`<sp/>method<sp/>returns</highlight></codeline>
<codeline><highlight class="normal">a<sp/>value<sp/>that<sp/>satisfies<sp/>matcher<sp/>`m`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">&gt;<sp/>|<sp/>`Field(&amp;Foo::number,<sp/>Ge(3))`<sp/>|<sp/>Matches<sp/>`x`<sp/>where<sp/>`x.number<sp/>&gt;=<sp/>3`.<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|:-----------------------------|:-----------------------------------|</highlight></codeline>
<codeline><highlight class="normal">&gt;<sp/>|<sp/>`Property(&amp;Foo::name,<sp/>StartsWith(&quot;John<sp/>&quot;))`<sp/>|<sp/>Matches<sp/>`x`<sp/>where<sp/>`x.name()`<sp/>starts<sp/>with<sp/>`&quot;John<sp/>&quot;`.<sp/>|</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>in<sp/>`Property(&amp;Foo::baz,<sp/>...)`,<sp/>method<sp/>`baz()`<sp/>must<sp/>take<sp/>no</highlight></codeline>
<codeline><highlight class="normal">argument<sp/>and<sp/>be<sp/>declared<sp/>as<sp/>`const`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">BTW,<sp/>`Field()`<sp/>and<sp/>`Property()`<sp/>can<sp/>also<sp/>match<sp/>plain<sp/>pointers<sp/>to</highlight></codeline>
<codeline><highlight class="normal">objects.<sp/>For<sp/>instance,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">Field(&amp;Foo::number,<sp/>Ge(3))</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">matches<sp/>a<sp/>plain<sp/>pointer<sp/>`p`<sp/>where<sp/>`p-&gt;number<sp/>&gt;=<sp/>3`.<sp/>If<sp/>`p`<sp/>is<sp/>`NULL`,</highlight></codeline>
<codeline><highlight class="normal">the<sp/>match<sp/>will<sp/>always<sp/>fail<sp/>regardless<sp/>of<sp/>the<sp/>inner<sp/>matcher.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">What<sp/>if<sp/>you<sp/>want<sp/>to<sp/>validate<sp/>more<sp/>than<sp/>one<sp/>members<sp/>at<sp/>the<sp/>same<sp/>time?</highlight></codeline>
<codeline><highlight class="normal">Remember<sp/>that<sp/>there<sp/>is<sp/>`AllOf()`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Validating<sp/>the<sp/>Value<sp/>Pointed<sp/>to<sp/>by<sp/>a<sp/>Pointer<sp/>Argument<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">C++<sp/>functions<sp/>often<sp/>take<sp/>pointers<sp/>as<sp/>arguments.<sp/>You<sp/>can<sp/>use<sp/>matchers</highlight></codeline>
<codeline><highlight class="normal">like<sp/>`IsNull()`,<sp/>`NotNull()`,<sp/>and<sp/>other<sp/>comparison<sp/>matchers<sp/>to<sp/>match<sp/>a</highlight></codeline>
<codeline><highlight class="normal">pointer,<sp/>but<sp/>what<sp/>if<sp/>you<sp/>want<sp/>to<sp/>make<sp/>sure<sp/>the<sp/>value<sp/>_pointed<sp/>to_<sp/>by</highlight></codeline>
<codeline><highlight class="normal">the<sp/>pointer,<sp/>instead<sp/>of<sp/>the<sp/>pointer<sp/>itself,<sp/>has<sp/>a<sp/>certain<sp/>property?</highlight></codeline>
<codeline><highlight class="normal">Well,<sp/>you<sp/>can<sp/>use<sp/>the<sp/>`Pointee(m)`<sp/>matcher.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`Pointee(m)`<sp/>matches<sp/>a<sp/>pointer<sp/>iff<sp/>`m`<sp/>matches<sp/>the<sp/>value<sp/>the<sp/>pointer</highlight></codeline>
<codeline><highlight class="normal">points<sp/>to.<sp/>For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Ge;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Pointee;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(Pointee(Ge(3))));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">expects<sp/>`foo.Bar()`<sp/>to<sp/>be<sp/>called<sp/>with<sp/>a<sp/>pointer<sp/>that<sp/>points<sp/>to<sp/>a<sp/>value</highlight></codeline>
<codeline><highlight class="normal">greater<sp/>than<sp/>or<sp/>equal<sp/>to<sp/>3.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">One<sp/>nice<sp/>thing<sp/>about<sp/>`Pointee()`<sp/>is<sp/>that<sp/>it<sp/>treats<sp/>a<sp/>`NULL`<sp/>pointer<sp/>as</highlight></codeline>
<codeline><highlight class="normal">a<sp/>match<sp/>failure,<sp/>so<sp/>you<sp/>can<sp/>write<sp/>`Pointee(m)`<sp/>instead<sp/>of</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AllOf(NotNull(),<sp/>Pointee(m))</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">without<sp/>worrying<sp/>that<sp/>a<sp/>`NULL`<sp/>pointer<sp/>will<sp/>crash<sp/>your<sp/>test.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Also,<sp/>did<sp/>we<sp/>tell<sp/>you<sp/>that<sp/>`Pointee()`<sp/>works<sp/>with<sp/>both<sp/>raw<sp/>pointers</highlight></codeline>
<codeline><highlight class="normal">**and**<sp/>smart<sp/>pointers<sp/>(`linked_ptr`,<sp/>`shared_ptr`,<sp/>`scoped_ptr`,<sp/>and</highlight></codeline>
<codeline><highlight class="normal">etc)?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">What<sp/>if<sp/>you<sp/>have<sp/>a<sp/>pointer<sp/>to<sp/>pointer?<sp/>You<sp/>guessed<sp/>it<sp/>-<sp/>you<sp/>can<sp/>use</highlight></codeline>
<codeline><highlight class="normal">nested<sp/>`Pointee()`<sp/>to<sp/>probe<sp/>deeper<sp/>inside<sp/>the<sp/>value.<sp/>For<sp/>example,</highlight></codeline>
<codeline><highlight class="normal">`Pointee(Pointee(Lt(3)))`<sp/>matches<sp/>a<sp/>pointer<sp/>that<sp/>points<sp/>to<sp/>a<sp/>pointer</highlight></codeline>
<codeline><highlight class="normal">that<sp/>points<sp/>to<sp/>a<sp/>number<sp/>less<sp/>than<sp/>3<sp/>(what<sp/>a<sp/>mouthful...).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Testing<sp/>a<sp/>Certain<sp/>Property<sp/>of<sp/>an<sp/>Object<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>you<sp/>want<sp/>to<sp/>specify<sp/>that<sp/>an<sp/>object<sp/>argument<sp/>has<sp/>a<sp/>certain</highlight></codeline>
<codeline><highlight class="normal">property,<sp/>but<sp/>there<sp/>is<sp/>no<sp/>existing<sp/>matcher<sp/>that<sp/>does<sp/>this.<sp/>If<sp/>you<sp/>want</highlight></codeline>
<codeline><highlight class="normal">good<sp/>error<sp/>messages,<sp/>you<sp/>should<sp/>define<sp/>a<sp/>matcher.<sp/>If<sp/>you<sp/>want<sp/>to<sp/>do<sp/>it</highlight></codeline>
<codeline><highlight class="normal">quick<sp/>and<sp/>dirty,<sp/>you<sp/>could<sp/>get<sp/>away<sp/>with<sp/>writing<sp/>an<sp/>ordinary<sp/>function.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Let&apos;s<sp/>say<sp/>you<sp/>have<sp/>a<sp/>mock<sp/>function<sp/>that<sp/>takes<sp/>an<sp/>object<sp/>of<sp/>type<sp/>`Foo`,</highlight></codeline>
<codeline><highlight class="normal">which<sp/>has<sp/>an<sp/>`int<sp/>bar()`<sp/>method<sp/>and<sp/>an<sp/>`int<sp/>baz()`<sp/>method,<sp/>and<sp/>you</highlight></codeline>
<codeline><highlight class="normal">want<sp/>to<sp/>constrain<sp/>that<sp/>the<sp/>argument&apos;s<sp/>`bar()`<sp/>value<sp/>plus<sp/>its<sp/>`baz()`</highlight></codeline>
<codeline><highlight class="normal">value<sp/>is<sp/>a<sp/>given<sp/>number.<sp/>Here&apos;s<sp/>how<sp/>you<sp/>can<sp/>define<sp/>a<sp/>matcher<sp/>to<sp/>do<sp/>it:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MatcherInterface;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MatchResultListener;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>BarPlusBazEqMatcher<sp/>:<sp/>public<sp/>MatcherInterface&lt;const<sp/>Foo&amp;&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>explicit<sp/>BarPlusBazEqMatcher(int<sp/>expected_sum)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>expected_sum_(expected_sum)<sp/>{}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>bool<sp/>MatchAndExplain(const<sp/>Foo&amp;<sp/>foo,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MatchResultListener*<sp/>listener)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(foo.bar()<sp/>+<sp/>foo.baz())<sp/>==<sp/>expected_sum_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>DescribeTo(::std::ostream*<sp/>os)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*os<sp/>&lt;&lt;<sp/>&quot;bar()<sp/>+<sp/>baz()<sp/>equals<sp/>&quot;<sp/>&lt;&lt;<sp/>expected_sum_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>DescribeNegationTo(::std::ostream*<sp/>os)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*os<sp/>&lt;&lt;<sp/>&quot;bar()<sp/>+<sp/>baz()<sp/>does<sp/>not<sp/>equal<sp/>&quot;<sp/>&lt;&lt;<sp/>expected_sum_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>expected_sum_;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">inline<sp/>Matcher&lt;const<sp/>Foo&amp;&gt;<sp/>BarPlusBazEq(int<sp/>expected_sum)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>MakeMatcher(new<sp/>BarPlusBazEqMatcher(expected_sum));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(...,<sp/>DoThis(BarPlusBazEq(5)))...;</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Matching<sp/>Containers<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>an<sp/>STL<sp/>container<sp/>(e.g.<sp/>list,<sp/>vector,<sp/>map,<sp/>...)<sp/>is<sp/>passed<sp/>to</highlight></codeline>
<codeline><highlight class="normal">a<sp/>mock<sp/>function<sp/>and<sp/>you<sp/>may<sp/>want<sp/>to<sp/>validate<sp/>it.<sp/>Since<sp/>most<sp/>STL</highlight></codeline>
<codeline><highlight class="normal">containers<sp/>support<sp/>the<sp/>`==`<sp/>operator,<sp/>you<sp/>can<sp/>write</highlight></codeline>
<codeline><highlight class="normal">`Eq(expected_container)`<sp/>or<sp/>simply<sp/>`expected_container`<sp/>to<sp/>match<sp/>a</highlight></codeline>
<codeline><highlight class="normal">container<sp/>exactly.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes,<sp/>though,<sp/>you<sp/>may<sp/>want<sp/>to<sp/>be<sp/>more<sp/>flexible<sp/>(for<sp/>example,<sp/>the</highlight></codeline>
<codeline><highlight class="normal">first<sp/>element<sp/>must<sp/>be<sp/>an<sp/>exact<sp/>match,<sp/>but<sp/>the<sp/>second<sp/>element<sp/>can<sp/>be</highlight></codeline>
<codeline><highlight class="normal">any<sp/>positive<sp/>number,<sp/>and<sp/>so<sp/>on).<sp/>Also,<sp/>containers<sp/>used<sp/>in<sp/>tests<sp/>often</highlight></codeline>
<codeline><highlight class="normal">have<sp/>a<sp/>small<sp/>number<sp/>of<sp/>elements,<sp/>and<sp/>having<sp/>to<sp/>define<sp/>the<sp/>expected</highlight></codeline>
<codeline><highlight class="normal">container<sp/>out-of-line<sp/>is<sp/>a<sp/>bit<sp/>of<sp/>a<sp/>hassle.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>use<sp/>the<sp/>`ElementsAre()`<sp/>or<sp/>`UnorderedElementsAre()`<sp/>matcher<sp/>in</highlight></codeline>
<codeline><highlight class="normal">such<sp/>cases:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::ElementsAre;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Gt;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(Foo,<sp/>void(const<sp/>vector&lt;int&gt;&amp;<sp/>numbers));</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(ElementsAre(1,<sp/>Gt(0),<sp/>_,<sp/>5)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>above<sp/>matcher<sp/>says<sp/>that<sp/>the<sp/>container<sp/>must<sp/>have<sp/>4<sp/>elements,<sp/>which</highlight></codeline>
<codeline><highlight class="normal">must<sp/>be<sp/>1,<sp/>greater<sp/>than<sp/>0,<sp/>anything,<sp/>and<sp/>5<sp/>respectively.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>instead<sp/>write:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Gt;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::UnorderedElementsAre;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(Foo,<sp/>void(const<sp/>vector&lt;int&gt;&amp;<sp/>numbers));</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(UnorderedElementsAre(1,<sp/>Gt(0),<sp/>_,<sp/>5)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">It<sp/>means<sp/>that<sp/>the<sp/>container<sp/>must<sp/>have<sp/>4<sp/>elements,<sp/>which<sp/>under<sp/>some</highlight></codeline>
<codeline><highlight class="normal">permutation<sp/>must<sp/>be<sp/>1,<sp/>greater<sp/>than<sp/>0,<sp/>anything,<sp/>and<sp/>5<sp/>respectively.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`ElementsAre()`<sp/>and<sp/>`UnorderedElementsAre()`<sp/>are<sp/>overloaded<sp/>to<sp/>take<sp/>0</highlight></codeline>
<codeline><highlight class="normal">to<sp/>10<sp/>arguments.<sp/>If<sp/>more<sp/>are<sp/>needed,<sp/>you<sp/>can<sp/>place<sp/>them<sp/>in<sp/>a<sp/>C-style</highlight></codeline>
<codeline><highlight class="normal">array<sp/>and<sp/>use<sp/>`ElementsAreArray()`<sp/>or<sp/>`UnorderedElementsAreArray()`</highlight></codeline>
<codeline><highlight class="normal">instead:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::ElementsAreArray;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>ElementsAreArray<sp/>accepts<sp/>an<sp/>array<sp/>of<sp/>element<sp/>values.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>expected_vector1[]<sp/>=<sp/>{<sp/>1,<sp/>5,<sp/>2,<sp/>4,<sp/>...<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(ElementsAreArray(expected_vector1)));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Or,<sp/>an<sp/>array<sp/>of<sp/>element<sp/>matchers.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matcher&lt;int&gt;<sp/>expected_vector2<sp/>=<sp/>{<sp/>1,<sp/>Gt(2),<sp/>_,<sp/>3,<sp/>...<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(ElementsAreArray(expected_vector2)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">In<sp/>case<sp/>the<sp/>array<sp/>needs<sp/>to<sp/>be<sp/>dynamically<sp/>created<sp/>(and<sp/>therefore<sp/>the</highlight></codeline>
<codeline><highlight class="normal">array<sp/>size<sp/>cannot<sp/>be<sp/>inferred<sp/>by<sp/>the<sp/>compiler),<sp/>you<sp/>can<sp/>give</highlight></codeline>
<codeline><highlight class="normal">`ElementsAreArray()`<sp/>an<sp/>additional<sp/>argument<sp/>to<sp/>specify<sp/>the<sp/>array<sp/>size:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::ElementsAreArray;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int*<sp/>const<sp/>expected_vector3<sp/>=<sp/>new<sp/>int[count];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>fill<sp/>expected_vector3<sp/>with<sp/>values<sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(ElementsAreArray(expected_vector3,<sp/>count)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**Tips:**</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>`ElementsAre*()`<sp/>can<sp/>be<sp/>used<sp/>to<sp/>match<sp/>_any_<sp/>container<sp/>that<sp/>implements<sp/>the<sp/>STL<sp/>iterator<sp/>pattern<sp/>(i.e.<sp/>it<sp/>has<sp/>a<sp/>`const_iterator`<sp/>type<sp/>and<sp/>supports<sp/>`begin()/end()`),<sp/>not<sp/>just<sp/>the<sp/>ones<sp/>defined<sp/>in<sp/>STL.<sp/>It<sp/>will<sp/>even<sp/>work<sp/>with<sp/>container<sp/>types<sp/>yet<sp/>to<sp/>be<sp/>written<sp/>-<sp/>as<sp/>long<sp/>as<sp/>they<sp/>follows<sp/>the<sp/>above<sp/>pattern.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>You<sp/>can<sp/>use<sp/>nested<sp/>`ElementsAre*()`<sp/>to<sp/>match<sp/>nested<sp/>(multi-dimensional)<sp/>containers.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>If<sp/>the<sp/>container<sp/>is<sp/>passed<sp/>by<sp/>pointer<sp/>instead<sp/>of<sp/>by<sp/>reference,<sp/>just<sp/>write<sp/>`Pointee(ElementsAre*(...))`.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>The<sp/>order<sp/>of<sp/>elements<sp/>_matters_<sp/>for<sp/>`ElementsAre*()`.<sp/>Therefore<sp/>don&apos;t<sp/>use<sp/>it<sp/>with<sp/>containers<sp/>whose<sp/>element<sp/>order<sp/>is<sp/>undefined<sp/>(e.g.<sp/>`hash_map`).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Sharing<sp/>Matchers<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Under<sp/>the<sp/>hood,<sp/>a<sp/>Google<sp/>Mock<sp/>matcher<sp/>object<sp/>consists<sp/>of<sp/>a<sp/>pointer<sp/>to</highlight></codeline>
<codeline><highlight class="normal">a<sp/>ref-counted<sp/>implementation<sp/>object.<sp/>Copying<sp/>matchers<sp/>is<sp/>allowed<sp/>and</highlight></codeline>
<codeline><highlight class="normal">very<sp/>efficient,<sp/>as<sp/>only<sp/>the<sp/>pointer<sp/>is<sp/>copied.<sp/>When<sp/>the<sp/>last<sp/>matcher</highlight></codeline>
<codeline><highlight class="normal">that<sp/>references<sp/>the<sp/>implementation<sp/>object<sp/>dies,<sp/>the<sp/>implementation</highlight></codeline>
<codeline><highlight class="normal">object<sp/>will<sp/>be<sp/>deleted.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Therefore,<sp/>if<sp/>you<sp/>have<sp/>some<sp/>complex<sp/>matcher<sp/>that<sp/>you<sp/>want<sp/>to<sp/>use<sp/>again</highlight></codeline>
<codeline><highlight class="normal">and<sp/>again,<sp/>there<sp/>is<sp/>no<sp/>need<sp/>to<sp/>build<sp/>it<sp/>everytime.<sp/>Just<sp/>assign<sp/>it<sp/>to<sp/>a</highlight></codeline>
<codeline><highlight class="normal">matcher<sp/>variable<sp/>and<sp/>use<sp/>that<sp/>variable<sp/>repeatedly!<sp/>For<sp/>example,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matcher&lt;int&gt;<sp/>in_range<sp/>=<sp/>AllOf(Gt(5),<sp/>Le(10));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>use<sp/>in_range<sp/>as<sp/>a<sp/>matcher<sp/>in<sp/>multiple<sp/>EXPECT_CALLs<sp/>...</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#<sp/>Setting<sp/>Expectations<sp/>#</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Knowing<sp/>When<sp/>to<sp/>Expect<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`ON_CALL`<sp/>is<sp/>likely<sp/>the<sp/>single<sp/>most<sp/>under-utilized<sp/>construct<sp/>in<sp/>Google<sp/>Mock.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">There<sp/>are<sp/>basically<sp/>two<sp/>constructs<sp/>for<sp/>defining<sp/>the<sp/>behavior<sp/>of<sp/>a<sp/>mock<sp/>object:<sp/>`ON_CALL`<sp/>and<sp/>`EXPECT_CALL`.<sp/>The<sp/>difference?<sp/>`ON_CALL`<sp/>defines<sp/>what<sp/>happens<sp/>when<sp/>a<sp/>mock<sp/>method<sp/>is<sp/>called,<sp/>but<sp/>_doesn&apos;t<sp/>imply<sp/>any<sp/>expectation<sp/>on<sp/>the<sp/>method<sp/>being<sp/>called._<sp/>`EXPECT_CALL`<sp/>not<sp/>only<sp/>defines<sp/>the<sp/>behavior,<sp/>but<sp/>also<sp/>sets<sp/>an<sp/>expectation<sp/>that<sp/>_the<sp/>method<sp/>will<sp/>be<sp/>called<sp/>with<sp/>the<sp/>given<sp/>arguments,<sp/>for<sp/>the<sp/>given<sp/>number<sp/>of<sp/>times_<sp/>(and<sp/>_in<sp/>the<sp/>given<sp/>order_<sp/>when<sp/>you<sp/>specify<sp/>the<sp/>order<sp/>too).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Since<sp/>`EXPECT_CALL`<sp/>does<sp/>more,<sp/>isn&apos;t<sp/>it<sp/>better<sp/>than<sp/>`ON_CALL`?<sp/>Not<sp/>really.<sp/>Every<sp/>`EXPECT_CALL`<sp/>adds<sp/>a<sp/>constraint<sp/>on<sp/>the<sp/>behavior<sp/>of<sp/>the<sp/>code<sp/>under<sp/>test.<sp/>Having<sp/>more<sp/>constraints<sp/>than<sp/>necessary<sp/>is<sp/>_baaad_<sp/>-<sp/>even<sp/>worse<sp/>than<sp/>not<sp/>having<sp/>enough<sp/>constraints.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>may<sp/>be<sp/>counter-intuitive.<sp/>How<sp/>could<sp/>tests<sp/>that<sp/>verify<sp/>more<sp/>be<sp/>worse<sp/>than<sp/>tests<sp/>that<sp/>verify<sp/>less?<sp/>Isn&apos;t<sp/>verification<sp/>the<sp/>whole<sp/>point<sp/>of<sp/>tests?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>answer,<sp/>lies<sp/>in<sp/>_what_<sp/>a<sp/>test<sp/>should<sp/>verify.<sp/>**A<sp/>good<sp/>test<sp/>verifies<sp/>the<sp/>contract<sp/>of<sp/>the<sp/>code.**<sp/>If<sp/>a<sp/>test<sp/>over-specifies,<sp/>it<sp/>doesn&apos;t<sp/>leave<sp/>enough<sp/>freedom<sp/>to<sp/>the<sp/>implementation.<sp/>As<sp/>a<sp/>result,<sp/>changing<sp/>the<sp/>implementation<sp/>without<sp/>breaking<sp/>the<sp/>contract<sp/>(e.g.<sp/>refactoring<sp/>and<sp/>optimization),<sp/>which<sp/>should<sp/>be<sp/>perfectly<sp/>fine<sp/>to<sp/>do,<sp/>can<sp/>break<sp/>such<sp/>tests.<sp/>Then<sp/>you<sp/>have<sp/>to<sp/>spend<sp/>time<sp/>fixing<sp/>them,<sp/>only<sp/>to<sp/>see<sp/>them<sp/>broken<sp/>again<sp/>the<sp/>next<sp/>time<sp/>the<sp/>implementation<sp/>is<sp/>changed.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Keep<sp/>in<sp/>mind<sp/>that<sp/>one<sp/>doesn&apos;t<sp/>have<sp/>to<sp/>verify<sp/>more<sp/>than<sp/>one<sp/>property<sp/>in<sp/>one<sp/>test.<sp/>In<sp/>fact,<sp/>**it&apos;s<sp/>a<sp/>good<sp/>style<sp/>to<sp/>verify<sp/>only<sp/>one<sp/>thing<sp/>in<sp/>one<sp/>test.**<sp/>If<sp/>you<sp/>do<sp/>that,<sp/>a<sp/>bug<sp/>will<sp/>likely<sp/>break<sp/>only<sp/>one<sp/>or<sp/>two<sp/>tests<sp/>instead<sp/>of<sp/>dozens<sp/>(which<sp/>case<sp/>would<sp/>you<sp/>rather<sp/>debug?).<sp/>If<sp/>you<sp/>are<sp/>also<sp/>in<sp/>the<sp/>habit<sp/>of<sp/>giving<sp/>tests<sp/>descriptive<sp/>names<sp/>that<sp/>tell<sp/>what<sp/>they<sp/>verify,<sp/>you<sp/>can<sp/>often<sp/>easily<sp/>guess<sp/>what&apos;s<sp/>wrong<sp/>just<sp/>from<sp/>the<sp/>test<sp/>log<sp/>itself.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">So<sp/>use<sp/>`ON_CALL`<sp/>by<sp/>default,<sp/>and<sp/>only<sp/>use<sp/>`EXPECT_CALL`<sp/>when<sp/>you<sp/>actually<sp/>intend<sp/>to<sp/>verify<sp/>that<sp/>the<sp/>call<sp/>is<sp/>made.<sp/>For<sp/>example,<sp/>you<sp/>may<sp/>have<sp/>a<sp/>bunch<sp/>of<sp/>`ON_CALL`s<sp/>in<sp/>your<sp/>test<sp/>fixture<sp/>to<sp/>set<sp/>the<sp/>common<sp/>mock<sp/>behavior<sp/>shared<sp/>by<sp/>all<sp/>tests<sp/>in<sp/>the<sp/>same<sp/>group,<sp/>and<sp/>write<sp/>(scarcely)<sp/>different<sp/>`EXPECT_CALL`s<sp/>in<sp/>different<sp/>`TEST_F`s<sp/>to<sp/>verify<sp/>different<sp/>aspects<sp/>of<sp/>the<sp/>code&apos;s<sp/>behavior.<sp/>Compared<sp/>with<sp/>the<sp/>style<sp/>where<sp/>each<sp/>`TEST`<sp/>has<sp/>many<sp/>`EXPECT_CALL`s,<sp/>this<sp/>leads<sp/>to<sp/>tests<sp/>that<sp/>are<sp/>more<sp/>resilient<sp/>to<sp/>implementational<sp/>changes<sp/>(and<sp/>thus<sp/>less<sp/>likely<sp/>to<sp/>require<sp/>maintenance)<sp/>and<sp/>makes<sp/>the<sp/>intent<sp/>of<sp/>the<sp/>tests<sp/>more<sp/>obvious<sp/>(so<sp/>they<sp/>are<sp/>easier<sp/>to<sp/>maintain<sp/>when<sp/>you<sp/>do<sp/>need<sp/>to<sp/>maintain<sp/>them).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>are<sp/>bothered<sp/>by<sp/>the<sp/>&quot;Uninteresting<sp/>mock<sp/>function<sp/>call&quot;<sp/>message<sp/>printed<sp/>when<sp/>a<sp/>mock<sp/>method<sp/>without<sp/>an<sp/>`EXPECT_CALL`<sp/>is<sp/>called,<sp/>you<sp/>may<sp/>use<sp/>a<sp/>`NiceMock`<sp/>instead<sp/>to<sp/>suppress<sp/>all<sp/>such<sp/>messages<sp/>for<sp/>the<sp/>mock<sp/>object,<sp/>or<sp/>suppress<sp/>the<sp/>message<sp/>for<sp/>specific<sp/>methods<sp/>by<sp/>adding<sp/>`EXPECT_CALL(...).Times(AnyNumber())`.<sp/>DO<sp/>NOT<sp/>suppress<sp/>it<sp/>by<sp/>blindly<sp/>adding<sp/>an<sp/>`EXPECT_CALL(...)`,<sp/>or<sp/>you&apos;ll<sp/>have<sp/>a<sp/>test<sp/>that&apos;s<sp/>a<sp/>pain<sp/>to<sp/>maintain.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Ignoring<sp/>Uninteresting<sp/>Calls<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>are<sp/>not<sp/>interested<sp/>in<sp/>how<sp/>a<sp/>mock<sp/>method<sp/>is<sp/>called,<sp/>just<sp/>don&apos;t</highlight></codeline>
<codeline><highlight class="normal">say<sp/>anything<sp/>about<sp/>it.<sp/>In<sp/>this<sp/>case,<sp/>if<sp/>the<sp/>method<sp/>is<sp/>ever<sp/>called,</highlight></codeline>
<codeline><highlight class="normal">Google<sp/>Mock<sp/>will<sp/>perform<sp/>its<sp/>default<sp/>action<sp/>to<sp/>allow<sp/>the<sp/>test<sp/>program</highlight></codeline>
<codeline><highlight class="normal">to<sp/>continue.<sp/>If<sp/>you<sp/>are<sp/>not<sp/>happy<sp/>with<sp/>the<sp/>default<sp/>action<sp/>taken<sp/>by</highlight></codeline>
<codeline><highlight class="normal">Google<sp/>Mock,<sp/>you<sp/>can<sp/>override<sp/>it<sp/>using<sp/>`DefaultValue&lt;T&gt;::Set()`</highlight></codeline>
<codeline><highlight class="normal">(described<sp/>later<sp/>in<sp/>this<sp/>document)<sp/>or<sp/>`ON_CALL()`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Please<sp/>note<sp/>that<sp/>once<sp/>you<sp/>expressed<sp/>interest<sp/>in<sp/>a<sp/>particular<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">method<sp/>(via<sp/>`EXPECT_CALL()`),<sp/>all<sp/>invocations<sp/>to<sp/>it<sp/>must<sp/>match<sp/>some</highlight></codeline>
<codeline><highlight class="normal">expectation.<sp/>If<sp/>this<sp/>function<sp/>is<sp/>called<sp/>but<sp/>the<sp/>arguments<sp/>don&apos;t<sp/>match</highlight></codeline>
<codeline><highlight class="normal">any<sp/>`EXPECT_CALL()`<sp/>statement,<sp/>it<sp/>will<sp/>be<sp/>an<sp/>error.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Disallowing<sp/>Unexpected<sp/>Calls<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>a<sp/>mock<sp/>method<sp/>shouldn&apos;t<sp/>be<sp/>called<sp/>at<sp/>all,<sp/>explicitly<sp/>say<sp/>so:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(0);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>some<sp/>calls<sp/>to<sp/>the<sp/>method<sp/>are<sp/>allowed,<sp/>but<sp/>the<sp/>rest<sp/>are<sp/>not,<sp/>just</highlight></codeline>
<codeline><highlight class="normal">list<sp/>all<sp/>the<sp/>expected<sp/>calls:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::AnyNumber;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Gt;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(Gt(10)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(AnyNumber());</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>call<sp/>to<sp/>`foo.Bar()`<sp/>that<sp/>doesn&apos;t<sp/>match<sp/>any<sp/>of<sp/>the<sp/>`EXPECT_CALL()`</highlight></codeline>
<codeline><highlight class="normal">statements<sp/>will<sp/>be<sp/>an<sp/>error.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Understanding<sp/>Uninteresting<sp/>vs<sp/>Unexpected<sp/>Calls<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">_Uninteresting_<sp/>calls<sp/>and<sp/>_unexpected_<sp/>calls<sp/>are<sp/>different<sp/>concepts<sp/>in<sp/>Google<sp/>Mock.<sp/>_Very_<sp/>different.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>call<sp/>`x.Y(...)`<sp/>is<sp/>**uninteresting**<sp/>if<sp/>there&apos;s<sp/>_not<sp/>even<sp/>a<sp/>single_<sp/>`EXPECT_CALL(x,<sp/>Y(...))`<sp/>set.<sp/>In<sp/>other<sp/>words,<sp/>the<sp/>test<sp/>isn&apos;t<sp/>interested<sp/>in<sp/>the<sp/>`x.Y()`<sp/>method<sp/>at<sp/>all,<sp/>as<sp/>evident<sp/>in<sp/>that<sp/>the<sp/>test<sp/>doesn&apos;t<sp/>care<sp/>to<sp/>say<sp/>anything<sp/>about<sp/>it.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>call<sp/>`x.Y(...)`<sp/>is<sp/>**unexpected**<sp/>if<sp/>there<sp/>are<sp/>some<sp/>`EXPECT_CALL(x,<sp/>Y(...))s`<sp/>set,<sp/>but<sp/>none<sp/>of<sp/>them<sp/>matches<sp/>the<sp/>call.<sp/>Put<sp/>another<sp/>way,<sp/>the<sp/>test<sp/>is<sp/>interested<sp/>in<sp/>the<sp/>`x.Y()`<sp/>method<sp/>(therefore<sp/>it<sp/>_explicitly_<sp/>sets<sp/>some<sp/>`EXPECT_CALL`<sp/>to<sp/>verify<sp/>how<sp/>it&apos;s<sp/>called);<sp/>however,<sp/>the<sp/>verification<sp/>fails<sp/>as<sp/>the<sp/>test<sp/>doesn&apos;t<sp/>expect<sp/>this<sp/>particular<sp/>call<sp/>to<sp/>happen.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**An<sp/>unexpected<sp/>call<sp/>is<sp/>always<sp/>an<sp/>error,**<sp/>as<sp/>the<sp/>code<sp/>under<sp/>test<sp/>doesn&apos;t<sp/>behave<sp/>the<sp/>way<sp/>the<sp/>test<sp/>expects<sp/>it<sp/>to<sp/>behave.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**By<sp/>default,<sp/>an<sp/>uninteresting<sp/>call<sp/>is<sp/>not<sp/>an<sp/>error,**<sp/>as<sp/>it<sp/>violates<sp/>no<sp/>constraint<sp/>specified<sp/>by<sp/>the<sp/>test.<sp/>(Google<sp/>Mock&apos;s<sp/>philosophy<sp/>is<sp/>that<sp/>saying<sp/>nothing<sp/>means<sp/>there<sp/>is<sp/>no<sp/>constraint.)<sp/>However,<sp/>it<sp/>leads<sp/>to<sp/>a<sp/>warning,<sp/>as<sp/>it<sp/>_might_<sp/>indicate<sp/>a<sp/>problem<sp/>(e.g.<sp/>the<sp/>test<sp/>author<sp/>might<sp/>have<sp/>forgotten<sp/>to<sp/>specify<sp/>a<sp/>constraint).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">In<sp/>Google<sp/>Mock,<sp/>`NiceMock`<sp/>and<sp/>`StrictMock`<sp/>can<sp/>be<sp/>used<sp/>to<sp/>make<sp/>a<sp/>mock<sp/>class<sp/>&quot;nice&quot;<sp/>or<sp/>&quot;strict&quot;.<sp/>How<sp/>does<sp/>this<sp/>affect<sp/>uninteresting<sp/>calls<sp/>and<sp/>unexpected<sp/>calls?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>**nice<sp/>mock**<sp/>suppresses<sp/>uninteresting<sp/>call<sp/>warnings.<sp/>It<sp/>is<sp/>less<sp/>chatty<sp/>than<sp/>the<sp/>default<sp/>mock,<sp/>but<sp/>otherwise<sp/>is<sp/>the<sp/>same.<sp/>If<sp/>a<sp/>test<sp/>fails<sp/>with<sp/>a<sp/>default<sp/>mock,<sp/>it<sp/>will<sp/>also<sp/>fail<sp/>using<sp/>a<sp/>nice<sp/>mock<sp/>instead.<sp/>And<sp/>vice<sp/>versa.<sp/>Don&apos;t<sp/>expect<sp/>making<sp/>a<sp/>mock<sp/>nice<sp/>to<sp/>change<sp/>the<sp/>test&apos;s<sp/>result.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>**strict<sp/>mock**<sp/>turns<sp/>uninteresting<sp/>call<sp/>warnings<sp/>into<sp/>errors.<sp/>So<sp/>making<sp/>a<sp/>mock<sp/>strict<sp/>may<sp/>change<sp/>the<sp/>test&apos;s<sp/>result.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Let&apos;s<sp/>look<sp/>at<sp/>an<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">TEST(...)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>NiceMock&lt;MockDomainRegistry&gt;<sp/>mock_registry;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_registry,<sp/>GetDomainOwner(&quot;google.com&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(&quot;Larry<sp/>Page&quot;));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Use<sp/>mock_registry<sp/>in<sp/>code<sp/>under<sp/>test.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>&amp;mock_registry<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>sole<sp/>`EXPECT_CALL`<sp/>here<sp/>says<sp/>that<sp/>all<sp/>calls<sp/>to<sp/>`GetDomainOwner()`<sp/>must<sp/>have<sp/>`&quot;google.com&quot;`<sp/>as<sp/>the<sp/>argument.<sp/>If<sp/>`GetDomainOwner(&quot;yahoo.com&quot;)`<sp/>is<sp/>called,<sp/>it<sp/>will<sp/>be<sp/>an<sp/>unexpected<sp/>call,<sp/>and<sp/>thus<sp/>an<sp/>error.<sp/>Having<sp/>a<sp/>nice<sp/>mock<sp/>doesn&apos;t<sp/>change<sp/>the<sp/>severity<sp/>of<sp/>an<sp/>unexpected<sp/>call.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">So<sp/>how<sp/>do<sp/>we<sp/>tell<sp/>Google<sp/>Mock<sp/>that<sp/>`GetDomainOwner()`<sp/>can<sp/>be<sp/>called<sp/>with<sp/>some<sp/>other<sp/>arguments<sp/>as<sp/>well?<sp/>The<sp/>standard<sp/>technique<sp/>is<sp/>to<sp/>add<sp/>a<sp/>&quot;catch<sp/>all&quot;<sp/>`EXPECT_CALL`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_registry,<sp/>GetDomainOwner(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.Times(AnyNumber());<sp/><sp/>//<sp/>catches<sp/>all<sp/>other<sp/>calls<sp/>to<sp/>this<sp/>method.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_registry,<sp/>GetDomainOwner(&quot;google.com&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(&quot;Larry<sp/>Page&quot;));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Remember<sp/>that<sp/>`_`<sp/>is<sp/>the<sp/>wildcard<sp/>matcher<sp/>that<sp/>matches<sp/>anything.<sp/>With<sp/>this,<sp/>if<sp/>`GetDomainOwner(&quot;google.com&quot;)`<sp/>is<sp/>called,<sp/>it<sp/>will<sp/>do<sp/>what<sp/>the<sp/>second<sp/>`EXPECT_CALL`<sp/>says;<sp/>if<sp/>it<sp/>is<sp/>called<sp/>with<sp/>a<sp/>different<sp/>argument,<sp/>it<sp/>will<sp/>do<sp/>what<sp/>the<sp/>first<sp/>`EXPECT_CALL`<sp/>says.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>the<sp/>order<sp/>of<sp/>the<sp/>two<sp/>`EXPECT_CALLs`<sp/>is<sp/>important,<sp/>as<sp/>a<sp/>newer<sp/>`EXPECT_CALL`<sp/>takes<sp/>precedence<sp/>over<sp/>an<sp/>older<sp/>one.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>more<sp/>on<sp/>uninteresting<sp/>calls,<sp/>nice<sp/>mocks,<sp/>and<sp/>strict<sp/>mocks,<sp/>read<sp/>[&quot;The<sp/>Nice,<sp/>the<sp/>Strict,<sp/>and<sp/>the<sp/>Naggy&quot;](#the-nice-the-strict-and-the-naggy).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Expecting<sp/>Ordered<sp/>Calls<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Although<sp/>an<sp/>`EXPECT_CALL()`<sp/>statement<sp/>defined<sp/>earlier<sp/>takes<sp/>precedence</highlight></codeline>
<codeline><highlight class="normal">when<sp/>Google<sp/>Mock<sp/>tries<sp/>to<sp/>match<sp/>a<sp/>function<sp/>call<sp/>with<sp/>an<sp/>expectation,</highlight></codeline>
<codeline><highlight class="normal">by<sp/>default<sp/>calls<sp/>don&apos;t<sp/>have<sp/>to<sp/>happen<sp/>in<sp/>the<sp/>order<sp/>`EXPECT_CALL()`</highlight></codeline>
<codeline><highlight class="normal">statements<sp/>are<sp/>written.<sp/>For<sp/>example,<sp/>if<sp/>the<sp/>arguments<sp/>match<sp/>the</highlight></codeline>
<codeline><highlight class="normal">matchers<sp/>in<sp/>the<sp/>third<sp/>`EXPECT_CALL()`,<sp/>but<sp/>not<sp/>those<sp/>in<sp/>the<sp/>first<sp/>two,</highlight></codeline>
<codeline><highlight class="normal">then<sp/>the<sp/>third<sp/>expectation<sp/>will<sp/>be<sp/>used.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>would<sp/>rather<sp/>have<sp/>all<sp/>calls<sp/>occur<sp/>in<sp/>the<sp/>order<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal">expectations,<sp/>put<sp/>the<sp/>`EXPECT_CALL()`<sp/>statements<sp/>in<sp/>a<sp/>block<sp/>where<sp/>you</highlight></codeline>
<codeline><highlight class="normal">define<sp/>a<sp/>variable<sp/>of<sp/>type<sp/>`InSequence`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>::testing::InSequence;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>InSequence<sp/>s;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(bar,<sp/>DoThat(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.Times(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">In<sp/>this<sp/>example,<sp/>we<sp/>expect<sp/>a<sp/>call<sp/>to<sp/>`foo.DoThis(5)`,<sp/>followed<sp/>by<sp/>two</highlight></codeline>
<codeline><highlight class="normal">calls<sp/>to<sp/>`bar.DoThat()`<sp/>where<sp/>the<sp/>argument<sp/>can<sp/>be<sp/>anything,<sp/>which<sp/>are</highlight></codeline>
<codeline><highlight class="normal">in<sp/>turn<sp/>followed<sp/>by<sp/>a<sp/>call<sp/>to<sp/>`foo.DoThis(6)`.<sp/>If<sp/>a<sp/>call<sp/>occurred</highlight></codeline>
<codeline><highlight class="normal">out-of-order,<sp/>Google<sp/>Mock<sp/>will<sp/>report<sp/>an<sp/>error.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Expecting<sp/>Partially<sp/>Ordered<sp/>Calls<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>requiring<sp/>everything<sp/>to<sp/>occur<sp/>in<sp/>a<sp/>predetermined<sp/>order<sp/>can</highlight></codeline>
<codeline><highlight class="normal">lead<sp/>to<sp/>brittle<sp/>tests.<sp/>For<sp/>example,<sp/>we<sp/>may<sp/>care<sp/>about<sp/>`A`<sp/>occurring</highlight></codeline>
<codeline><highlight class="normal">before<sp/>both<sp/>`B`<sp/>and<sp/>`C`,<sp/>but<sp/>aren&apos;t<sp/>interested<sp/>in<sp/>the<sp/>relative<sp/>order</highlight></codeline>
<codeline><highlight class="normal">of<sp/>`B`<sp/>and<sp/>`C`.<sp/>In<sp/>this<sp/>case,<sp/>the<sp/>test<sp/>should<sp/>reflect<sp/>our<sp/>real<sp/>intent,</highlight></codeline>
<codeline><highlight class="normal">instead<sp/>of<sp/>being<sp/>overly<sp/>constraining.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Google<sp/>Mock<sp/>allows<sp/>you<sp/>to<sp/>impose<sp/>an<sp/>arbitrary<sp/>DAG<sp/>(directed<sp/>acyclic</highlight></codeline>
<codeline><highlight class="normal">graph)<sp/>on<sp/>the<sp/>calls.<sp/>One<sp/>way<sp/>to<sp/>express<sp/>the<sp/>DAG<sp/>is<sp/>to<sp/>use<sp/>the</highlight></codeline>
<codeline><highlight class="normal">[After](CheatSheet.md#the-after-clause)<sp/>clause<sp/>of<sp/>`EXPECT_CALL`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Another<sp/>way<sp/>is<sp/>via<sp/>the<sp/>`InSequence()`<sp/>clause<sp/>(not<sp/>the<sp/>same<sp/>as<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`InSequence`<sp/>class),<sp/>which<sp/>we<sp/>borrowed<sp/>from<sp/>jMock<sp/>2.<sp/>It&apos;s<sp/>less</highlight></codeline>
<codeline><highlight class="normal">flexible<sp/>than<sp/>`After()`,<sp/>but<sp/>more<sp/>convenient<sp/>when<sp/>you<sp/>have<sp/>long<sp/>chains</highlight></codeline>
<codeline><highlight class="normal">of<sp/>sequential<sp/>calls,<sp/>as<sp/>it<sp/>doesn&apos;t<sp/>require<sp/>you<sp/>to<sp/>come<sp/>up<sp/>with</highlight></codeline>
<codeline><highlight class="normal">different<sp/>names<sp/>for<sp/>the<sp/>expectations<sp/>in<sp/>the<sp/>chains.<sp/><sp/>Here&apos;s<sp/>how<sp/>it</highlight></codeline>
<codeline><highlight class="normal">works:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>we<sp/>view<sp/>`EXPECT_CALL()`<sp/>statements<sp/>as<sp/>nodes<sp/>in<sp/>a<sp/>graph,<sp/>and<sp/>add<sp/>an</highlight></codeline>
<codeline><highlight class="normal">edge<sp/>from<sp/>node<sp/>A<sp/>to<sp/>node<sp/>B<sp/>wherever<sp/>A<sp/>must<sp/>occur<sp/>before<sp/>B,<sp/>we<sp/>can<sp/>get</highlight></codeline>
<codeline><highlight class="normal">a<sp/>DAG.<sp/>We<sp/>use<sp/>the<sp/>term<sp/>&quot;sequence&quot;<sp/>to<sp/>mean<sp/>a<sp/>directed<sp/>path<sp/>in<sp/>this</highlight></codeline>
<codeline><highlight class="normal">DAG.<sp/>Now,<sp/>if<sp/>we<sp/>decompose<sp/>the<sp/>DAG<sp/>into<sp/>sequences,<sp/>we<sp/>just<sp/>need<sp/>to<sp/>know</highlight></codeline>
<codeline><highlight class="normal">which<sp/>sequences<sp/>each<sp/>`EXPECT_CALL()`<sp/>belongs<sp/>to<sp/>in<sp/>order<sp/>to<sp/>be<sp/>able<sp/>to</highlight></codeline>
<codeline><highlight class="normal">reconstruct<sp/>the<sp/>orginal<sp/>DAG.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">So,<sp/>to<sp/>specify<sp/>the<sp/>partial<sp/>order<sp/>on<sp/>the<sp/>expectations<sp/>we<sp/>need<sp/>to<sp/>do<sp/>two</highlight></codeline>
<codeline><highlight class="normal">things:<sp/>first<sp/>to<sp/>define<sp/>some<sp/>`Sequence`<sp/>objects,<sp/>and<sp/>then<sp/>for<sp/>each</highlight></codeline>
<codeline><highlight class="normal">`EXPECT_CALL()`<sp/>say<sp/>which<sp/>`Sequence`<sp/>objects<sp/>it<sp/>is<sp/>part</highlight></codeline>
<codeline><highlight class="normal">of.<sp/>Expectations<sp/>in<sp/>the<sp/>same<sp/>sequence<sp/>must<sp/>occur<sp/>in<sp/>the<sp/>order<sp/>they<sp/>are</highlight></codeline>
<codeline><highlight class="normal">written.<sp/>For<sp/>example,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>::testing::Sequence;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>Sequence<sp/>s1,<sp/>s2;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>A())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s1,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(bar,<sp/>B())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(bar,<sp/>C())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>D())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s2);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">specifies<sp/>the<sp/>following<sp/>DAG<sp/>(where<sp/>`s1`<sp/>is<sp/>`A<sp/>-&gt;<sp/>B`,<sp/>and<sp/>`s2`<sp/>is<sp/>`A<sp/>-&gt;</highlight></codeline>
<codeline><highlight class="normal">C<sp/>-&gt;<sp/>D`):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+---&gt;<sp/>B</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>A<sp/>---|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+---&gt;<sp/>C<sp/>---&gt;<sp/>D</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>means<sp/>that<sp/>A<sp/>must<sp/>occur<sp/>before<sp/>B<sp/>and<sp/>C,<sp/>and<sp/>C<sp/>must<sp/>occur<sp/>before</highlight></codeline>
<codeline><highlight class="normal">D.<sp/>There&apos;s<sp/>no<sp/>restriction<sp/>about<sp/>the<sp/>order<sp/>other<sp/>than<sp/>these.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Controlling<sp/>When<sp/>an<sp/>Expectation<sp/>Retires<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>a<sp/>mock<sp/>method<sp/>is<sp/>called,<sp/>Google<sp/>Mock<sp/>only<sp/>consider<sp/>expectations</highlight></codeline>
<codeline><highlight class="normal">that<sp/>are<sp/>still<sp/>active.<sp/>An<sp/>expectation<sp/>is<sp/>active<sp/>when<sp/>created,<sp/>and</highlight></codeline>
<codeline><highlight class="normal">becomes<sp/>inactive<sp/>(aka<sp/>_retires_)<sp/>when<sp/>a<sp/>call<sp/>that<sp/>has<sp/>to<sp/>occur<sp/>later</highlight></codeline>
<codeline><highlight class="normal">has<sp/>occurred.<sp/>For<sp/>example,<sp/>in</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>::testing::Sequence;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>Sequence<sp/>s1,<sp/>s2;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/>&quot;File<sp/>too<sp/>large.&quot;))<sp/><sp/><sp/><sp/><sp/>//<sp/>#1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(AnyNumber())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s1,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/>&quot;Data<sp/>set<sp/>is<sp/>empty.&quot;))<sp/><sp/>//<sp/>#2</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/>&quot;User<sp/>not<sp/>found.&quot;))<sp/><sp/><sp/><sp/><sp/>//<sp/>#3</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s2);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">as<sp/>soon<sp/>as<sp/>either<sp/>#2<sp/>or<sp/>#3<sp/>is<sp/>matched,<sp/>#1<sp/>will<sp/>retire.<sp/>If<sp/>a<sp/>warning</highlight></codeline>
<codeline><highlight class="normal">`&quot;File<sp/>too<sp/>large.&quot;`<sp/>is<sp/>logged<sp/>after<sp/>this,<sp/>it<sp/>will<sp/>be<sp/>an<sp/>error.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>an<sp/>expectation<sp/>doesn&apos;t<sp/>retire<sp/>automatically<sp/>when<sp/>it&apos;s</highlight></codeline>
<codeline><highlight class="normal">saturated.<sp/>For<sp/>example,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/>_));<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>#1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/>&quot;File<sp/>too<sp/>large.&quot;));<sp/><sp/>//<sp/>#2</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">says<sp/>that<sp/>there<sp/>will<sp/>be<sp/>exactly<sp/>one<sp/>warning<sp/>with<sp/>the<sp/>message<sp/>`&quot;File</highlight></codeline>
<codeline><highlight class="normal">too<sp/>large.&quot;`.<sp/>If<sp/>the<sp/>second<sp/>warning<sp/>contains<sp/>this<sp/>message<sp/>too,<sp/>#2<sp/>will</highlight></codeline>
<codeline><highlight class="normal">match<sp/>again<sp/>and<sp/>result<sp/>in<sp/>an<sp/>upper-bound-violated<sp/>error.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>this<sp/>is<sp/>not<sp/>what<sp/>you<sp/>want,<sp/>you<sp/>can<sp/>ask<sp/>an<sp/>expectation<sp/>to<sp/>retire<sp/>as</highlight></codeline>
<codeline><highlight class="normal">soon<sp/>as<sp/>it<sp/>becomes<sp/>saturated:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/>_));<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>#1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/>&quot;File<sp/>too<sp/>large.&quot;))<sp/><sp/>//<sp/>#2</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.RetiresOnSaturation();</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Here<sp/>#2<sp/>can<sp/>be<sp/>used<sp/>only<sp/>once,<sp/>so<sp/>if<sp/>you<sp/>have<sp/>two<sp/>warnings<sp/>with<sp/>the</highlight></codeline>
<codeline><highlight class="normal">message<sp/>`&quot;File<sp/>too<sp/>large.&quot;`,<sp/>the<sp/>first<sp/>will<sp/>match<sp/>#2<sp/>and<sp/>the<sp/>second</highlight></codeline>
<codeline><highlight class="normal">will<sp/>match<sp/>#1<sp/>-<sp/>there<sp/>will<sp/>be<sp/>no<sp/>error.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#<sp/>Using<sp/>Actions<sp/>#</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Returning<sp/>References<sp/>from<sp/>Mock<sp/>Methods<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>a<sp/>mock<sp/>function&apos;s<sp/>return<sp/>type<sp/>is<sp/>a<sp/>reference,<sp/>you<sp/>need<sp/>to<sp/>use</highlight></codeline>
<codeline><highlight class="normal">`ReturnRef()`<sp/>instead<sp/>of<sp/>`Return()`<sp/>to<sp/>return<sp/>a<sp/>result:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::ReturnRef;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD0(GetBar,<sp/>Bar&amp;());</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Bar<sp/>bar;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>GetBar())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(ReturnRef(bar));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Returning<sp/>Live<sp/>Values<sp/>from<sp/>Mock<sp/>Methods<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>`Return(x)`<sp/>action<sp/>saves<sp/>a<sp/>copy<sp/>of<sp/>`x`<sp/>when<sp/>the<sp/>action<sp/>is</highlight></codeline>
<codeline><highlight class="normal">_created_,<sp/>and<sp/>always<sp/>returns<sp/>the<sp/>same<sp/>value<sp/>whenever<sp/>it&apos;s</highlight></codeline>
<codeline><highlight class="normal">executed.<sp/>Sometimes<sp/>you<sp/>may<sp/>want<sp/>to<sp/>instead<sp/>return<sp/>the<sp/>_live_<sp/>value<sp/>of</highlight></codeline>
<codeline><highlight class="normal">`x`<sp/>(i.e.<sp/>its<sp/>value<sp/>at<sp/>the<sp/>time<sp/>when<sp/>the<sp/>action<sp/>is<sp/>_executed_.).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>the<sp/>mock<sp/>function&apos;s<sp/>return<sp/>type<sp/>is<sp/>a<sp/>reference,<sp/>you<sp/>can<sp/>do<sp/>it<sp/>using</highlight></codeline>
<codeline><highlight class="normal">`ReturnRef(x)`,<sp/>as<sp/>shown<sp/>in<sp/>the<sp/>previous<sp/>recipe<sp/>(&quot;Returning<sp/>References</highlight></codeline>
<codeline><highlight class="normal">from<sp/>Mock<sp/>Methods&quot;).<sp/>However,<sp/>Google<sp/>Mock<sp/>doesn&apos;t<sp/>let<sp/>you<sp/>use</highlight></codeline>
<codeline><highlight class="normal">`ReturnRef()`<sp/>in<sp/>a<sp/>mock<sp/>function<sp/>whose<sp/>return<sp/>type<sp/>is<sp/>not<sp/>a<sp/>reference,</highlight></codeline>
<codeline><highlight class="normal">as<sp/>doing<sp/>that<sp/>usually<sp/>indicates<sp/>a<sp/>user<sp/>error.<sp/>So,<sp/>what<sp/>shall<sp/>you<sp/>do?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>may<sp/>be<sp/>tempted<sp/>to<sp/>try<sp/>`ByRef()`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>testing::ByRef;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>testing::Return;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD0(GetValue,<sp/>int());</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>x<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>GetValue())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(ByRef(x)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>x<sp/>=<sp/>42;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_EQ(42,<sp/>foo.GetValue());</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Unfortunately,<sp/>it<sp/>doesn&apos;t<sp/>work<sp/>here.<sp/>The<sp/>above<sp/>code<sp/>will<sp/>fail<sp/>with<sp/>error:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>of:<sp/>foo.GetValue()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Actual:<sp/>0</highlight></codeline>
<codeline><highlight class="normal">Expected:<sp/>42</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>reason<sp/>is<sp/>that<sp/>`Return(value)`<sp/>converts<sp/>`value`<sp/>to<sp/>the<sp/>actual</highlight></codeline>
<codeline><highlight class="normal">return<sp/>type<sp/>of<sp/>the<sp/>mock<sp/>function<sp/>at<sp/>the<sp/>time<sp/>when<sp/>the<sp/>action<sp/>is</highlight></codeline>
<codeline><highlight class="normal">_created_,<sp/>not<sp/>when<sp/>it<sp/>is<sp/>_executed_.<sp/>(This<sp/>behavior<sp/>was<sp/>chosen<sp/>for</highlight></codeline>
<codeline><highlight class="normal">the<sp/>action<sp/>to<sp/>be<sp/>safe<sp/>when<sp/>`value`<sp/>is<sp/>a<sp/>proxy<sp/>object<sp/>that<sp/>references</highlight></codeline>
<codeline><highlight class="normal">some<sp/>temporary<sp/>objects.)<sp/>As<sp/>a<sp/>result,<sp/>`ByRef(x)`<sp/>is<sp/>converted<sp/>to<sp/>an</highlight></codeline>
<codeline><highlight class="normal">`int`<sp/>value<sp/>(instead<sp/>of<sp/>a<sp/>`const<sp/>int&amp;`)<sp/>when<sp/>the<sp/>expectation<sp/>is<sp/>set,</highlight></codeline>
<codeline><highlight class="normal">and<sp/>`Return(ByRef(x))`<sp/>will<sp/>always<sp/>return<sp/>0.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`ReturnPointee(pointer)`<sp/>was<sp/>provided<sp/>to<sp/>solve<sp/>this<sp/>problem</highlight></codeline>
<codeline><highlight class="normal">specifically.<sp/>It<sp/>returns<sp/>the<sp/>value<sp/>pointed<sp/>to<sp/>by<sp/>`pointer`<sp/>at<sp/>the<sp/>time</highlight></codeline>
<codeline><highlight class="normal">the<sp/>action<sp/>is<sp/>_executed_:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>testing::ReturnPointee;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>x<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>GetValue())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(ReturnPointee(&amp;x));<sp/><sp/>//<sp/>Note<sp/>the<sp/>&amp;<sp/>here.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>x<sp/>=<sp/>42;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_EQ(42,<sp/>foo.GetValue());<sp/><sp/>//<sp/>This<sp/>will<sp/>succeed<sp/>now.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Combining<sp/>Actions<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Want<sp/>to<sp/>do<sp/>more<sp/>than<sp/>one<sp/>thing<sp/>when<sp/>a<sp/>function<sp/>is<sp/>called?<sp/>That&apos;s</highlight></codeline>
<codeline><highlight class="normal">fine.<sp/>`DoAll()`<sp/>allow<sp/>you<sp/>to<sp/>do<sp/>sequence<sp/>of<sp/>actions<sp/>every<sp/>time.<sp/>Only</highlight></codeline>
<codeline><highlight class="normal">the<sp/>return<sp/>value<sp/>of<sp/>the<sp/>last<sp/>action<sp/>in<sp/>the<sp/>sequence<sp/>will<sp/>be<sp/>used.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::DoAll;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(Bar,<sp/>bool(int<sp/>n));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(DoAll(action_1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>action_2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>action_n));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Mocking<sp/>Side<sp/>Effects<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>a<sp/>method<sp/>exhibits<sp/>its<sp/>effect<sp/>not<sp/>via<sp/>returning<sp/>a<sp/>value<sp/>but</highlight></codeline>
<codeline><highlight class="normal">via<sp/>side<sp/>effects.<sp/>For<sp/>example,<sp/>it<sp/>may<sp/>change<sp/>some<sp/>global<sp/>state<sp/>or</highlight></codeline>
<codeline><highlight class="normal">modify<sp/>an<sp/>output<sp/>argument.<sp/>To<sp/>mock<sp/>side<sp/>effects,<sp/>in<sp/>general<sp/>you<sp/>can</highlight></codeline>
<codeline><highlight class="normal">define<sp/>your<sp/>own<sp/>action<sp/>by<sp/>implementing<sp/>`::testing::ActionInterface`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>all<sp/>you<sp/>need<sp/>to<sp/>do<sp/>is<sp/>to<sp/>change<sp/>an<sp/>output<sp/>argument,<sp/>the<sp/>built-in</highlight></codeline>
<codeline><highlight class="normal">`SetArgPointee()`<sp/>action<sp/>is<sp/>convenient:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SetArgPointee;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockMutator<sp/>:<sp/>public<sp/>Mutator<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD2(Mutate,<sp/>void(bool<sp/>mutate,<sp/>int*<sp/>value));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockMutator<sp/>mutator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mutator,<sp/>Mutate(true,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(SetArgPointee&lt;1&gt;(5));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">In<sp/>this<sp/>example,<sp/>when<sp/>`mutator.Mutate()`<sp/>is<sp/>called,<sp/>we<sp/>will<sp/>assign<sp/>5</highlight></codeline>
<codeline><highlight class="normal">to<sp/>the<sp/>`int`<sp/>variable<sp/>pointed<sp/>to<sp/>by<sp/>argument<sp/>#1</highlight></codeline>
<codeline><highlight class="normal">(0-based).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`SetArgPointee()`<sp/>conveniently<sp/>makes<sp/>an<sp/>internal<sp/>copy<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal">value<sp/>you<sp/>pass<sp/>to<sp/>it,<sp/>removing<sp/>the<sp/>need<sp/>to<sp/>keep<sp/>the<sp/>value<sp/>in<sp/>scope<sp/>and</highlight></codeline>
<codeline><highlight class="normal">alive.<sp/>The<sp/>implication<sp/>however<sp/>is<sp/>that<sp/>the<sp/>value<sp/>must<sp/>have<sp/>a<sp/>copy</highlight></codeline>
<codeline><highlight class="normal">constructor<sp/>and<sp/>assignment<sp/>operator.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>the<sp/>mock<sp/>method<sp/>also<sp/>needs<sp/>to<sp/>return<sp/>a<sp/>value<sp/>as<sp/>well,<sp/>you<sp/>can<sp/>chain</highlight></codeline>
<codeline><highlight class="normal">`SetArgPointee()`<sp/>with<sp/>`Return()`<sp/>using<sp/>`DoAll()`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SetArgPointee;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockMutator<sp/>:<sp/>public<sp/>Mutator<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(MutateInt,<sp/>bool(int*<sp/>value));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockMutator<sp/>mutator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mutator,<sp/>MutateInt(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(DoAll(SetArgPointee&lt;0&gt;(5),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Return(true)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>the<sp/>output<sp/>argument<sp/>is<sp/>an<sp/>array,<sp/>use<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`SetArrayArgument&lt;N&gt;(first,<sp/>last)`<sp/>action<sp/>instead.<sp/>It<sp/>copies<sp/>the</highlight></codeline>
<codeline><highlight class="normal">elements<sp/>in<sp/>source<sp/>range<sp/>`[first,<sp/>last)`<sp/>to<sp/>the<sp/>array<sp/>pointed<sp/>to<sp/>by</highlight></codeline>
<codeline><highlight class="normal">the<sp/>`N`-th<sp/>(0-based)<sp/>argument:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::NotNull;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SetArrayArgument;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockArrayMutator<sp/>:<sp/>public<sp/>ArrayMutator<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD2(Mutate,<sp/>void(int*<sp/>values,<sp/>int<sp/>num_values));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockArrayMutator<sp/>mutator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>values[5]<sp/>=<sp/>{<sp/>1,<sp/>2,<sp/>3,<sp/>4,<sp/>5<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mutator,<sp/>Mutate(NotNull(),<sp/>5))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(SetArrayArgument&lt;0&gt;(values,<sp/>values<sp/>+<sp/>5));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>also<sp/>works<sp/>when<sp/>the<sp/>argument<sp/>is<sp/>an<sp/>output<sp/>iterator:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SeArrayArgument;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockRolodex<sp/>:<sp/>public<sp/>Rolodex<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(GetNames,<sp/>void(std::back_insert_iterator&lt;vector&lt;string&gt;<sp/>&gt;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockRolodex<sp/>rolodex;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vector&lt;string&gt;<sp/>names;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>names.push_back(&quot;George&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>names.push_back(&quot;John&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>names.push_back(&quot;Thomas&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(rolodex,<sp/>GetNames(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(SetArrayArgument&lt;0&gt;(names.begin(),<sp/>names.end()));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Changing<sp/>a<sp/>Mock<sp/>Object&apos;s<sp/>Behavior<sp/>Based<sp/>on<sp/>the<sp/>State<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>expect<sp/>a<sp/>call<sp/>to<sp/>change<sp/>the<sp/>behavior<sp/>of<sp/>a<sp/>mock<sp/>object,<sp/>you<sp/>can<sp/>use<sp/>`::testing::InSequence`<sp/>to<sp/>specify<sp/>different<sp/>behaviors<sp/>before<sp/>and<sp/>after<sp/>the<sp/>call:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::InSequence;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>InSequence<sp/>seq;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(my_mock,<sp/>IsDirty())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(true));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(my_mock,<sp/>Flush());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(my_mock,<sp/>IsDirty())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(false));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>my_mock.FlushIfDirty();</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>makes<sp/>`my_mock.IsDirty()`<sp/>return<sp/>`true`<sp/>before<sp/>`my_mock.Flush()`<sp/>is<sp/>called<sp/>and<sp/>return<sp/>`false`<sp/>afterwards.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>the<sp/>behavior<sp/>change<sp/>is<sp/>more<sp/>complex,<sp/>you<sp/>can<sp/>store<sp/>the<sp/>effects<sp/>in<sp/>a<sp/>variable<sp/>and<sp/>make<sp/>a<sp/>mock<sp/>method<sp/>get<sp/>its<sp/>return<sp/>value<sp/>from<sp/>that<sp/>variable:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SaveArg;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">ACTION_P(ReturnPointee,<sp/>p)<sp/>{<sp/>return<sp/>*p;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>previous_value<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(my_mock,<sp/>GetPrevValue())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(ReturnPointee(&amp;previous_value));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(my_mock,<sp/>UpdateValue(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(SaveArg&lt;0&gt;(&amp;previous_value));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>my_mock.DoSomethingToUpdateValue();</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Here<sp/>`my_mock.GetPrevValue()`<sp/>will<sp/>always<sp/>return<sp/>the<sp/>argument<sp/>of<sp/>the<sp/>last<sp/>`UpdateValue()`<sp/>call.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Setting<sp/>the<sp/>Default<sp/>Value<sp/>for<sp/>a<sp/>Return<sp/>Type<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>a<sp/>mock<sp/>method&apos;s<sp/>return<sp/>type<sp/>is<sp/>a<sp/>built-in<sp/>C++<sp/>type<sp/>or<sp/>pointer,<sp/>by</highlight></codeline>
<codeline><highlight class="normal">default<sp/>it<sp/>will<sp/>return<sp/>0<sp/>when<sp/>invoked.<sp/>Also,<sp/>in<sp/>C++<sp/>11<sp/>and<sp/>above,<sp/>a<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">method<sp/>whose<sp/>return<sp/>type<sp/>has<sp/>a<sp/>default<sp/>constructor<sp/>will<sp/>return<sp/>a<sp/>default-constructed</highlight></codeline>
<codeline><highlight class="normal">value<sp/>by<sp/>default.<sp/><sp/>You<sp/>only<sp/>need<sp/>to<sp/>specify<sp/>an</highlight></codeline>
<codeline><highlight class="normal">action<sp/>if<sp/>this<sp/>default<sp/>value<sp/>doesn&apos;t<sp/>work<sp/>for<sp/>you.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes,<sp/>you<sp/>may<sp/>want<sp/>to<sp/>change<sp/>this<sp/>default<sp/>value,<sp/>or<sp/>you<sp/>may<sp/>want</highlight></codeline>
<codeline><highlight class="normal">to<sp/>specify<sp/>a<sp/>default<sp/>value<sp/>for<sp/>types<sp/>Google<sp/>Mock<sp/>doesn&apos;t<sp/>know</highlight></codeline>
<codeline><highlight class="normal">about.<sp/>You<sp/>can<sp/>do<sp/>this<sp/>using<sp/>the<sp/>`::testing::DefaultValue`<sp/>class</highlight></codeline>
<codeline><highlight class="normal">template:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD0(CalculateBar,<sp/>Bar());</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>Bar<sp/>default_bar;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Sets<sp/>the<sp/>default<sp/>return<sp/>value<sp/>for<sp/>type<sp/>Bar.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DefaultValue&lt;Bar&gt;::Set(default_bar);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>We<sp/>don&apos;t<sp/>need<sp/>to<sp/>specify<sp/>an<sp/>action<sp/>here,<sp/>as<sp/>the<sp/>default</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>return<sp/>value<sp/>works<sp/>for<sp/>us.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>CalculateBar());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.CalculateBar();<sp/><sp/>//<sp/>This<sp/>should<sp/>return<sp/>default_bar.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Unsets<sp/>the<sp/>default<sp/>return<sp/>value.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DefaultValue&lt;Bar&gt;::Clear();</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Please<sp/>note<sp/>that<sp/>changing<sp/>the<sp/>default<sp/>value<sp/>for<sp/>a<sp/>type<sp/>can<sp/>make<sp/>you</highlight></codeline>
<codeline><highlight class="normal">tests<sp/>hard<sp/>to<sp/>understand.<sp/>We<sp/>recommend<sp/>you<sp/>to<sp/>use<sp/>this<sp/>feature</highlight></codeline>
<codeline><highlight class="normal">judiciously.<sp/>For<sp/>example,<sp/>you<sp/>may<sp/>want<sp/>to<sp/>make<sp/>sure<sp/>the<sp/>`Set()`<sp/>and</highlight></codeline>
<codeline><highlight class="normal">`Clear()`<sp/>calls<sp/>are<sp/>right<sp/>next<sp/>to<sp/>the<sp/>code<sp/>that<sp/>uses<sp/>your<sp/>mock.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Setting<sp/>the<sp/>Default<sp/>Actions<sp/>for<sp/>a<sp/>Mock<sp/>Method<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You&apos;ve<sp/>learned<sp/>how<sp/>to<sp/>change<sp/>the<sp/>default<sp/>value<sp/>of<sp/>a<sp/>given</highlight></codeline>
<codeline><highlight class="normal">type.<sp/>However,<sp/>this<sp/>may<sp/>be<sp/>too<sp/>coarse<sp/>for<sp/>your<sp/>purpose:<sp/>perhaps<sp/>you</highlight></codeline>
<codeline><highlight class="normal">have<sp/>two<sp/>mock<sp/>methods<sp/>with<sp/>the<sp/>same<sp/>return<sp/>type<sp/>and<sp/>you<sp/>want<sp/>them<sp/>to</highlight></codeline>
<codeline><highlight class="normal">have<sp/>different<sp/>behaviors.<sp/>The<sp/>`ON_CALL()`<sp/>macro<sp/>allows<sp/>you<sp/>to</highlight></codeline>
<codeline><highlight class="normal">customize<sp/>your<sp/>mock&apos;s<sp/>behavior<sp/>at<sp/>the<sp/>method<sp/>level:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::AnyNumber;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Gt;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ON_CALL(foo,<sp/>Sign(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillByDefault(Return(-1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ON_CALL(foo,<sp/>Sign(0))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillByDefault(Return(0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ON_CALL(foo,<sp/>Sign(Gt(0)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillByDefault(Return(1));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Sign(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(AnyNumber());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.Sign(5);<sp/><sp/><sp/>//<sp/>This<sp/>should<sp/>return<sp/>1.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.Sign(-9);<sp/><sp/>//<sp/>This<sp/>should<sp/>return<sp/>-1.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.Sign(0);<sp/><sp/><sp/>//<sp/>This<sp/>should<sp/>return<sp/>0.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">As<sp/>you<sp/>may<sp/>have<sp/>guessed,<sp/>when<sp/>there<sp/>are<sp/>more<sp/>than<sp/>one<sp/>`ON_CALL()`</highlight></codeline>
<codeline><highlight class="normal">statements,<sp/>the<sp/>news<sp/>order<sp/>take<sp/>precedence<sp/>over<sp/>the<sp/>older<sp/>ones.<sp/>In</highlight></codeline>
<codeline><highlight class="normal">other<sp/>words,<sp/>the<sp/>**last**<sp/>one<sp/>that<sp/>matches<sp/>the<sp/>function<sp/>arguments<sp/>will</highlight></codeline>
<codeline><highlight class="normal">be<sp/>used.<sp/>This<sp/>matching<sp/>order<sp/>allows<sp/>you<sp/>to<sp/>set<sp/>up<sp/>the<sp/>common<sp/>behavior</highlight></codeline>
<codeline><highlight class="normal">in<sp/>a<sp/>mock<sp/>object&apos;s<sp/>constructor<sp/>or<sp/>the<sp/>test<sp/>fixture&apos;s<sp/>set-up<sp/>phase<sp/>and</highlight></codeline>
<codeline><highlight class="normal">specialize<sp/>the<sp/>mock&apos;s<sp/>behavior<sp/>later.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Using<sp/>Functions/Methods/Functors<sp/>as<sp/>Actions<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>the<sp/>built-in<sp/>actions<sp/>don&apos;t<sp/>suit<sp/>you,<sp/>you<sp/>can<sp/>easily<sp/>use<sp/>an<sp/>existing</highlight></codeline>
<codeline><highlight class="normal">function,<sp/>method,<sp/>or<sp/>functor<sp/>as<sp/>an<sp/>action:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD2(Sum,<sp/>int(int<sp/>x,<sp/>int<sp/>y));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(ComplexJob,<sp/>bool(int<sp/>x));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/>CalculateSum(int<sp/>x,<sp/>int<sp/>y)<sp/>{<sp/>return<sp/>x<sp/>+<sp/>y;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>Helper<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>ComplexJob(int<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Helper<sp/>helper;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Sum(_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(CalculateSum));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>ComplexJob(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(&amp;helper,<sp/>&amp;Helper::ComplexJob));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.Sum(5,<sp/>6);<sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Invokes<sp/>CalculateSum(5,<sp/>6).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.ComplexJob(10);<sp/><sp/>//<sp/>Invokes<sp/>helper.ComplexJob(10);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>only<sp/>requirement<sp/>is<sp/>that<sp/>the<sp/>type<sp/>of<sp/>the<sp/>function,<sp/>etc<sp/>must<sp/>be</highlight></codeline>
<codeline><highlight class="normal">_compatible_<sp/>with<sp/>the<sp/>signature<sp/>of<sp/>the<sp/>mock<sp/>function,<sp/>meaning<sp/>that<sp/>the</highlight></codeline>
<codeline><highlight class="normal">latter&apos;s<sp/>arguments<sp/>can<sp/>be<sp/>implicitly<sp/>converted<sp/>to<sp/>the<sp/>corresponding</highlight></codeline>
<codeline><highlight class="normal">arguments<sp/>of<sp/>the<sp/>former,<sp/>and<sp/>the<sp/>former&apos;s<sp/>return<sp/>type<sp/>can<sp/>be</highlight></codeline>
<codeline><highlight class="normal">implicitly<sp/>converted<sp/>to<sp/>that<sp/>of<sp/>the<sp/>latter.<sp/>So,<sp/>you<sp/>can<sp/>invoke</highlight></codeline>
<codeline><highlight class="normal">something<sp/>whose<sp/>type<sp/>is<sp/>_not_<sp/>exactly<sp/>the<sp/>same<sp/>as<sp/>the<sp/>mock<sp/>function,</highlight></codeline>
<codeline><highlight class="normal">as<sp/>long<sp/>as<sp/>it&apos;s<sp/>safe<sp/>to<sp/>do<sp/>so<sp/>-<sp/>nice,<sp/>huh?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Invoking<sp/>a<sp/>Function/Method/Functor<sp/>Without<sp/>Arguments<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`Invoke()`<sp/>is<sp/>very<sp/>useful<sp/>for<sp/>doing<sp/>actions<sp/>that<sp/>are<sp/>more<sp/>complex.<sp/>It</highlight></codeline>
<codeline><highlight class="normal">passes<sp/>the<sp/>mock<sp/>function&apos;s<sp/>arguments<sp/>to<sp/>the<sp/>function<sp/>or<sp/>functor<sp/>being</highlight></codeline>
<codeline><highlight class="normal">invoked<sp/>such<sp/>that<sp/>the<sp/>callee<sp/>has<sp/>the<sp/>full<sp/>context<sp/>of<sp/>the<sp/>call<sp/>to<sp/>work</highlight></codeline>
<codeline><highlight class="normal">with.<sp/>If<sp/>the<sp/>invoked<sp/>function<sp/>is<sp/>not<sp/>interested<sp/>in<sp/>some<sp/>or<sp/>all<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal">arguments,<sp/>it<sp/>can<sp/>simply<sp/>ignore<sp/>them.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Yet,<sp/>a<sp/>common<sp/>pattern<sp/>is<sp/>that<sp/>a<sp/>test<sp/>author<sp/>wants<sp/>to<sp/>invoke<sp/>a<sp/>function</highlight></codeline>
<codeline><highlight class="normal">without<sp/>the<sp/>arguments<sp/>of<sp/>the<sp/>mock<sp/>function.<sp/>`Invoke()`<sp/>allows<sp/>her<sp/>to</highlight></codeline>
<codeline><highlight class="normal">do<sp/>that<sp/>using<sp/>a<sp/>wrapper<sp/>function<sp/>that<sp/>throws<sp/>away<sp/>the<sp/>arguments<sp/>before</highlight></codeline>
<codeline><highlight class="normal">invoking<sp/>an<sp/>underlining<sp/>nullary<sp/>function.<sp/>Needless<sp/>to<sp/>say,<sp/>this<sp/>can<sp/>be</highlight></codeline>
<codeline><highlight class="normal">tedious<sp/>and<sp/>obscures<sp/>the<sp/>intent<sp/>of<sp/>the<sp/>test.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`InvokeWithoutArgs()`<sp/>solves<sp/>this<sp/>problem.<sp/>It&apos;s<sp/>like<sp/>`Invoke()`<sp/>except</highlight></codeline>
<codeline><highlight class="normal">that<sp/>it<sp/>doesn&apos;t<sp/>pass<sp/>the<sp/>mock<sp/>function&apos;s<sp/>arguments<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">callee.<sp/>Here&apos;s<sp/>an<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::InvokeWithoutArgs;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(ComplexJob,<sp/>bool(int<sp/>n));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">bool<sp/>Job1()<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>ComplexJob(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(InvokeWithoutArgs(Job1));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.ComplexJob(10);<sp/><sp/>//<sp/>Invokes<sp/>Job1().</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Invoking<sp/>an<sp/>Argument<sp/>of<sp/>the<sp/>Mock<sp/>Function<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>a<sp/>mock<sp/>function<sp/>will<sp/>receive<sp/>a<sp/>function<sp/>pointer<sp/>or<sp/>a<sp/>functor</highlight></codeline>
<codeline><highlight class="normal">(in<sp/>other<sp/>words,<sp/>a<sp/>&quot;callable&quot;)<sp/>as<sp/>an<sp/>argument,<sp/>e.g.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD2(DoThis,<sp/>bool(int<sp/>n,<sp/>bool<sp/>(*fp)(int)));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">and<sp/>you<sp/>may<sp/>want<sp/>to<sp/>invoke<sp/>this<sp/>callable<sp/>argument:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(...);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Will<sp/>execute<sp/>(*fp)(5),<sp/>where<sp/>fp<sp/>is<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>second<sp/>argument<sp/>DoThis()<sp/>receives.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Arghh,<sp/>you<sp/>need<sp/>to<sp/>refer<sp/>to<sp/>a<sp/>mock<sp/>function<sp/>argument<sp/>but<sp/>C++<sp/>has<sp/>no</highlight></codeline>
<codeline><highlight class="normal">lambda<sp/>(yet),<sp/>so<sp/>you<sp/>have<sp/>to<sp/>define<sp/>your<sp/>own<sp/>action.<sp/>:-(<sp/>Or<sp/>do<sp/>you</highlight></codeline>
<codeline><highlight class="normal">really?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Well,<sp/>Google<sp/>Mock<sp/>has<sp/>an<sp/>action<sp/>to<sp/>solve<sp/>_exactly_<sp/>this<sp/>problem:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>InvokeArgument&lt;N&gt;(arg_1,<sp/>arg_2,<sp/>...,<sp/>arg_m)</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">will<sp/>invoke<sp/>the<sp/>`N`-th<sp/>(0-based)<sp/>argument<sp/>the<sp/>mock<sp/>function<sp/>receives,</highlight></codeline>
<codeline><highlight class="normal">with<sp/>`arg_1`,<sp/>`arg_2`,<sp/>...,<sp/>and<sp/>`arg_m`.<sp/>No<sp/>matter<sp/>if<sp/>the<sp/>argument<sp/>is</highlight></codeline>
<codeline><highlight class="normal">a<sp/>function<sp/>pointer<sp/>or<sp/>a<sp/>functor,<sp/>Google<sp/>Mock<sp/>handles<sp/>them<sp/>both.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">With<sp/>that,<sp/>you<sp/>could<sp/>write:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::InvokeArgument;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(InvokeArgument&lt;1&gt;(5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Will<sp/>execute<sp/>(*fp)(5),<sp/>where<sp/>fp<sp/>is<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>second<sp/>argument<sp/>DoThis()<sp/>receives.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">What<sp/>if<sp/>the<sp/>callable<sp/>takes<sp/>an<sp/>argument<sp/>by<sp/>reference?<sp/>No<sp/>problem<sp/>-<sp/>just</highlight></codeline>
<codeline><highlight class="normal">wrap<sp/>it<sp/>inside<sp/>`ByRef()`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(Bar,<sp/>bool(bool<sp/>(*fp)(int,<sp/>const<sp/>Helper&amp;)));</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::ByRef;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::InvokeArgument;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Helper<sp/>helper;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(InvokeArgument&lt;0&gt;(5,<sp/>ByRef(helper)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>ByRef(helper)<sp/>guarantees<sp/>that<sp/>a<sp/>reference<sp/>to<sp/>helper,<sp/>not<sp/>a<sp/>copy<sp/>of<sp/>it,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>will<sp/>be<sp/>passed<sp/>to<sp/>the<sp/>callable.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">What<sp/>if<sp/>the<sp/>callable<sp/>takes<sp/>an<sp/>argument<sp/>by<sp/>reference<sp/>and<sp/>we<sp/>do<sp/>**not**</highlight></codeline>
<codeline><highlight class="normal">wrap<sp/>the<sp/>argument<sp/>in<sp/>`ByRef()`?<sp/>Then<sp/>`InvokeArgument()`<sp/>will<sp/>_make<sp/>a</highlight></codeline>
<codeline><highlight class="normal">copy_<sp/>of<sp/>the<sp/>argument,<sp/>and<sp/>pass<sp/>a<sp/>_reference<sp/>to<sp/>the<sp/>copy_,<sp/>instead<sp/>of</highlight></codeline>
<codeline><highlight class="normal">a<sp/>reference<sp/>to<sp/>the<sp/>original<sp/>value,<sp/>to<sp/>the<sp/>callable.<sp/>This<sp/>is<sp/>especially</highlight></codeline>
<codeline><highlight class="normal">handy<sp/>when<sp/>the<sp/>argument<sp/>is<sp/>a<sp/>temporary<sp/>value:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(DoThat,<sp/>bool(bool<sp/>(*f)(const<sp/>double&amp;<sp/>x,<sp/>const<sp/>string&amp;<sp/>s)));</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::InvokeArgument;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(InvokeArgument&lt;0&gt;(5.0,<sp/>string(&quot;Hi&quot;)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Will<sp/>execute<sp/>(*f)(5.0,<sp/>string(&quot;Hi&quot;)),<sp/>where<sp/>f<sp/>is<sp/>the<sp/>function<sp/>pointer</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>DoThat()<sp/>receives.<sp/><sp/>Note<sp/>that<sp/>the<sp/>values<sp/>5.0<sp/>and<sp/>string(&quot;Hi&quot;)<sp/>are</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>temporary<sp/>and<sp/>dead<sp/>once<sp/>the<sp/>EXPECT_CALL()<sp/>statement<sp/>finishes.<sp/><sp/>Yet</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>it&apos;s<sp/>fine<sp/>to<sp/>perform<sp/>this<sp/>action<sp/>later,<sp/>since<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>values</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>are<sp/>kept<sp/>inside<sp/>the<sp/>InvokeArgument<sp/>action.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Ignoring<sp/>an<sp/>Action&apos;s<sp/>Result<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>you<sp/>have<sp/>an<sp/>action<sp/>that<sp/>returns<sp/>_something_,<sp/>but<sp/>you<sp/>need<sp/>an</highlight></codeline>
<codeline><highlight class="normal">action<sp/>that<sp/>returns<sp/>`void`<sp/>(perhaps<sp/>you<sp/>want<sp/>to<sp/>use<sp/>it<sp/>in<sp/>a<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">function<sp/>that<sp/>returns<sp/>`void`,<sp/>or<sp/>perhaps<sp/>it<sp/>needs<sp/>to<sp/>be<sp/>used<sp/>in</highlight></codeline>
<codeline><highlight class="normal">`DoAll()`<sp/>and<sp/>it&apos;s<sp/>not<sp/>the<sp/>last<sp/>in<sp/>the<sp/>list).<sp/>`IgnoreResult()`<sp/>lets</highlight></codeline>
<codeline><highlight class="normal">you<sp/>do<sp/>that.<sp/>For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/>Process(const<sp/>MyData&amp;<sp/>data);</highlight></codeline>
<codeline><highlight class="normal">string<sp/>DoSomething();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(Abc,<sp/>void(const<sp/>MyData&amp;<sp/>data));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD0(Xyz,<sp/>bool());</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Abc(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>.WillOnce(Invoke(Process));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>above<sp/>line<sp/>won&apos;t<sp/>compile<sp/>as<sp/>Process()<sp/>returns<sp/>int<sp/>but<sp/>Abc()<sp/>needs</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>to<sp/>return<sp/>void.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(IgnoreResult(Invoke(Process)));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Xyz())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(DoAll(IgnoreResult(Invoke(DoSomething)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Ignores<sp/>the<sp/>string<sp/>DoSomething()<sp/>returns.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Return(true)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>you<sp/>**cannot**<sp/>use<sp/>`IgnoreResult()`<sp/>on<sp/>an<sp/>action<sp/>that<sp/>already</highlight></codeline>
<codeline><highlight class="normal">returns<sp/>`void`.<sp/>Doing<sp/>so<sp/>will<sp/>lead<sp/>to<sp/>ugly<sp/>compiler<sp/>errors.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Selecting<sp/>an<sp/>Action&apos;s<sp/>Arguments<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Say<sp/>you<sp/>have<sp/>a<sp/>mock<sp/>function<sp/>`Foo()`<sp/>that<sp/>takes<sp/>seven<sp/>arguments,<sp/>and</highlight></codeline>
<codeline><highlight class="normal">you<sp/>have<sp/>a<sp/>custom<sp/>action<sp/>that<sp/>you<sp/>want<sp/>to<sp/>invoke<sp/>when<sp/>`Foo()`<sp/>is</highlight></codeline>
<codeline><highlight class="normal">called.<sp/>Trouble<sp/>is,<sp/>the<sp/>custom<sp/>action<sp/>only<sp/>wants<sp/>three<sp/>arguments:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD7(Foo,<sp/>bool(bool<sp/>visible,<sp/>const<sp/>string&amp;<sp/>name,<sp/>int<sp/>x,<sp/>int<sp/>y,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>map&lt;pair&lt;int,<sp/>int&gt;,<sp/>double&gt;&amp;<sp/>weight,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>min_weight,<sp/>double<sp/>max_wight));</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">bool<sp/>IsVisibleInQuadrant1(bool<sp/>visible,<sp/>int<sp/>x,<sp/>int<sp/>y)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>visible<sp/>&amp;&amp;<sp/>x<sp/>&gt;=<sp/>0<sp/>&amp;&amp;<sp/>y<sp/>&gt;=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(_,<sp/>_,<sp/>_,<sp/>_,<sp/>_,<sp/>_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(IsVisibleInQuadrant1));<sp/><sp/>//<sp/>Uh,<sp/>won&apos;t<sp/>compile.<sp/>:-(</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">To<sp/>please<sp/>the<sp/>compiler<sp/>God,<sp/>you<sp/>can<sp/>to<sp/>define<sp/>an<sp/>&quot;adaptor&quot;<sp/>that<sp/>has</highlight></codeline>
<codeline><highlight class="normal">the<sp/>same<sp/>signature<sp/>as<sp/>`Foo()`<sp/>and<sp/>calls<sp/>the<sp/>custom<sp/>action<sp/>with<sp/>the</highlight></codeline>
<codeline><highlight class="normal">right<sp/>arguments:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">bool<sp/>MyIsVisibleInQuadrant1(bool<sp/>visible,<sp/>const<sp/>string&amp;<sp/>name,<sp/>int<sp/>x,<sp/>int<sp/>y,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>map&lt;pair&lt;int,<sp/>int&gt;,<sp/>double&gt;&amp;<sp/>weight,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>min_weight,<sp/>double<sp/>max_wight)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>IsVisibleInQuadrant1(visible,<sp/>x,<sp/>y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(_,<sp/>_,<sp/>_,<sp/>_,<sp/>_,<sp/>_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(MyIsVisibleInQuadrant1));<sp/><sp/>//<sp/>Now<sp/>it<sp/>works.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">But<sp/>isn&apos;t<sp/>this<sp/>awkward?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Google<sp/>Mock<sp/>provides<sp/>a<sp/>generic<sp/>_action<sp/>adaptor_,<sp/>so<sp/>you<sp/>can<sp/>spend<sp/>your</highlight></codeline>
<codeline><highlight class="normal">time<sp/>minding<sp/>more<sp/>important<sp/>business<sp/>than<sp/>writing<sp/>your<sp/>own</highlight></codeline>
<codeline><highlight class="normal">adaptors.<sp/>Here&apos;s<sp/>the<sp/>syntax:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WithArgs&lt;N1,<sp/>N2,<sp/>...,<sp/>Nk&gt;(action)</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">creates<sp/>an<sp/>action<sp/>that<sp/>passes<sp/>the<sp/>arguments<sp/>of<sp/>the<sp/>mock<sp/>function<sp/>at</highlight></codeline>
<codeline><highlight class="normal">the<sp/>given<sp/>indices<sp/>(0-based)<sp/>to<sp/>the<sp/>inner<sp/>`action`<sp/>and<sp/>performs</highlight></codeline>
<codeline><highlight class="normal">it.<sp/>Using<sp/>`WithArgs`,<sp/>our<sp/>original<sp/>example<sp/>can<sp/>be<sp/>written<sp/>as:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::WithArgs;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(_,<sp/>_,<sp/>_,<sp/>_,<sp/>_,<sp/>_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(WithArgs&lt;0,<sp/>2,<sp/>3&gt;(Invoke(IsVisibleInQuadrant1)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>No<sp/>need<sp/>to<sp/>define<sp/>your<sp/>own<sp/>adaptor.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>better<sp/>readability,<sp/>Google<sp/>Mock<sp/>also<sp/>gives<sp/>you:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>`WithoutArgs(action)`<sp/>when<sp/>the<sp/>inner<sp/>`action`<sp/>takes<sp/>_no_<sp/>argument,<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>`WithArg&lt;N&gt;(action)`<sp/>(no<sp/>`s`<sp/>after<sp/>`Arg`)<sp/>when<sp/>the<sp/>inner<sp/>`action`<sp/>takes<sp/>_one_<sp/>argument.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">As<sp/>you<sp/>may<sp/>have<sp/>realized,<sp/>`InvokeWithoutArgs(...)`<sp/>is<sp/>just<sp/>syntactic</highlight></codeline>
<codeline><highlight class="normal">sugar<sp/>for<sp/>`WithoutArgs(Invoke(...))`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Here<sp/>are<sp/>more<sp/>tips:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>The<sp/>inner<sp/>action<sp/>used<sp/>in<sp/>`WithArgs`<sp/>and<sp/>friends<sp/>does<sp/>not<sp/>have<sp/>to<sp/>be<sp/>`Invoke()`<sp/>--<sp/>it<sp/>can<sp/>be<sp/>anything.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>You<sp/>can<sp/>repeat<sp/>an<sp/>argument<sp/>in<sp/>the<sp/>argument<sp/>list<sp/>if<sp/>necessary,<sp/>e.g.<sp/>`WithArgs&lt;2,<sp/>3,<sp/>3,<sp/>5&gt;(...)`.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>You<sp/>can<sp/>change<sp/>the<sp/>order<sp/>of<sp/>the<sp/>arguments,<sp/>e.g.<sp/>`WithArgs&lt;3,<sp/>2,<sp/>1&gt;(...)`.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>The<sp/>types<sp/>of<sp/>the<sp/>selected<sp/>arguments<sp/>do<sp/>_not_<sp/>have<sp/>to<sp/>match<sp/>the<sp/>signature<sp/>of<sp/>the<sp/>inner<sp/>action<sp/>exactly.<sp/>It<sp/>works<sp/>as<sp/>long<sp/>as<sp/>they<sp/>can<sp/>be<sp/>implicitly<sp/>converted<sp/>to<sp/>the<sp/>corresponding<sp/>arguments<sp/>of<sp/>the<sp/>inner<sp/>action.<sp/>For<sp/>example,<sp/>if<sp/>the<sp/>4-th<sp/>argument<sp/>of<sp/>the<sp/>mock<sp/>function<sp/>is<sp/>an<sp/>`int`<sp/>and<sp/>`my_action`<sp/>takes<sp/>a<sp/>`double`,<sp/>`WithArg&lt;4&gt;(my_action)`<sp/>will<sp/>work.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Ignoring<sp/>Arguments<sp/>in<sp/>Action<sp/>Functions<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>selecting-an-action&apos;s-arguments<sp/>recipe<sp/>showed<sp/>us<sp/>one<sp/>way<sp/>to<sp/>make<sp/>a</highlight></codeline>
<codeline><highlight class="normal">mock<sp/>function<sp/>and<sp/>an<sp/>action<sp/>with<sp/>incompatible<sp/>argument<sp/>lists<sp/>fit</highlight></codeline>
<codeline><highlight class="normal">together.<sp/>The<sp/>downside<sp/>is<sp/>that<sp/>wrapping<sp/>the<sp/>action<sp/>in</highlight></codeline>
<codeline><highlight class="normal">`WithArgs&lt;...&gt;()`<sp/>can<sp/>get<sp/>tedious<sp/>for<sp/>people<sp/>writing<sp/>the<sp/>tests.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>are<sp/>defining<sp/>a<sp/>function,<sp/>method,<sp/>or<sp/>functor<sp/>to<sp/>be<sp/>used<sp/>with</highlight></codeline>
<codeline><highlight class="normal">`Invoke*()`,<sp/>and<sp/>you<sp/>are<sp/>not<sp/>interested<sp/>in<sp/>some<sp/>of<sp/>its<sp/>arguments,<sp/>an</highlight></codeline>
<codeline><highlight class="normal">alternative<sp/>to<sp/>`WithArgs`<sp/>is<sp/>to<sp/>declare<sp/>the<sp/>uninteresting<sp/>arguments<sp/>as</highlight></codeline>
<codeline><highlight class="normal">`Unused`.<sp/>This<sp/>makes<sp/>the<sp/>definition<sp/>less<sp/>cluttered<sp/>and<sp/>less<sp/>fragile<sp/>in</highlight></codeline>
<codeline><highlight class="normal">case<sp/>the<sp/>types<sp/>of<sp/>the<sp/>uninteresting<sp/>arguments<sp/>change.<sp/>It<sp/>could<sp/>also</highlight></codeline>
<codeline><highlight class="normal">increase<sp/>the<sp/>chance<sp/>the<sp/>action<sp/>function<sp/>can<sp/>be<sp/>reused.<sp/>For<sp/>example,</highlight></codeline>
<codeline><highlight class="normal">given</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD3(Foo,<sp/>double(const<sp/>string&amp;<sp/>label,<sp/>double<sp/>x,<sp/>double<sp/>y));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD3(Bar,<sp/>double(int<sp/>index,<sp/>double<sp/>x,<sp/>double<sp/>y));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">instead<sp/>of</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">double<sp/>DistanceToOriginWithLabel(const<sp/>string&amp;<sp/>label,<sp/>double<sp/>x,<sp/>double<sp/>y)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>sqrt(x*x<sp/>+<sp/>y*y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">double<sp/>DistanceToOriginWithIndex(int<sp/>index,<sp/>double<sp/>x,<sp/>double<sp/>y)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>sqrt(x*x<sp/>+<sp/>y*y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXEPCT_CALL(mock,<sp/>Foo(&quot;abc&quot;,<sp/>_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(DistanceToOriginWithLabel));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXEPCT_CALL(mock,<sp/>Bar(5,<sp/>_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(DistanceToOriginWithIndex));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">you<sp/>could<sp/>write</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Unused;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">double<sp/>DistanceToOrigin(Unused,<sp/>double<sp/>x,<sp/>double<sp/>y)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>sqrt(x*x<sp/>+<sp/>y*y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXEPCT_CALL(mock,<sp/>Foo(&quot;abc&quot;,<sp/>_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(DistanceToOrigin));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXEPCT_CALL(mock,<sp/>Bar(5,<sp/>_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(DistanceToOrigin));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Sharing<sp/>Actions<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Just<sp/>like<sp/>matchers,<sp/>a<sp/>Google<sp/>Mock<sp/>action<sp/>object<sp/>consists<sp/>of<sp/>a<sp/>pointer</highlight></codeline>
<codeline><highlight class="normal">to<sp/>a<sp/>ref-counted<sp/>implementation<sp/>object.<sp/>Therefore<sp/>copying<sp/>actions<sp/>is</highlight></codeline>
<codeline><highlight class="normal">also<sp/>allowed<sp/>and<sp/>very<sp/>efficient.<sp/>When<sp/>the<sp/>last<sp/>action<sp/>that<sp/>references</highlight></codeline>
<codeline><highlight class="normal">the<sp/>implementation<sp/>object<sp/>dies,<sp/>the<sp/>implementation<sp/>object<sp/>will<sp/>be</highlight></codeline>
<codeline><highlight class="normal">deleted.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>have<sp/>some<sp/>complex<sp/>action<sp/>that<sp/>you<sp/>want<sp/>to<sp/>use<sp/>again<sp/>and<sp/>again,</highlight></codeline>
<codeline><highlight class="normal">you<sp/>may<sp/>not<sp/>have<sp/>to<sp/>build<sp/>it<sp/>from<sp/>scratch<sp/>everytime.<sp/>If<sp/>the<sp/>action</highlight></codeline>
<codeline><highlight class="normal">doesn&apos;t<sp/>have<sp/>an<sp/>internal<sp/>state<sp/>(i.e.<sp/>if<sp/>it<sp/>always<sp/>does<sp/>the<sp/>same<sp/>thing</highlight></codeline>
<codeline><highlight class="normal">no<sp/>matter<sp/>how<sp/>many<sp/>times<sp/>it<sp/>has<sp/>been<sp/>called),<sp/>you<sp/>can<sp/>assign<sp/>it<sp/>to<sp/>an</highlight></codeline>
<codeline><highlight class="normal">action<sp/>variable<sp/>and<sp/>use<sp/>that<sp/>variable<sp/>repeatedly.<sp/>For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Action&lt;bool(int*)&gt;<sp/>set_flag<sp/>=<sp/>DoAll(SetArgPointee&lt;0&gt;(5),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Return(true));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>use<sp/>set_flag<sp/>in<sp/>.WillOnce()<sp/>and<sp/>.WillRepeatedly()<sp/>...</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">However,<sp/>if<sp/>the<sp/>action<sp/>has<sp/>its<sp/>own<sp/>state,<sp/>you<sp/>may<sp/>be<sp/>surprised<sp/>if<sp/>you</highlight></codeline>
<codeline><highlight class="normal">share<sp/>the<sp/>action<sp/>object.<sp/>Suppose<sp/>you<sp/>have<sp/>an<sp/>action<sp/>factory</highlight></codeline>
<codeline><highlight class="normal">`IncrementCounter(init)`<sp/>which<sp/>creates<sp/>an<sp/>action<sp/>that<sp/>increments<sp/>and</highlight></codeline>
<codeline><highlight class="normal">returns<sp/>a<sp/>counter<sp/>whose<sp/>initial<sp/>value<sp/>is<sp/>`init`,<sp/>using<sp/>two<sp/>actions</highlight></codeline>
<codeline><highlight class="normal">created<sp/>from<sp/>the<sp/>same<sp/>expression<sp/>and<sp/>using<sp/>a<sp/>shared<sp/>action<sp/>will</highlight></codeline>
<codeline><highlight class="normal">exihibit<sp/>different<sp/>behaviors.<sp/>Example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(IncrementCounter(0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(IncrementCounter(0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThis();<sp/><sp/>//<sp/>Returns<sp/>1.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThis();<sp/><sp/>//<sp/>Returns<sp/>2.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThat();<sp/><sp/>//<sp/>Returns<sp/>1<sp/>-<sp/>Blah()<sp/>uses<sp/>a<sp/>different</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>counter<sp/>than<sp/>Bar()&apos;s.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">versus</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Action&lt;int()&gt;<sp/>increment<sp/>=<sp/>IncrementCounter(0);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(increment);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(increment);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThis();<sp/><sp/>//<sp/>Returns<sp/>1.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThis();<sp/><sp/>//<sp/>Returns<sp/>2.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThat();<sp/><sp/>//<sp/>Returns<sp/>3<sp/>-<sp/>the<sp/>counter<sp/>is<sp/>shared.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#<sp/>Misc<sp/>Recipes<sp/>on<sp/>Using<sp/>Google<sp/>Mock<sp/>#</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Mocking<sp/>Methods<sp/>That<sp/>Use<sp/>Move-Only<sp/>Types<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">C++11<sp/>introduced<sp/>&lt;em&gt;move-only<sp/>types&lt;/em&gt;.<sp/><sp/>A<sp/>move-only-typed<sp/>value<sp/>can<sp/>be<sp/>moved<sp/>from<sp/>one<sp/>object<sp/>to<sp/>another,<sp/>but<sp/>cannot<sp/>be<sp/>copied.<sp/><sp/>`std::unique_ptr&lt;T&gt;`<sp/>is<sp/>probably<sp/>the<sp/>most<sp/>commonly<sp/>used<sp/>move-only<sp/>type.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Mocking<sp/>a<sp/>method<sp/>that<sp/>takes<sp/>and/or<sp/>returns<sp/>move-only<sp/>types<sp/>presents<sp/>some<sp/>challenges,<sp/>but<sp/>nothing<sp/>insurmountable.<sp/><sp/>This<sp/>recipe<sp/>shows<sp/>you<sp/>how<sp/>you<sp/>can<sp/>do<sp/>it.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Let’s<sp/>say<sp/>we<sp/>are<sp/>working<sp/>on<sp/>a<sp/>fictional<sp/>project<sp/>that<sp/>lets<sp/>one<sp/>post<sp/>and<sp/>share<sp/>snippets<sp/>called<sp/>“buzzes”.<sp/><sp/>Your<sp/>code<sp/>uses<sp/>these<sp/>types:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">enum<sp/>class<sp/>AccessLevel<sp/>{<sp/>kInternal,<sp/>kPublic<sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>Buzz<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>explicit<sp/>Buzz(AccessLevel<sp/>access)<sp/>{<sp/>…<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>Buzzer<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~Buzzer()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>std::unique_ptr&lt;Buzz&gt;<sp/>MakeBuzz(const<sp/>std::string&amp;<sp/>text)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>bool<sp/>ShareBuzz(std::unique_ptr&lt;Buzz&gt;<sp/>buzz,<sp/>Time<sp/>timestamp)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>`Buzz`<sp/>object<sp/>represents<sp/>a<sp/>snippet<sp/>being<sp/>posted.<sp/><sp/>A<sp/>class<sp/>that<sp/>implements<sp/>the<sp/>`Buzzer`<sp/>interface<sp/>is<sp/>capable<sp/>of<sp/>creating<sp/>and<sp/>sharing<sp/>`Buzz`.<sp/><sp/>Methods<sp/>in<sp/>`Buzzer`<sp/>may<sp/>return<sp/>a<sp/>`unique_ptr&lt;Buzz&gt;`<sp/>or<sp/>take<sp/>a<sp/>`unique_ptr&lt;Buzz&gt;`.<sp/><sp/>Now<sp/>we<sp/>need<sp/>to<sp/>mock<sp/>`Buzzer`<sp/>in<sp/>our<sp/>tests.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">To<sp/>mock<sp/>a<sp/>method<sp/>that<sp/>returns<sp/>a<sp/>move-only<sp/>type,<sp/>you<sp/>just<sp/>use<sp/>the<sp/>familiar<sp/>`MOCK_METHOD`<sp/>syntax<sp/>as<sp/>usual:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockBuzzer<sp/>:<sp/>public<sp/>Buzzer<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(MakeBuzz,<sp/>std::unique_ptr&lt;Buzz&gt;(const<sp/>std::string&amp;<sp/>text));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>…</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">However,<sp/>if<sp/>you<sp/>attempt<sp/>to<sp/>use<sp/>the<sp/>same<sp/>`MOCK_METHOD`<sp/>pattern<sp/>to<sp/>mock<sp/>a<sp/>method<sp/>that<sp/>takes<sp/>a<sp/>move-only<sp/>parameter,<sp/>you’ll<sp/>get<sp/>a<sp/>compiler<sp/>error<sp/>currently:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Does<sp/>NOT<sp/>compile!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD2(ShareBuzz,<sp/>bool(std::unique_ptr&lt;Buzz&gt;<sp/>buzz,<sp/>Time<sp/>timestamp));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">While<sp/>it’s<sp/>highly<sp/>desirable<sp/>to<sp/>make<sp/>this<sp/>syntax<sp/>just<sp/>work,<sp/>it’s<sp/>not<sp/>trivial<sp/>and<sp/>the<sp/>work<sp/>hasn’t<sp/>been<sp/>done<sp/>yet.<sp/><sp/>Fortunately,<sp/>there<sp/>is<sp/>a<sp/>trick<sp/>you<sp/>can<sp/>apply<sp/>today<sp/>to<sp/>get<sp/>something<sp/>that<sp/>works<sp/>nearly<sp/>as<sp/>well<sp/>as<sp/>this.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>trick,<sp/>is<sp/>to<sp/>delegate<sp/>the<sp/>`ShareBuzz()`<sp/>method<sp/>to<sp/>a<sp/>mock<sp/>method<sp/>(let’s<sp/>call<sp/>it<sp/>`DoShareBuzz()`)<sp/>that<sp/>does<sp/>not<sp/>take<sp/>move-only<sp/>parameters:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockBuzzer<sp/>:<sp/>public<sp/>Buzzer<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(MakeBuzz,<sp/>std::unique_ptr&lt;Buzz&gt;(const<sp/>std::string&amp;<sp/>text));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD2(DoShareBuzz,<sp/>bool(Buzz*<sp/>buzz,<sp/>Time<sp/>timestamp));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>ShareBuzz(std::unique_ptr&lt;Buzz&gt;<sp/>buzz,<sp/>Time<sp/>timestamp)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>DoShareBuzz(buzz.get(),<sp/>timestamp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>there&apos;s<sp/>no<sp/>need<sp/>to<sp/>define<sp/>or<sp/>declare<sp/>`DoShareBuzz()`<sp/>in<sp/>a<sp/>base<sp/>class.<sp/><sp/>You<sp/>only<sp/>need<sp/>to<sp/>define<sp/>it<sp/>as<sp/>a<sp/>`MOCK_METHOD`<sp/>in<sp/>the<sp/>mock<sp/>class.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Now<sp/>that<sp/>we<sp/>have<sp/>the<sp/>mock<sp/>class<sp/>defined,<sp/>we<sp/>can<sp/>use<sp/>it<sp/>in<sp/>tests.<sp/><sp/>In<sp/>the<sp/>following<sp/>code<sp/>examples,<sp/>we<sp/>assume<sp/>that<sp/>we<sp/>have<sp/>defined<sp/>a<sp/>`MockBuzzer`<sp/>object<sp/>named<sp/>`mock_buzzer_`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockBuzzer<sp/>mock_buzzer_;</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">First<sp/>let’s<sp/>see<sp/>how<sp/>we<sp/>can<sp/>set<sp/>expectations<sp/>on<sp/>the<sp/>`MakeBuzz()`<sp/>method,<sp/>which<sp/>returns<sp/>a<sp/>`unique_ptr&lt;Buzz&gt;`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">As<sp/>usual,<sp/>if<sp/>you<sp/>set<sp/>an<sp/>expectation<sp/>without<sp/>an<sp/>action<sp/>(i.e.<sp/>the<sp/>`.WillOnce()`<sp/>or<sp/>`.WillRepeated()`<sp/>clause),<sp/>when<sp/>that<sp/>expectation<sp/>fires,<sp/>the<sp/>default<sp/>action<sp/>for<sp/>that<sp/>method<sp/>will<sp/>be<sp/>taken.<sp/><sp/>Since<sp/>`unique_ptr&lt;&gt;`<sp/>has<sp/>a<sp/>default<sp/>constructor<sp/>that<sp/>returns<sp/>a<sp/>null<sp/>`unique_ptr`,<sp/>that’s<sp/>what<sp/>you’ll<sp/>get<sp/>if<sp/>you<sp/>don’t<sp/>specify<sp/>an<sp/>action:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Use<sp/>the<sp/>default<sp/>action.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_buzzer_,<sp/>MakeBuzz(&quot;hello&quot;));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Triggers<sp/>the<sp/>previous<sp/>EXPECT_CALL.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_EQ(nullptr,<sp/>mock_buzzer_.MakeBuzz(&quot;hello&quot;));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>are<sp/>not<sp/>happy<sp/>with<sp/>the<sp/>default<sp/>action,<sp/>you<sp/>can<sp/>tweak<sp/>it.<sp/><sp/>Depending<sp/>on<sp/>what<sp/>you<sp/>need,<sp/>you<sp/>may<sp/>either<sp/>tweak<sp/>the<sp/>default<sp/>action<sp/>for<sp/>a<sp/>specific<sp/>(mock<sp/>object,<sp/>mock<sp/>method)<sp/>combination<sp/>using<sp/>`ON_CALL()`,<sp/>or<sp/>you<sp/>may<sp/>tweak<sp/>the<sp/>default<sp/>action<sp/>for<sp/>all<sp/>mock<sp/>methods<sp/>that<sp/>return<sp/>a<sp/>specific<sp/>type.<sp/><sp/>The<sp/>usage<sp/>of<sp/>`ON_CALL()`<sp/>is<sp/>similar<sp/>to<sp/>`EXPECT_CALL()`,<sp/>so<sp/>we’ll<sp/>skip<sp/>it<sp/>and<sp/>just<sp/>explain<sp/>how<sp/>to<sp/>do<sp/>the<sp/>latter<sp/>(tweaking<sp/>the<sp/>default<sp/>action<sp/>for<sp/>a<sp/>specific<sp/>return<sp/>type).<sp/><sp/>You<sp/>do<sp/>this<sp/>via<sp/>the<sp/>`DefaultValue&lt;&gt;::SetFactory()`<sp/>and<sp/>`DefaultValue&lt;&gt;::Clear()`<sp/>API:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Sets<sp/>the<sp/>default<sp/>action<sp/>for<sp/>return<sp/>type<sp/>std::unique_ptr&lt;Buzz&gt;<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>creating<sp/>a<sp/>new<sp/>Buzz<sp/>every<sp/>time.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DefaultValue&lt;std::unique_ptr&lt;Buzz&gt;&gt;::SetFactory(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>[]<sp/>{<sp/>return<sp/>MakeUnique&lt;Buzz&gt;(AccessLevel::kInternal);<sp/>});</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>When<sp/>this<sp/>fires,<sp/>the<sp/>default<sp/>action<sp/>of<sp/>MakeBuzz()<sp/>will<sp/>run,<sp/>which</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>will<sp/>return<sp/>a<sp/>new<sp/>Buzz<sp/>object.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_buzzer_,<sp/>MakeBuzz(&quot;hello&quot;)).Times(AnyNumber());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>buzz1<sp/>=<sp/>mock_buzzer_.MakeBuzz(&quot;hello&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>buzz2<sp/>=<sp/>mock_buzzer_.MakeBuzz(&quot;hello&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_NE(nullptr,<sp/>buzz1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_NE(nullptr,<sp/>buzz2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_NE(buzz1,<sp/>buzz2);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Resets<sp/>the<sp/>default<sp/>action<sp/>for<sp/>return<sp/>type<sp/>std::unique_ptr&lt;Buzz&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>to<sp/>avoid<sp/>interfere<sp/>with<sp/>other<sp/>tests.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DefaultValue&lt;std::unique_ptr&lt;Buzz&gt;&gt;::Clear();</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">What<sp/>if<sp/>you<sp/>want<sp/>the<sp/>method<sp/>to<sp/>do<sp/>something<sp/>other<sp/>than<sp/>the<sp/>default<sp/>action?<sp/><sp/>If<sp/>you<sp/>just<sp/>need<sp/>to<sp/>return<sp/>a<sp/>pre-defined<sp/>move-only<sp/>value,<sp/>you<sp/>can<sp/>use<sp/>the<sp/>`Return(ByMove(...))`<sp/>action:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>When<sp/>this<sp/>fires,<sp/>the<sp/>unique_ptr&lt;&gt;<sp/>specified<sp/>by<sp/>ByMove(...)<sp/>will</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>be<sp/>returned.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_buzzer_,<sp/>MakeBuzz(&quot;world&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Return(ByMove(MakeUnique&lt;Buzz&gt;(AccessLevel::kInternal))));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_NE(nullptr,<sp/>mock_buzzer_.MakeBuzz(&quot;world&quot;));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>`ByMove()`<sp/>is<sp/>essential<sp/>here<sp/>-<sp/>if<sp/>you<sp/>drop<sp/>it,<sp/>the<sp/>code<sp/>won’t<sp/>compile.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Quiz<sp/>time!<sp/><sp/>What<sp/>do<sp/>you<sp/>think<sp/>will<sp/>happen<sp/>if<sp/>a<sp/>`Return(ByMove(...))`<sp/>action<sp/>is<sp/>performed<sp/>more<sp/>than<sp/>once<sp/>(e.g.<sp/>you<sp/>write<sp/>`….WillRepeatedly(Return(ByMove(...)));`)?<sp/><sp/>Come<sp/>think<sp/>of<sp/>it,<sp/>after<sp/>the<sp/>first<sp/>time<sp/>the<sp/>action<sp/>runs,<sp/>the<sp/>source<sp/>value<sp/>will<sp/>be<sp/>consumed<sp/>(since<sp/>it’s<sp/>a<sp/>move-only<sp/>value),<sp/>so<sp/>the<sp/>next<sp/>time<sp/>around,<sp/>there’s<sp/>no<sp/>value<sp/>to<sp/>move<sp/>from<sp/>--<sp/>you’ll<sp/>get<sp/>a<sp/>run-time<sp/>error<sp/>that<sp/>`Return(ByMove(...))`<sp/>can<sp/>only<sp/>be<sp/>run<sp/>once.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>need<sp/>your<sp/>mock<sp/>method<sp/>to<sp/>do<sp/>more<sp/>than<sp/>just<sp/>moving<sp/>a<sp/>pre-defined<sp/>value,<sp/>remember<sp/>that<sp/>you<sp/>can<sp/>always<sp/>use<sp/>`Invoke()`<sp/>to<sp/>call<sp/>a<sp/>lambda<sp/>or<sp/>a<sp/>callable<sp/>object,<sp/>which<sp/>can<sp/>do<sp/>pretty<sp/>much<sp/>anything<sp/>you<sp/>want:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_buzzer_,<sp/>MakeBuzz(&quot;x&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Invoke([](const<sp/>std::string&amp;<sp/>text)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>std::make_unique&lt;Buzz&gt;(AccessLevel::kInternal);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_NE(nullptr,<sp/>mock_buzzer_.MakeBuzz(&quot;x&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_NE(nullptr,<sp/>mock_buzzer_.MakeBuzz(&quot;x&quot;));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Every<sp/>time<sp/>this<sp/>`EXPECT_CALL`<sp/>fires,<sp/>a<sp/>new<sp/>`unique_ptr&lt;Buzz&gt;`<sp/>will<sp/>be<sp/>created<sp/>and<sp/>returned.<sp/><sp/>You<sp/>cannot<sp/>do<sp/>this<sp/>with<sp/>`Return(ByMove(...))`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Now<sp/>there’s<sp/>one<sp/>topic<sp/>we<sp/>haven’t<sp/>covered:<sp/>how<sp/>do<sp/>you<sp/>set<sp/>expectations<sp/>on<sp/>`ShareBuzz()`,<sp/>which<sp/>takes<sp/>a<sp/>move-only-typed<sp/>parameter?<sp/><sp/>The<sp/>answer<sp/>is<sp/>you<sp/>don’t.<sp/><sp/>Instead,<sp/>you<sp/>set<sp/>expectations<sp/>on<sp/>the<sp/>`DoShareBuzz()`<sp/>mock<sp/>method<sp/>(remember<sp/>that<sp/>we<sp/>defined<sp/>a<sp/>`MOCK_METHOD`<sp/>for<sp/>`DoShareBuzz()`,<sp/>not<sp/>`ShareBuzz()`):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_buzzer_,<sp/>DoShareBuzz(NotNull(),<sp/>_));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>When<sp/>one<sp/>calls<sp/>ShareBuzz()<sp/>on<sp/>the<sp/>MockBuzzer<sp/>like<sp/>this,<sp/>the<sp/>call<sp/>is</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>forwarded<sp/>to<sp/>DoShareBuzz(),<sp/>which<sp/>is<sp/>mocked.<sp/><sp/>Therefore<sp/>this<sp/>statement</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>will<sp/>trigger<sp/>the<sp/>above<sp/>EXPECT_CALL.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mock_buzzer_.ShareBuzz(MakeUnique&amp;lt;Buzz&amp;gt;(AccessLevel::kInternal),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>::base::Now());</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Some<sp/>of<sp/>you<sp/>may<sp/>have<sp/>spotted<sp/>one<sp/>problem<sp/>with<sp/>this<sp/>approach:<sp/>the<sp/>`DoShareBuzz()`<sp/>mock<sp/>method<sp/>differs<sp/>from<sp/>the<sp/>real<sp/>`ShareBuzz()`<sp/>method<sp/>in<sp/>that<sp/>it<sp/>cannot<sp/>take<sp/>ownership<sp/>of<sp/>the<sp/>buzz<sp/>parameter<sp/>-<sp/>`ShareBuzz()`<sp/>will<sp/>always<sp/>delete<sp/>buzz<sp/>after<sp/>`DoShareBuzz()`<sp/>returns.<sp/><sp/>What<sp/>if<sp/>you<sp/>need<sp/>to<sp/>save<sp/>the<sp/>buzz<sp/>object<sp/>somewhere<sp/>for<sp/>later<sp/>use<sp/>when<sp/>`ShareBuzz()`<sp/>is<sp/>called?<sp/><sp/>Indeed,<sp/>you&apos;d<sp/>be<sp/>stuck.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Another<sp/>problem<sp/>with<sp/>the<sp/>`DoShareBuzz()`<sp/>we<sp/>had<sp/>is<sp/>that<sp/>it<sp/>can<sp/>surprise<sp/>people<sp/>reading<sp/>or<sp/>maintaining<sp/>the<sp/>test,<sp/>as<sp/>one<sp/>would<sp/>expect<sp/>that<sp/>`DoShareBuzz()`<sp/>has<sp/>(logically)<sp/>the<sp/>same<sp/>contract<sp/>as<sp/>`ShareBuzz()`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Fortunately,<sp/>these<sp/>problems<sp/>can<sp/>be<sp/>fixed<sp/>with<sp/>a<sp/>bit<sp/>more<sp/>code.<sp/><sp/>Let&apos;s<sp/>try<sp/>to<sp/>get<sp/>it<sp/>right<sp/>this<sp/>time:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockBuzzer<sp/>:<sp/>public<sp/>Buzzer<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockBuzzer()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Since<sp/>DoShareBuzz(buzz,<sp/>time)<sp/>is<sp/>supposed<sp/>to<sp/>take<sp/>ownership<sp/>of</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>buzz,<sp/>define<sp/>a<sp/>default<sp/>behavior<sp/>for<sp/>DoShareBuzz(buzz,<sp/>time)<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>delete<sp/>buzz.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ON_CALL(*this,<sp/>DoShareBuzz(_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.WillByDefault(Invoke([](Buzz*<sp/>buzz,<sp/>Time<sp/>timestamp)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delete<sp/>buzz;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(MakeBuzz,<sp/>std::unique_ptr&lt;Buzz&gt;(const<sp/>std::string&amp;<sp/>text));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Takes<sp/>ownership<sp/>of<sp/>buzz.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD2(DoShareBuzz,<sp/>bool(Buzz*<sp/>buzz,<sp/>Time<sp/>timestamp));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>ShareBuzz(std::unique_ptr&lt;Buzz&gt;<sp/>buzz,<sp/>Time<sp/>timestamp)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>DoShareBuzz(buzz.release(),<sp/>timestamp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Now,<sp/>the<sp/>mock<sp/>`DoShareBuzz()`<sp/>method<sp/>is<sp/>free<sp/>to<sp/>save<sp/>the<sp/>buzz<sp/>argument<sp/>for<sp/>later<sp/>use<sp/>if<sp/>this<sp/>is<sp/>what<sp/>you<sp/>want:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::unique_ptr&lt;Buzz&gt;<sp/>intercepted_buzz;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_buzzer_,<sp/>DoShareBuzz(NotNull(),<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke([&amp;amp;intercepted_buzz](Buzz*<sp/>buzz,<sp/>Time<sp/>timestamp)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Save<sp/>buzz<sp/>in<sp/>intercepted_buzz<sp/>for<sp/>analysis<sp/>later.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>intercepted_buzz.reset(buzz);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>mock_buzzer_.ShareBuzz(std::make_unique&lt;Buzz&gt;(AccessLevel::kInternal),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Now());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_NE(nullptr,<sp/>intercepted_buzz);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Using<sp/>the<sp/>tricks<sp/>covered<sp/>in<sp/>this<sp/>recipe,<sp/>you<sp/>are<sp/>now<sp/>able<sp/>to<sp/>mock<sp/>methods<sp/>that<sp/>take<sp/>and/or<sp/>return<sp/>move-only<sp/>types.<sp/><sp/>Put<sp/>your<sp/>newly-acquired<sp/>power<sp/>to<sp/>good<sp/>use<sp/>-<sp/>when<sp/>you<sp/>design<sp/>a<sp/>new<sp/>API,<sp/>you<sp/>can<sp/>now<sp/>feel<sp/>comfortable<sp/>using<sp/>`unique_ptrs`<sp/>as<sp/>appropriate,<sp/>without<sp/>fearing<sp/>that<sp/>doing<sp/>so<sp/>will<sp/>compromise<sp/>your<sp/>tests.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Making<sp/>the<sp/>Compilation<sp/>Faster<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Believe<sp/>it<sp/>or<sp/>not,<sp/>the<sp/>_vast<sp/>majority_<sp/>of<sp/>the<sp/>time<sp/>spent<sp/>on<sp/>compiling</highlight></codeline>
<codeline><highlight class="normal">a<sp/>mock<sp/>class<sp/>is<sp/>in<sp/>generating<sp/>its<sp/>constructor<sp/>and<sp/>destructor,<sp/>as<sp/>they</highlight></codeline>
<codeline><highlight class="normal">perform<sp/>non-trivial<sp/>tasks<sp/>(e.g.<sp/>verification<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal">expectations).<sp/>What&apos;s<sp/>more,<sp/>mock<sp/>methods<sp/>with<sp/>different<sp/>signatures</highlight></codeline>
<codeline><highlight class="normal">have<sp/>different<sp/>types<sp/>and<sp/>thus<sp/>their<sp/>constructors/destructors<sp/>need<sp/>to</highlight></codeline>
<codeline><highlight class="normal">be<sp/>generated<sp/>by<sp/>the<sp/>compiler<sp/>separately.<sp/>As<sp/>a<sp/>result,<sp/>if<sp/>you<sp/>mock<sp/>many</highlight></codeline>
<codeline><highlight class="normal">different<sp/>types<sp/>of<sp/>methods,<sp/>compiling<sp/>your<sp/>mock<sp/>class<sp/>can<sp/>get<sp/>really</highlight></codeline>
<codeline><highlight class="normal">slow.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>are<sp/>experiencing<sp/>slow<sp/>compilation,<sp/>you<sp/>can<sp/>move<sp/>the<sp/>definition</highlight></codeline>
<codeline><highlight class="normal">of<sp/>your<sp/>mock<sp/>class&apos;<sp/>constructor<sp/>and<sp/>destructor<sp/>out<sp/>of<sp/>the<sp/>class<sp/>body</highlight></codeline>
<codeline><highlight class="normal">and<sp/>into<sp/>a<sp/>`.cpp`<sp/>file.<sp/>This<sp/>way,<sp/>even<sp/>if<sp/>you<sp/>`#include`<sp/>your<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">class<sp/>in<sp/>N<sp/>files,<sp/>the<sp/>compiler<sp/>only<sp/>needs<sp/>to<sp/>generate<sp/>its<sp/>constructor</highlight></codeline>
<codeline><highlight class="normal">and<sp/>destructor<sp/>once,<sp/>resulting<sp/>in<sp/>a<sp/>much<sp/>faster<sp/>compilation.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Let&apos;s<sp/>illustrate<sp/>the<sp/>idea<sp/>using<sp/>an<sp/>example.<sp/>Here&apos;s<sp/>the<sp/>definition<sp/>of<sp/>a</highlight></codeline>
<codeline><highlight class="normal">mock<sp/>class<sp/>before<sp/>applying<sp/>this<sp/>recipe:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">//<sp/>File<sp/>mock_foo.h.</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Since<sp/>we<sp/>don&apos;t<sp/>declare<sp/>the<sp/>constructor<sp/>or<sp/>the<sp/>destructor,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>the<sp/>compiler<sp/>will<sp/>generate<sp/>them<sp/>in<sp/>every<sp/>translation<sp/>unit</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>where<sp/>this<sp/>mock<sp/>class<sp/>is<sp/>used.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD0(DoThis,<sp/>int());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(DoThat,<sp/>bool(const<sp/>char*<sp/>str));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>more<sp/>mock<sp/>methods<sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">After<sp/>the<sp/>change,<sp/>it<sp/>would<sp/>look<sp/>like:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">//<sp/>File<sp/>mock_foo.h.</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>constructor<sp/>and<sp/>destructor<sp/>are<sp/>declared,<sp/>but<sp/>not<sp/>defined,<sp/>here.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~MockFoo();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD0(DoThis,<sp/>int());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD1(DoThat,<sp/>bool(const<sp/>char*<sp/>str));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>more<sp/>mock<sp/>methods<sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">and</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">//<sp/>File<sp/>mock_foo.cpp.</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;path/to/mock_foo.h&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>definitions<sp/>may<sp/>appear<sp/>trivial,<sp/>but<sp/>the<sp/>functions<sp/>actually<sp/>do<sp/>a</highlight></codeline>
<codeline><highlight class="normal">//<sp/>lot<sp/>of<sp/>things<sp/>through<sp/>the<sp/>constructors/destructors<sp/>of<sp/>the<sp/>member</highlight></codeline>
<codeline><highlight class="normal">//<sp/>variables<sp/>used<sp/>to<sp/>implement<sp/>the<sp/>mock<sp/>methods.</highlight></codeline>
<codeline><highlight class="normal">MockFoo::MockFoo()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal">MockFoo::~MockFoo()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Forcing<sp/>a<sp/>Verification<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>it&apos;s<sp/>being<sp/>destoyed,<sp/>your<sp/>friendly<sp/>mock<sp/>object<sp/>will<sp/>automatically</highlight></codeline>
<codeline><highlight class="normal">verify<sp/>that<sp/>all<sp/>expectations<sp/>on<sp/>it<sp/>have<sp/>been<sp/>satisfied,<sp/>and<sp/>will</highlight></codeline>
<codeline><highlight class="normal">generate<sp/>[Google<sp/>Test](../../googletest/)<sp/>failures</highlight></codeline>
<codeline><highlight class="normal">if<sp/>not.<sp/>This<sp/>is<sp/>convenient<sp/>as<sp/>it<sp/>leaves<sp/>you<sp/>with<sp/>one<sp/>less<sp/>thing<sp/>to</highlight></codeline>
<codeline><highlight class="normal">worry<sp/>about.<sp/>That<sp/>is,<sp/>unless<sp/>you<sp/>are<sp/>not<sp/>sure<sp/>if<sp/>your<sp/>mock<sp/>object<sp/>will</highlight></codeline>
<codeline><highlight class="normal">be<sp/>destoyed.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">How<sp/>could<sp/>it<sp/>be<sp/>that<sp/>your<sp/>mock<sp/>object<sp/>won&apos;t<sp/>eventually<sp/>be<sp/>destroyed?</highlight></codeline>
<codeline><highlight class="normal">Well,<sp/>it<sp/>might<sp/>be<sp/>created<sp/>on<sp/>the<sp/>heap<sp/>and<sp/>owned<sp/>by<sp/>the<sp/>code<sp/>you<sp/>are</highlight></codeline>
<codeline><highlight class="normal">testing.<sp/>Suppose<sp/>there&apos;s<sp/>a<sp/>bug<sp/>in<sp/>that<sp/>code<sp/>and<sp/>it<sp/>doesn&apos;t<sp/>delete<sp/>the</highlight></codeline>
<codeline><highlight class="normal">mock<sp/>object<sp/>properly<sp/>-<sp/>you<sp/>could<sp/>end<sp/>up<sp/>with<sp/>a<sp/>passing<sp/>test<sp/>when</highlight></codeline>
<codeline><highlight class="normal">there&apos;s<sp/>actually<sp/>a<sp/>bug.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Using<sp/>a<sp/>heap<sp/>checker<sp/>is<sp/>a<sp/>good<sp/>idea<sp/>and<sp/>can<sp/>alleviate<sp/>the<sp/>concern,<sp/>but</highlight></codeline>
<codeline><highlight class="normal">its<sp/>implementation<sp/>may<sp/>not<sp/>be<sp/>100%<sp/>reliable.<sp/>So,<sp/>sometimes<sp/>you<sp/>do<sp/>want</highlight></codeline>
<codeline><highlight class="normal">to<sp/>_force_<sp/>Google<sp/>Mock<sp/>to<sp/>verify<sp/>a<sp/>mock<sp/>object<sp/>before<sp/>it<sp/>is</highlight></codeline>
<codeline><highlight class="normal">(hopefully)<sp/>destructed.<sp/>You<sp/>can<sp/>do<sp/>this<sp/>with</highlight></codeline>
<codeline><highlight class="normal">`Mock::VerifyAndClearExpectations(&amp;mock_object)`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">TEST(MyServerTest,<sp/>ProcessesRequest)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>::testing::Mock;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo*<sp/>const<sp/>foo<sp/>=<sp/>new<sp/>MockFoo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(*foo,<sp/>...)...;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>...<sp/>other<sp/>expectations<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>server<sp/>now<sp/>owns<sp/>foo.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MyServer<sp/>server(foo);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>server.ProcessRequest(...);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>In<sp/>case<sp/>that<sp/>server&apos;s<sp/>destructor<sp/>will<sp/>forget<sp/>to<sp/>delete<sp/>foo,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>this<sp/>will<sp/>verify<sp/>the<sp/>expectations<sp/>anyway.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Mock::VerifyAndClearExpectations(foo);</highlight></codeline>
<codeline><highlight class="normal">}<sp/><sp/>//<sp/>server<sp/>is<sp/>destroyed<sp/>when<sp/>it<sp/>goes<sp/>out<sp/>of<sp/>scope<sp/>here.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**Tip:**<sp/>The<sp/>`Mock::VerifyAndClearExpectations()`<sp/>function<sp/>returns<sp/>a</highlight></codeline>
<codeline><highlight class="normal">`bool`<sp/>to<sp/>indicate<sp/>whether<sp/>the<sp/>verification<sp/>was<sp/>successful<sp/>(`true`<sp/>for</highlight></codeline>
<codeline><highlight class="normal">yes),<sp/>so<sp/>you<sp/>can<sp/>wrap<sp/>that<sp/>function<sp/>call<sp/>inside<sp/>a<sp/>`ASSERT_TRUE()`<sp/>if</highlight></codeline>
<codeline><highlight class="normal">there<sp/>is<sp/>no<sp/>point<sp/>going<sp/>further<sp/>when<sp/>the<sp/>verification<sp/>has<sp/>failed.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Using<sp/>Check<sp/>Points<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>you<sp/>may<sp/>want<sp/>to<sp/>&quot;reset&quot;<sp/>a<sp/>mock<sp/>object<sp/>at<sp/>various<sp/>check</highlight></codeline>
<codeline><highlight class="normal">points<sp/>in<sp/>your<sp/>test:<sp/>at<sp/>each<sp/>check<sp/>point,<sp/>you<sp/>verify<sp/>that<sp/>all<sp/>existing</highlight></codeline>
<codeline><highlight class="normal">expectations<sp/>on<sp/>the<sp/>mock<sp/>object<sp/>have<sp/>been<sp/>satisfied,<sp/>and<sp/>then<sp/>you<sp/>set</highlight></codeline>
<codeline><highlight class="normal">some<sp/>new<sp/>expectations<sp/>on<sp/>it<sp/>as<sp/>if<sp/>it&apos;s<sp/>newly<sp/>created.<sp/>This<sp/>allows<sp/>you</highlight></codeline>
<codeline><highlight class="normal">to<sp/>work<sp/>with<sp/>a<sp/>mock<sp/>object<sp/>in<sp/>&quot;phases&quot;<sp/>whose<sp/>sizes<sp/>are<sp/>each</highlight></codeline>
<codeline><highlight class="normal">manageable.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">One<sp/>such<sp/>scenario<sp/>is<sp/>that<sp/>in<sp/>your<sp/>test&apos;s<sp/>`SetUp()`<sp/>function,<sp/>you<sp/>may</highlight></codeline>
<codeline><highlight class="normal">want<sp/>to<sp/>put<sp/>the<sp/>object<sp/>you<sp/>are<sp/>testing<sp/>into<sp/>a<sp/>certain<sp/>state,<sp/>with<sp/>the</highlight></codeline>
<codeline><highlight class="normal">help<sp/>from<sp/>a<sp/>mock<sp/>object.<sp/>Once<sp/>in<sp/>the<sp/>desired<sp/>state,<sp/>you<sp/>want<sp/>to<sp/>clear</highlight></codeline>
<codeline><highlight class="normal">all<sp/>expectations<sp/>on<sp/>the<sp/>mock,<sp/>such<sp/>that<sp/>in<sp/>the<sp/>`TEST_F`<sp/>body<sp/>you<sp/>can</highlight></codeline>
<codeline><highlight class="normal">set<sp/>fresh<sp/>expectations<sp/>on<sp/>it.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">As<sp/>you<sp/>may<sp/>have<sp/>figured<sp/>out,<sp/>the<sp/>`Mock::VerifyAndClearExpectations()`</highlight></codeline>
<codeline><highlight class="normal">function<sp/>we<sp/>saw<sp/>in<sp/>the<sp/>previous<sp/>recipe<sp/>can<sp/>help<sp/>you<sp/>here.<sp/>Or,<sp/>if<sp/>you</highlight></codeline>
<codeline><highlight class="normal">are<sp/>using<sp/>`ON_CALL()`<sp/>to<sp/>set<sp/>default<sp/>actions<sp/>on<sp/>the<sp/>mock<sp/>object<sp/>and</highlight></codeline>
<codeline><highlight class="normal">want<sp/>to<sp/>clear<sp/>the<sp/>default<sp/>actions<sp/>as<sp/>well,<sp/>use</highlight></codeline>
<codeline><highlight class="normal">`Mock::VerifyAndClear(&amp;mock_object)`<sp/>instead.<sp/>This<sp/>function<sp/>does<sp/>what</highlight></codeline>
<codeline><highlight class="normal">`Mock::VerifyAndClearExpectations(&amp;mock_object)`<sp/>does<sp/>and<sp/>returns<sp/>the</highlight></codeline>
<codeline><highlight class="normal">same<sp/>`bool`,<sp/>**plus**<sp/>it<sp/>clears<sp/>the<sp/>`ON_CALL()`<sp/>statements<sp/>on</highlight></codeline>
<codeline><highlight class="normal">`mock_object`<sp/>too.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Another<sp/>trick<sp/>you<sp/>can<sp/>use<sp/>to<sp/>achieve<sp/>the<sp/>same<sp/>effect<sp/>is<sp/>to<sp/>put<sp/>the</highlight></codeline>
<codeline><highlight class="normal">expectations<sp/>in<sp/>sequences<sp/>and<sp/>insert<sp/>calls<sp/>to<sp/>a<sp/>dummy<sp/>&quot;check-point&quot;</highlight></codeline>
<codeline><highlight class="normal">function<sp/>at<sp/>specific<sp/>places.<sp/>Then<sp/>you<sp/>can<sp/>verify<sp/>that<sp/>the<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">function<sp/>calls<sp/>do<sp/>happen<sp/>at<sp/>the<sp/>right<sp/>time.<sp/>For<sp/>example,<sp/>if<sp/>you<sp/>are</highlight></codeline>
<codeline><highlight class="normal">exercising<sp/>code:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">Foo(1);</highlight></codeline>
<codeline><highlight class="normal">Foo(2);</highlight></codeline>
<codeline><highlight class="normal">Foo(3);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">and<sp/>want<sp/>to<sp/>verify<sp/>that<sp/>`Foo(1)`<sp/>and<sp/>`Foo(3)`<sp/>both<sp/>invoke</highlight></codeline>
<codeline><highlight class="normal">`mock.Bar(&quot;a&quot;)`,<sp/>but<sp/>`Foo(2)`<sp/>doesn&apos;t<sp/>invoke<sp/>anything.<sp/>You<sp/>can<sp/>write:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MockFunction;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TEST(FooTest,<sp/>InvokesBarCorrectly)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MyMock<sp/>mock;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Class<sp/>MockFunction&lt;F&gt;<sp/>has<sp/>exactly<sp/>one<sp/>mock<sp/>method.<sp/><sp/>It<sp/>is<sp/>named</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Call()<sp/>and<sp/>has<sp/>type<sp/>F.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFunction&lt;void(string<sp/>check_point_name)&gt;<sp/>check;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>InSequence<sp/>s;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(mock,<sp/>Bar(&quot;a&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(check,<sp/>Call(&quot;1&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(check,<sp/>Call(&quot;2&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(mock,<sp/>Bar(&quot;a&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Foo(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>check.Call(&quot;1&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Foo(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>check.Call(&quot;2&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Foo(3);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>expectation<sp/>spec<sp/>says<sp/>that<sp/>the<sp/>first<sp/>`Bar(&quot;a&quot;)`<sp/>must<sp/>happen<sp/>before</highlight></codeline>
<codeline><highlight class="normal">check<sp/>point<sp/>&quot;1&quot;,<sp/>the<sp/>second<sp/>`Bar(&quot;a&quot;)`<sp/>must<sp/>happen<sp/>after<sp/>check<sp/>point<sp/>&quot;2&quot;,</highlight></codeline>
<codeline><highlight class="normal">and<sp/>nothing<sp/>should<sp/>happen<sp/>between<sp/>the<sp/>two<sp/>check<sp/>points.<sp/>The<sp/>explicit</highlight></codeline>
<codeline><highlight class="normal">check<sp/>points<sp/>make<sp/>it<sp/>easy<sp/>to<sp/>tell<sp/>which<sp/>`Bar(&quot;a&quot;)`<sp/>is<sp/>called<sp/>by<sp/>which</highlight></codeline>
<codeline><highlight class="normal">call<sp/>to<sp/>`Foo()`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Mocking<sp/>Destructors<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>you<sp/>want<sp/>to<sp/>make<sp/>sure<sp/>a<sp/>mock<sp/>object<sp/>is<sp/>destructed<sp/>at<sp/>the</highlight></codeline>
<codeline><highlight class="normal">right<sp/>time,<sp/>e.g.<sp/>after<sp/>`bar-&gt;A()`<sp/>is<sp/>called<sp/>but<sp/>before<sp/>`bar-&gt;B()`<sp/>is</highlight></codeline>
<codeline><highlight class="normal">called.<sp/>We<sp/>already<sp/>know<sp/>that<sp/>you<sp/>can<sp/>specify<sp/>constraints<sp/>on<sp/>the<sp/>order</highlight></codeline>
<codeline><highlight class="normal">of<sp/>mock<sp/>function<sp/>calls,<sp/>so<sp/>all<sp/>we<sp/>need<sp/>to<sp/>do<sp/>is<sp/>to<sp/>mock<sp/>the<sp/>destructor</highlight></codeline>
<codeline><highlight class="normal">of<sp/>the<sp/>mock<sp/>function.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>sounds<sp/>simple,<sp/>except<sp/>for<sp/>one<sp/>problem:<sp/>a<sp/>destructor<sp/>is<sp/>a<sp/>special</highlight></codeline>
<codeline><highlight class="normal">function<sp/>with<sp/>special<sp/>syntax<sp/>and<sp/>special<sp/>semantics,<sp/>and<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`MOCK_METHOD0`<sp/>macro<sp/>doesn&apos;t<sp/>work<sp/>for<sp/>it:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD0(~MockFoo,<sp/>void());<sp/><sp/>//<sp/>Won&apos;t<sp/>compile!</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>good<sp/>news<sp/>is<sp/>that<sp/>you<sp/>can<sp/>use<sp/>a<sp/>simple<sp/>pattern<sp/>to<sp/>achieve<sp/>the<sp/>same</highlight></codeline>
<codeline><highlight class="normal">effect.<sp/>First,<sp/>add<sp/>a<sp/>mock<sp/>function<sp/>`Die()`<sp/>to<sp/>your<sp/>mock<sp/>class<sp/>and<sp/>call</highlight></codeline>
<codeline><highlight class="normal">it<sp/>in<sp/>the<sp/>destructor,<sp/>like<sp/>this:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Add<sp/>the<sp/>following<sp/>two<sp/>lines<sp/>to<sp/>the<sp/>mock<sp/>class.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD0(Die,<sp/>void());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~MockFoo()<sp/>{<sp/>Die();<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">(If<sp/>the<sp/>name<sp/>`Die()`<sp/>clashes<sp/>with<sp/>an<sp/>existing<sp/>symbol,<sp/>choose<sp/>another</highlight></codeline>
<codeline><highlight class="normal">name.)<sp/>Now,<sp/>we<sp/>have<sp/>translated<sp/>the<sp/>problem<sp/>of<sp/>testing<sp/>when<sp/>a<sp/>`MockFoo`</highlight></codeline>
<codeline><highlight class="normal">object<sp/>dies<sp/>to<sp/>testing<sp/>when<sp/>its<sp/>`Die()`<sp/>method<sp/>is<sp/>called:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo*<sp/>foo<sp/>=<sp/>new<sp/>MockFoo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockBar*<sp/>bar<sp/>=<sp/>new<sp/>MockBar;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>InSequence<sp/>s;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Expects<sp/>*foo<sp/>to<sp/>die<sp/>after<sp/>bar-&gt;A()<sp/>and<sp/>before<sp/>bar-&gt;B().</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(*bar,<sp/>A());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(*foo,<sp/>Die());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(*bar,<sp/>B());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">And<sp/>that&apos;s<sp/>that.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Using<sp/>Google<sp/>Mock<sp/>and<sp/>Threads<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**IMPORTANT<sp/>NOTE:**<sp/>What<sp/>we<sp/>describe<sp/>in<sp/>this<sp/>recipe<sp/>is<sp/>**ONLY**<sp/>true<sp/>on</highlight></codeline>
<codeline><highlight class="normal">platforms<sp/>where<sp/>Google<sp/>Mock<sp/>is<sp/>thread-safe.<sp/>Currently<sp/>these<sp/>are<sp/>only</highlight></codeline>
<codeline><highlight class="normal">platforms<sp/>that<sp/>support<sp/>the<sp/>pthreads<sp/>library<sp/>(this<sp/>includes<sp/>Linux<sp/>and<sp/>Mac).</highlight></codeline>
<codeline><highlight class="normal">To<sp/>make<sp/>it<sp/>thread-safe<sp/>on<sp/>other<sp/>platforms<sp/>we<sp/>only<sp/>need<sp/>to<sp/>implement</highlight></codeline>
<codeline><highlight class="normal">some<sp/>synchronization<sp/>operations<sp/>in<sp/>`&quot;gtest/internal/gtest-port.h&quot;`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">In<sp/>a<sp/>**unit**<sp/>test,<sp/>it&apos;s<sp/>best<sp/>if<sp/>you<sp/>could<sp/>isolate<sp/>and<sp/>test<sp/>a<sp/>piece<sp/>of</highlight></codeline>
<codeline><highlight class="normal">code<sp/>in<sp/>a<sp/>single-threaded<sp/>context.<sp/>That<sp/>avoids<sp/>race<sp/>conditions<sp/>and</highlight></codeline>
<codeline><highlight class="normal">dead<sp/>locks,<sp/>and<sp/>makes<sp/>debugging<sp/>your<sp/>test<sp/>much<sp/>easier.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Yet<sp/>many<sp/>programs<sp/>are<sp/>multi-threaded,<sp/>and<sp/>sometimes<sp/>to<sp/>test<sp/>something</highlight></codeline>
<codeline><highlight class="normal">we<sp/>need<sp/>to<sp/>pound<sp/>on<sp/>it<sp/>from<sp/>more<sp/>than<sp/>one<sp/>thread.<sp/>Google<sp/>Mock<sp/>works</highlight></codeline>
<codeline><highlight class="normal">for<sp/>this<sp/>purpose<sp/>too.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Remember<sp/>the<sp/>steps<sp/>for<sp/>using<sp/>a<sp/>mock:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>1.<sp/>Create<sp/>a<sp/>mock<sp/>object<sp/>`foo`.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>1.<sp/>Set<sp/>its<sp/>default<sp/>actions<sp/>and<sp/>expectations<sp/>using<sp/>`ON_CALL()`<sp/>and<sp/>`EXPECT_CALL()`.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>1.<sp/>The<sp/>code<sp/>under<sp/>test<sp/>calls<sp/>methods<sp/>of<sp/>`foo`.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>1.<sp/>Optionally,<sp/>verify<sp/>and<sp/>reset<sp/>the<sp/>mock.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>1.<sp/>Destroy<sp/>the<sp/>mock<sp/>yourself,<sp/>or<sp/>let<sp/>the<sp/>code<sp/>under<sp/>test<sp/>destroy<sp/>it.<sp/>The<sp/>destructor<sp/>will<sp/>automatically<sp/>verify<sp/>it.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>follow<sp/>the<sp/>following<sp/>simple<sp/>rules,<sp/>your<sp/>mocks<sp/>and<sp/>threads<sp/>can</highlight></codeline>
<codeline><highlight class="normal">live<sp/>happily<sp/>together:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>Execute<sp/>your<sp/>_test<sp/>code_<sp/>(as<sp/>opposed<sp/>to<sp/>the<sp/>code<sp/>being<sp/>tested)<sp/>in<sp/>_one_<sp/>thread.<sp/>This<sp/>makes<sp/>your<sp/>test<sp/>easy<sp/>to<sp/>follow.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>Obviously,<sp/>you<sp/>can<sp/>do<sp/>step<sp/>#1<sp/>without<sp/>locking.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>When<sp/>doing<sp/>step<sp/>#2<sp/>and<sp/>#5,<sp/>make<sp/>sure<sp/>no<sp/>other<sp/>thread<sp/>is<sp/>accessing<sp/>`foo`.<sp/>Obvious<sp/>too,<sp/>huh?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>#3<sp/>and<sp/>#4<sp/>can<sp/>be<sp/>done<sp/>either<sp/>in<sp/>one<sp/>thread<sp/>or<sp/>in<sp/>multiple<sp/>threads<sp/>-<sp/>anyway<sp/>you<sp/>want.<sp/>Google<sp/>Mock<sp/>takes<sp/>care<sp/>of<sp/>the<sp/>locking,<sp/>so<sp/>you<sp/>don&apos;t<sp/>have<sp/>to<sp/>do<sp/>any<sp/>-<sp/>unless<sp/>required<sp/>by<sp/>your<sp/>test<sp/>logic.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>violate<sp/>the<sp/>rules<sp/>(for<sp/>example,<sp/>if<sp/>you<sp/>set<sp/>expectations<sp/>on<sp/>a</highlight></codeline>
<codeline><highlight class="normal">mock<sp/>while<sp/>another<sp/>thread<sp/>is<sp/>calling<sp/>its<sp/>methods),<sp/>you<sp/>get<sp/>undefined</highlight></codeline>
<codeline><highlight class="normal">behavior.<sp/>That&apos;s<sp/>not<sp/>fun,<sp/>so<sp/>don&apos;t<sp/>do<sp/>it.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Google<sp/>Mock<sp/>guarantees<sp/>that<sp/>the<sp/>action<sp/>for<sp/>a<sp/>mock<sp/>function<sp/>is<sp/>done<sp/>in</highlight></codeline>
<codeline><highlight class="normal">the<sp/>same<sp/>thread<sp/>that<sp/>called<sp/>the<sp/>mock<sp/>function.<sp/>For<sp/>example,<sp/>in</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(1))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(action1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(2))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(action2);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">if<sp/>`Foo(1)`<sp/>is<sp/>called<sp/>in<sp/>thread<sp/>1<sp/>and<sp/>`Foo(2)`<sp/>is<sp/>called<sp/>in<sp/>thread<sp/>2,</highlight></codeline>
<codeline><highlight class="normal">Google<sp/>Mock<sp/>will<sp/>execute<sp/>`action1`<sp/>in<sp/>thread<sp/>1<sp/>and<sp/>`action2`<sp/>in<sp/>thread</highlight></codeline>
<codeline><highlight class="normal">2.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Google<sp/>Mock<sp/>does<sp/>_not_<sp/>impose<sp/>a<sp/>sequence<sp/>on<sp/>actions<sp/>performed<sp/>in</highlight></codeline>
<codeline><highlight class="normal">different<sp/>threads<sp/>(doing<sp/>so<sp/>may<sp/>create<sp/>deadlocks<sp/>as<sp/>the<sp/>actions<sp/>may</highlight></codeline>
<codeline><highlight class="normal">need<sp/>to<sp/>cooperate).<sp/>This<sp/>means<sp/>that<sp/>the<sp/>execution<sp/>of<sp/>`action1`<sp/>and</highlight></codeline>
<codeline><highlight class="normal">`action2`<sp/>in<sp/>the<sp/>above<sp/>example<sp/>_may_<sp/>interleave.<sp/>If<sp/>this<sp/>is<sp/>a<sp/>problem,</highlight></codeline>
<codeline><highlight class="normal">you<sp/>should<sp/>add<sp/>proper<sp/>synchronization<sp/>logic<sp/>to<sp/>`action1`<sp/>and<sp/>`action2`</highlight></codeline>
<codeline><highlight class="normal">to<sp/>make<sp/>the<sp/>test<sp/>thread-safe.</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Also,<sp/>remember<sp/>that<sp/>`DefaultValue&lt;T&gt;`<sp/>is<sp/>a<sp/>global<sp/>resource<sp/>that</highlight></codeline>
<codeline><highlight class="normal">potentially<sp/>affects<sp/>_all_<sp/>living<sp/>mock<sp/>objects<sp/>in<sp/>your</highlight></codeline>
<codeline><highlight class="normal">program.<sp/>Naturally,<sp/>you<sp/>won&apos;t<sp/>want<sp/>to<sp/>mess<sp/>with<sp/>it<sp/>from<sp/>multiple</highlight></codeline>
<codeline><highlight class="normal">threads<sp/>or<sp/>when<sp/>there<sp/>still<sp/>are<sp/>mocks<sp/>in<sp/>action.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Controlling<sp/>How<sp/>Much<sp/>Information<sp/>Google<sp/>Mock<sp/>Prints<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>Google<sp/>Mock<sp/>sees<sp/>something<sp/>that<sp/>has<sp/>the<sp/>potential<sp/>of<sp/>being<sp/>an</highlight></codeline>
<codeline><highlight class="normal">error<sp/>(e.g.<sp/>a<sp/>mock<sp/>function<sp/>with<sp/>no<sp/>expectation<sp/>is<sp/>called,<sp/>a.k.a.<sp/>an</highlight></codeline>
<codeline><highlight class="normal">uninteresting<sp/>call,<sp/>which<sp/>is<sp/>allowed<sp/>but<sp/>perhaps<sp/>you<sp/>forgot<sp/>to</highlight></codeline>
<codeline><highlight class="normal">explicitly<sp/>ban<sp/>the<sp/>call),<sp/>it<sp/>prints<sp/>some<sp/>warning<sp/>messages,<sp/>including</highlight></codeline>
<codeline><highlight class="normal">the<sp/>arguments<sp/>of<sp/>the<sp/>function<sp/>and<sp/>the<sp/>return<sp/>value.<sp/>Hopefully<sp/>this</highlight></codeline>
<codeline><highlight class="normal">will<sp/>remind<sp/>you<sp/>to<sp/>take<sp/>a<sp/>look<sp/>and<sp/>see<sp/>if<sp/>there<sp/>is<sp/>indeed<sp/>a<sp/>problem.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>you<sp/>are<sp/>confident<sp/>that<sp/>your<sp/>tests<sp/>are<sp/>correct<sp/>and<sp/>may<sp/>not</highlight></codeline>
<codeline><highlight class="normal">appreciate<sp/>such<sp/>friendly<sp/>messages.<sp/>Some<sp/>other<sp/>times,<sp/>you<sp/>are<sp/>debugging</highlight></codeline>
<codeline><highlight class="normal">your<sp/>tests<sp/>or<sp/>learning<sp/>about<sp/>the<sp/>behavior<sp/>of<sp/>the<sp/>code<sp/>you<sp/>are<sp/>testing,</highlight></codeline>
<codeline><highlight class="normal">and<sp/>wish<sp/>you<sp/>could<sp/>observe<sp/>every<sp/>mock<sp/>call<sp/>that<sp/>happens<sp/>(including</highlight></codeline>
<codeline><highlight class="normal">argument<sp/>values<sp/>and<sp/>the<sp/>return<sp/>value).<sp/>Clearly,<sp/>one<sp/>size<sp/>doesn&apos;t<sp/>fit</highlight></codeline>
<codeline><highlight class="normal">all.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>control<sp/>how<sp/>much<sp/>Google<sp/>Mock<sp/>tells<sp/>you<sp/>using<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`--gmock_verbose=LEVEL`<sp/>command-line<sp/>flag,<sp/>where<sp/>`LEVEL`<sp/>is<sp/>a<sp/>string</highlight></codeline>
<codeline><highlight class="normal">with<sp/>three<sp/>possible<sp/>values:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>`info`:<sp/>Google<sp/>Mock<sp/>will<sp/>print<sp/>all<sp/>informational<sp/>messages,<sp/>warnings,<sp/>and<sp/>errors<sp/>(most<sp/>verbose).<sp/>At<sp/>this<sp/>setting,<sp/>Google<sp/>Mock<sp/>will<sp/>also<sp/>log<sp/>any<sp/>calls<sp/>to<sp/>the<sp/>`ON_CALL/EXPECT_CALL`<sp/>macros.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>`warning`:<sp/>Google<sp/>Mock<sp/>will<sp/>print<sp/>both<sp/>warnings<sp/>and<sp/>errors<sp/>(less<sp/>verbose).<sp/>This<sp/>is<sp/>the<sp/>default.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*<sp/>`error`:<sp/>Google<sp/>Mock<sp/>will<sp/>print<sp/>errors<sp/>only<sp/>(least<sp/>verbose).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Alternatively,<sp/>you<sp/>can<sp/>adjust<sp/>the<sp/>value<sp/>of<sp/>that<sp/>flag<sp/>from<sp/>within<sp/>your</highlight></codeline>
<codeline><highlight class="normal">tests<sp/>like<sp/>so:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>::testing::FLAGS_gmock_verbose<sp/>=<sp/>&quot;error&quot;;</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Now,<sp/>judiciously<sp/>use<sp/>the<sp/>right<sp/>flag<sp/>to<sp/>enable<sp/>Google<sp/>Mock<sp/>serve<sp/>you<sp/>better!</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Gaining<sp/>Super<sp/>Vision<sp/>into<sp/>Mock<sp/>Calls<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>have<sp/>a<sp/>test<sp/>using<sp/>Google<sp/>Mock.<sp/>It<sp/>fails:<sp/>Google<sp/>Mock<sp/>tells<sp/>you</highlight></codeline>
<codeline><highlight class="normal">that<sp/>some<sp/>expectations<sp/>aren&apos;t<sp/>satisfied.<sp/>However,<sp/>you<sp/>aren&apos;t<sp/>sure<sp/>why:</highlight></codeline>
<codeline><highlight class="normal">Is<sp/>there<sp/>a<sp/>typo<sp/>somewhere<sp/>in<sp/>the<sp/>matchers?<sp/>Did<sp/>you<sp/>mess<sp/>up<sp/>the<sp/>order</highlight></codeline>
<codeline><highlight class="normal">of<sp/>the<sp/>`EXPECT_CALL`s?<sp/>Or<sp/>is<sp/>the<sp/>code<sp/>under<sp/>test<sp/>doing<sp/>something</highlight></codeline>
<codeline><highlight class="normal">wrong?<sp/><sp/>How<sp/>can<sp/>you<sp/>find<sp/>out<sp/>the<sp/>cause?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Won&apos;t<sp/>it<sp/>be<sp/>nice<sp/>if<sp/>you<sp/>have<sp/>X-ray<sp/>vision<sp/>and<sp/>can<sp/>actually<sp/>see<sp/>the</highlight></codeline>
<codeline><highlight class="normal">trace<sp/>of<sp/>all<sp/>`EXPECT_CALL`s<sp/>and<sp/>mock<sp/>method<sp/>calls<sp/>as<sp/>they<sp/>are<sp/>made?</highlight></codeline>
<codeline><highlight class="normal">For<sp/>each<sp/>call,<sp/>would<sp/>you<sp/>like<sp/>to<sp/>see<sp/>its<sp/>actual<sp/>argument<sp/>values<sp/>and</highlight></codeline>
<codeline><highlight class="normal">which<sp/>`EXPECT_CALL`<sp/>Google<sp/>Mock<sp/>thinks<sp/>it<sp/>matches?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>unlock<sp/>this<sp/>power<sp/>by<sp/>running<sp/>your<sp/>test<sp/>with<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`--gmock_verbose=info`<sp/>flag.<sp/>For<sp/>example,<sp/>given<sp/>the<sp/>test<sp/>program:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>testing::HasSubstr;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>testing::Return;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD2(F,<sp/>void(const<sp/>string&amp;<sp/>x,<sp/>const<sp/>string&amp;<sp/>y));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TEST(Foo,<sp/>Bar)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>mock;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>F(_,<sp/>_)).WillRepeatedly(Return());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>F(&quot;a&quot;,<sp/>&quot;b&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>F(&quot;c&quot;,<sp/>HasSubstr(&quot;d&quot;)));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>mock.F(&quot;a&quot;,<sp/>&quot;good&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mock.F(&quot;a&quot;,<sp/>&quot;b&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">if<sp/>you<sp/>run<sp/>it<sp/>with<sp/>`--gmock_verbose=info`,<sp/>you<sp/>will<sp/>see<sp/>this<sp/>output:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">[<sp/>RUN<sp/><sp/><sp/><sp/><sp/><sp/>]<sp/>Foo.Bar</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">foo_test.cc:14:<sp/>EXPECT_CALL(mock,<sp/>F(_,<sp/>_))<sp/>invoked</highlight></codeline>
<codeline><highlight class="normal">foo_test.cc:15:<sp/>EXPECT_CALL(mock,<sp/>F(&quot;a&quot;,<sp/>&quot;b&quot;))<sp/>invoked</highlight></codeline>
<codeline><highlight class="normal">foo_test.cc:16:<sp/>EXPECT_CALL(mock,<sp/>F(&quot;c&quot;,<sp/>HasSubstr(&quot;d&quot;)))<sp/>invoked</highlight></codeline>
<codeline><highlight class="normal">foo_test.cc:14:<sp/>Mock<sp/>function<sp/>call<sp/>matches<sp/>EXPECT_CALL(mock,<sp/>F(_,<sp/>_))...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Function<sp/>call:<sp/>F(@0x7fff7c8dad40&quot;a&quot;,<sp/>@0x7fff7c8dad10&quot;good&quot;)</highlight></codeline>
<codeline><highlight class="normal">foo_test.cc:15:<sp/>Mock<sp/>function<sp/>call<sp/>matches<sp/>EXPECT_CALL(mock,<sp/>F(&quot;a&quot;,<sp/>&quot;b&quot;))...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Function<sp/>call:<sp/>F(@0x7fff7c8dada0&quot;a&quot;,<sp/>@0x7fff7c8dad70&quot;b&quot;)</highlight></codeline>
<codeline><highlight class="normal">foo_test.cc:16:<sp/>Failure</highlight></codeline>
<codeline><highlight class="normal">Actual<sp/>function<sp/>call<sp/>count<sp/>doesn&apos;t<sp/>match<sp/>EXPECT_CALL(mock,<sp/>F(&quot;c&quot;,<sp/>HasSubstr(&quot;d&quot;)))...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Expected:<sp/>to<sp/>be<sp/>called<sp/>once</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Actual:<sp/>never<sp/>called<sp/>-<sp/>unsatisfied<sp/>and<sp/>active</highlight></codeline>
<codeline><highlight class="normal">[<sp/><sp/>FAILED<sp/><sp/>]<sp/>Foo.Bar</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Suppose<sp/>the<sp/>bug<sp/>is<sp/>that<sp/>the<sp/>`&quot;c&quot;`<sp/>in<sp/>the<sp/>third<sp/>`EXPECT_CALL`<sp/>is<sp/>a<sp/>typo</highlight></codeline>
<codeline><highlight class="normal">and<sp/>should<sp/>actually<sp/>be<sp/>`&quot;a&quot;`.<sp/>With<sp/>the<sp/>above<sp/>message,<sp/>you<sp/>should<sp/>see</highlight></codeline>
<codeline><highlight class="normal">that<sp/>the<sp/>actual<sp/>`F(&quot;a&quot;,<sp/>&quot;good&quot;)`<sp/>call<sp/>is<sp/>matched<sp/>by<sp/>the<sp/>first</highlight></codeline>
<codeline><highlight class="normal">`EXPECT_CALL`,<sp/>not<sp/>the<sp/>third<sp/>as<sp/>you<sp/>thought.<sp/>From<sp/>that<sp/>it<sp/>should<sp/>be</highlight></codeline>
<codeline><highlight class="normal">obvious<sp/>that<sp/>the<sp/>third<sp/>`EXPECT_CALL`<sp/>is<sp/>written<sp/>wrong.<sp/>Case<sp/>solved.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Running<sp/>Tests<sp/>in<sp/>Emacs<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>build<sp/>and<sp/>run<sp/>your<sp/>tests<sp/>in<sp/>Emacs,<sp/>the<sp/>source<sp/>file<sp/>locations<sp/>of</highlight></codeline>
<codeline><highlight class="normal">Google<sp/>Mock<sp/>and<sp/>[Google<sp/>Test](../../googletest/)</highlight></codeline>
<codeline><highlight class="normal">errors<sp/>will<sp/>be<sp/>highlighted.<sp/>Just<sp/>press<sp/>`&lt;Enter&gt;`<sp/>on<sp/>one<sp/>of<sp/>them<sp/>and</highlight></codeline>
<codeline><highlight class="normal">you&apos;ll<sp/>be<sp/>taken<sp/>to<sp/>the<sp/>offending<sp/>line.<sp/>Or,<sp/>you<sp/>can<sp/>just<sp/>type<sp/>`C-x<sp/>``</highlight></codeline>
<codeline><highlight class="normal">to<sp/>jump<sp/>to<sp/>the<sp/>next<sp/>error.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">To<sp/>make<sp/>it<sp/>even<sp/>easier,<sp/>you<sp/>can<sp/>add<sp/>the<sp/>following<sp/>lines<sp/>to<sp/>your</highlight></codeline>
<codeline><highlight class="normal">`~/.emacs`<sp/>file:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">(global-set-key<sp/>&quot;\M-m&quot;<sp/><sp/><sp/>&apos;compile)<sp/><sp/>;<sp/>m<sp/>is<sp/>for<sp/>make</highlight></codeline>
<codeline><highlight class="normal">(global-set-key<sp/>[M-down]<sp/>&apos;next-error)</highlight></codeline>
<codeline><highlight class="normal">(global-set-key<sp/>[M-up]<sp/><sp/><sp/>&apos;(lambda<sp/>()<sp/>(interactive)<sp/>(next-error<sp/>-1)))</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Then<sp/>you<sp/>can<sp/>type<sp/>`M-m`<sp/>to<sp/>start<sp/>a<sp/>build,<sp/>or<sp/>`M-up`/`M-down`<sp/>to<sp/>move</highlight></codeline>
<codeline><highlight class="normal">back<sp/>and<sp/>forth<sp/>between<sp/>errors.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Fusing<sp/>Google<sp/>Mock<sp/>Source<sp/>Files<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Google<sp/>Mock&apos;s<sp/>implementation<sp/>consists<sp/>of<sp/>dozens<sp/>of<sp/>files<sp/>(excluding</highlight></codeline>
<codeline><highlight class="normal">its<sp/>own<sp/>tests).<sp/><sp/>Sometimes<sp/>you<sp/>may<sp/>want<sp/>them<sp/>to<sp/>be<sp/>packaged<sp/>up<sp/>in</highlight></codeline>
<codeline><highlight class="normal">fewer<sp/>files<sp/>instead,<sp/>such<sp/>that<sp/>you<sp/>can<sp/>easily<sp/>copy<sp/>them<sp/>to<sp/>a<sp/>new</highlight></codeline>
<codeline><highlight class="normal">machine<sp/>and<sp/>start<sp/>hacking<sp/>there.<sp/><sp/>For<sp/>this<sp/>we<sp/>provide<sp/>an<sp/>experimental</highlight></codeline>
<codeline><highlight class="normal">Python<sp/>script<sp/>`fuse_gmock_files.py`<sp/>in<sp/>the<sp/>`scripts/`<sp/>directory</highlight></codeline>
<codeline><highlight class="normal">(starting<sp/>with<sp/>release<sp/>1.2.0).<sp/><sp/>Assuming<sp/>you<sp/>have<sp/>Python<sp/>2.4<sp/>or<sp/>above</highlight></codeline>
<codeline><highlight class="normal">installed<sp/>on<sp/>your<sp/>machine,<sp/>just<sp/>go<sp/>to<sp/>that<sp/>directory<sp/>and<sp/>run</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">python<sp/>fuse_gmock_files.py<sp/>OUTPUT_DIR</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">and<sp/>you<sp/>should<sp/>see<sp/>an<sp/>`OUTPUT_DIR`<sp/>directory<sp/>being<sp/>created<sp/>with<sp/>files</highlight></codeline>
<codeline><highlight class="normal">`gtest/gtest.h`,<sp/>`gmock/gmock.h`,<sp/>and<sp/>`gmock-gtest-all.cc`<sp/>in<sp/>it.</highlight></codeline>
<codeline><highlight class="normal">These<sp/>three<sp/>files<sp/>contain<sp/>everything<sp/>you<sp/>need<sp/>to<sp/>use<sp/>Google<sp/>Mock<sp/>(and</highlight></codeline>
<codeline><highlight class="normal">Google<sp/>Test).<sp/><sp/>Just<sp/>copy<sp/>them<sp/>to<sp/>anywhere<sp/>you<sp/>want<sp/>and<sp/>you<sp/>are<sp/>ready</highlight></codeline>
<codeline><highlight class="normal">to<sp/>write<sp/>tests<sp/>and<sp/>use<sp/>mocks.<sp/><sp/>You<sp/>can<sp/>use<sp/>the</highlight></codeline>
<codeline><highlight class="normal">[scrpts/test/Makefile](../scripts/test/Makefile)<sp/>file<sp/>as<sp/>an<sp/>example<sp/>on<sp/>how<sp/>to<sp/>compile<sp/>your<sp/>tests</highlight></codeline>
<codeline><highlight class="normal">against<sp/>them.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#<sp/>Extending<sp/>Google<sp/>Mock<sp/>#</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Writing<sp/>New<sp/>Matchers<sp/>Quickly<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>`MATCHER*`<sp/>family<sp/>of<sp/>macros<sp/>can<sp/>be<sp/>used<sp/>to<sp/>define<sp/>custom<sp/>matchers</highlight></codeline>
<codeline><highlight class="normal">easily.<sp/><sp/>The<sp/>syntax:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">MATCHER(name,<sp/>description_string_expression)<sp/>{<sp/>statements;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">will<sp/>define<sp/>a<sp/>matcher<sp/>with<sp/>the<sp/>given<sp/>name<sp/>that<sp/>executes<sp/>the</highlight></codeline>
<codeline><highlight class="normal">statements,<sp/>which<sp/>must<sp/>return<sp/>a<sp/>`bool`<sp/>to<sp/>indicate<sp/>if<sp/>the<sp/>match</highlight></codeline>
<codeline><highlight class="normal">succeeds.<sp/><sp/>Inside<sp/>the<sp/>statements,<sp/>you<sp/>can<sp/>refer<sp/>to<sp/>the<sp/>value<sp/>being</highlight></codeline>
<codeline><highlight class="normal">matched<sp/>by<sp/>`arg`,<sp/>and<sp/>refer<sp/>to<sp/>its<sp/>type<sp/>by<sp/>`arg_type`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>description<sp/>string<sp/>is<sp/>a<sp/>`string`-typed<sp/>expression<sp/>that<sp/>documents</highlight></codeline>
<codeline><highlight class="normal">what<sp/>the<sp/>matcher<sp/>does,<sp/>and<sp/>is<sp/>used<sp/>to<sp/>generate<sp/>the<sp/>failure<sp/>message</highlight></codeline>
<codeline><highlight class="normal">when<sp/>the<sp/>match<sp/>fails.<sp/><sp/>It<sp/>can<sp/>(and<sp/>should)<sp/>reference<sp/>the<sp/>special</highlight></codeline>
<codeline><highlight class="normal">`bool`<sp/>variable<sp/>`negation`,<sp/>and<sp/>should<sp/>evaluate<sp/>to<sp/>the<sp/>description<sp/>of</highlight></codeline>
<codeline><highlight class="normal">the<sp/>matcher<sp/>when<sp/>`negation`<sp/>is<sp/>`false`,<sp/>or<sp/>that<sp/>of<sp/>the<sp/>matcher&apos;s</highlight></codeline>
<codeline><highlight class="normal">negation<sp/>when<sp/>`negation`<sp/>is<sp/>`true`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>convenience,<sp/>we<sp/>allow<sp/>the<sp/>description<sp/>string<sp/>to<sp/>be<sp/>empty<sp/>(`&quot;&quot;`),</highlight></codeline>
<codeline><highlight class="normal">in<sp/>which<sp/>case<sp/>Google<sp/>Mock<sp/>will<sp/>use<sp/>the<sp/>sequence<sp/>of<sp/>words<sp/>in<sp/>the</highlight></codeline>
<codeline><highlight class="normal">matcher<sp/>name<sp/>as<sp/>the<sp/>description.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>example:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">MATCHER(IsDivisibleBy7,<sp/>&quot;&quot;)<sp/>{<sp/>return<sp/>(arg<sp/>%<sp/>7)<sp/>==<sp/>0;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">allows<sp/>you<sp/>to<sp/>write</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Expects<sp/>mock_foo.Bar(n)<sp/>to<sp/>be<sp/>called<sp/>where<sp/>n<sp/>is<sp/>divisible<sp/>by<sp/>7.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_foo,<sp/>Bar(IsDivisibleBy7()));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">or,</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Not;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(some_expression,<sp/>IsDivisibleBy7());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(some_other_expression,<sp/>Not(IsDivisibleBy7()));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">If<sp/>the<sp/>above<sp/>assertions<sp/>fail,<sp/>they<sp/>will<sp/>print<sp/>something<sp/>like:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Value<sp/>of:<sp/>some_expression</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Expected:<sp/>is<sp/>divisible<sp/>by<sp/>7</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Actual:<sp/>27</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Value<sp/>of:<sp/>some_other_expression</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Expected:<sp/>not<sp/>(is<sp/>divisible<sp/>by<sp/>7)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Actual:<sp/>21</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">where<sp/>the<sp/>descriptions<sp/>`&quot;is<sp/>divisible<sp/>by<sp/>7&quot;`<sp/>and<sp/>`&quot;not<sp/>(is<sp/>divisible</highlight></codeline>
<codeline><highlight class="normal">by<sp/>7)&quot;`<sp/>are<sp/>automatically<sp/>calculated<sp/>from<sp/>the<sp/>matcher<sp/>name</highlight></codeline>
<codeline><highlight class="normal">`IsDivisibleBy7`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">As<sp/>you<sp/>may<sp/>have<sp/>noticed,<sp/>the<sp/>auto-generated<sp/>descriptions<sp/>(especially</highlight></codeline>
<codeline><highlight class="normal">those<sp/>for<sp/>the<sp/>negation)<sp/>may<sp/>not<sp/>be<sp/>so<sp/>great.<sp/>You<sp/>can<sp/>always<sp/>override</highlight></codeline>
<codeline><highlight class="normal">them<sp/>with<sp/>a<sp/>string<sp/>expression<sp/>of<sp/>your<sp/>own:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">MATCHER(IsDivisibleBy7,<sp/>std::string(negation<sp/>?<sp/>&quot;isn&apos;t&quot;<sp/>:<sp/>&quot;is&quot;)<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;<sp/>divisible<sp/>by<sp/>7&quot;)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>(arg<sp/>%<sp/>7)<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Optionally,<sp/>you<sp/>can<sp/>stream<sp/>additional<sp/>information<sp/>to<sp/>a<sp/>hidden<sp/>argument</highlight></codeline>
<codeline><highlight class="normal">named<sp/>`result_listener`<sp/>to<sp/>explain<sp/>the<sp/>match<sp/>result.<sp/>For<sp/>example,<sp/>a</highlight></codeline>
<codeline><highlight class="normal">better<sp/>definition<sp/>of<sp/>`IsDivisibleBy7`<sp/>is:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">MATCHER(IsDivisibleBy7,<sp/>&quot;&quot;)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>((arg<sp/>%<sp/>7)<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>*result_listener<sp/>&lt;&lt;<sp/>&quot;the<sp/>remainder<sp/>is<sp/>&quot;<sp/>&lt;&lt;<sp/>(arg<sp/>%<sp/>7);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">With<sp/>this<sp/>definition,<sp/>the<sp/>above<sp/>assertion<sp/>will<sp/>give<sp/>a<sp/>better<sp/>message:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Value<sp/>of:<sp/>some_expression</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Expected:<sp/>is<sp/>divisible<sp/>by<sp/>7</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Actual:<sp/>27<sp/>(the<sp/>remainder<sp/>is<sp/>6)</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>should<sp/>let<sp/>`MatchAndExplain()`<sp/>print<sp/>_any<sp/>additional<sp/>information_</highlight></codeline>
<codeline><highlight class="normal">that<sp/>can<sp/>help<sp/>a<sp/>user<sp/>understand<sp/>the<sp/>match<sp/>result.<sp/>Note<sp/>that<sp/>it<sp/>should</highlight></codeline>
<codeline><highlight class="normal">explain<sp/>why<sp/>the<sp/>match<sp/>succeeds<sp/>in<sp/>case<sp/>of<sp/>a<sp/>success<sp/>(unless<sp/>it&apos;s</highlight></codeline>
<codeline><highlight class="normal">obvious)<sp/>-<sp/>this<sp/>is<sp/>useful<sp/>when<sp/>the<sp/>matcher<sp/>is<sp/>used<sp/>inside</highlight></codeline>
<codeline><highlight class="normal">`Not()`.<sp/>There<sp/>is<sp/>no<sp/>need<sp/>to<sp/>print<sp/>the<sp/>argument<sp/>value<sp/>itself,<sp/>as</highlight></codeline>
<codeline><highlight class="normal">Google<sp/>Mock<sp/>already<sp/>prints<sp/>it<sp/>for<sp/>you.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**Notes:**</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>1.<sp/>The<sp/>type<sp/>of<sp/>the<sp/>value<sp/>being<sp/>matched<sp/>(`arg_type`)<sp/>is<sp/>determined<sp/>by<sp/>the<sp/>context<sp/>in<sp/>which<sp/>you<sp/>use<sp/>the<sp/>matcher<sp/>and<sp/>is<sp/>supplied<sp/>to<sp/>you<sp/>by<sp/>the<sp/>compiler,<sp/>so<sp/>you<sp/>don&apos;t<sp/>need<sp/>to<sp/>worry<sp/>about<sp/>declaring<sp/>it<sp/>(nor<sp/>can<sp/>you).<sp/><sp/>This<sp/>allows<sp/>the<sp/>matcher<sp/>to<sp/>be<sp/>polymorphic.<sp/><sp/>For<sp/>example,<sp/>`IsDivisibleBy7()`<sp/>can<sp/>be<sp/>used<sp/>to<sp/>match<sp/>any<sp/>type<sp/>where<sp/>the<sp/>value<sp/>of<sp/>`(arg<sp/>%<sp/>7)<sp/>==<sp/>0`<sp/>can<sp/>be<sp/>implicitly<sp/>converted<sp/>to<sp/>a<sp/>`bool`.<sp/><sp/>In<sp/>the<sp/>`Bar(IsDivisibleBy7())`<sp/>example<sp/>above,<sp/>if<sp/>method<sp/>`Bar()`<sp/>takes<sp/>an<sp/>`int`,<sp/>`arg_type`<sp/>will<sp/>be<sp/>`int`;<sp/>if<sp/>it<sp/>takes<sp/>an<sp/>`unsigned<sp/>long`,<sp/>`arg_type`<sp/>will<sp/>be<sp/>`unsigned<sp/>long`;<sp/>and<sp/>so<sp/>on.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>1.<sp/>Google<sp/>Mock<sp/>doesn&apos;t<sp/>guarantee<sp/>when<sp/>or<sp/>how<sp/>many<sp/>times<sp/>a<sp/>matcher<sp/>will<sp/>be<sp/>invoked.<sp/>Therefore<sp/>the<sp/>matcher<sp/>logic<sp/>must<sp/>be<sp/>_purely<sp/>functional_<sp/>(i.e.<sp/>it<sp/>cannot<sp/>have<sp/>any<sp/>side<sp/>effect,<sp/>and<sp/>the<sp/>result<sp/>must<sp/>not<sp/>depend<sp/>on<sp/>anything<sp/>other<sp/>than<sp/>the<sp/>value<sp/>being<sp/>matched<sp/>and<sp/>the<sp/>matcher<sp/>parameters).<sp/>This<sp/>requirement<sp/>must<sp/>be<sp/>satisfied<sp/>no<sp/>matter<sp/>how<sp/>you<sp/>define<sp/>the<sp/>matcher<sp/>(e.g.<sp/>using<sp/>one<sp/>of<sp/>the<sp/>methods<sp/>described<sp/>in<sp/>the<sp/>following<sp/>recipes).<sp/>In<sp/>particular,<sp/>a<sp/>matcher<sp/>can<sp/>never<sp/>call<sp/>a<sp/>mock<sp/>function,<sp/>as<sp/>that<sp/>will<sp/>affect<sp/>the<sp/>state<sp/>of<sp/>the<sp/>mock<sp/>object<sp/>and<sp/>Google<sp/>Mock.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Writing<sp/>New<sp/>Parameterized<sp/>Matchers<sp/>Quickly<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>you&apos;ll<sp/>want<sp/>to<sp/>define<sp/>a<sp/>matcher<sp/>that<sp/>has<sp/>parameters.<sp/><sp/>For<sp/>that<sp/>you</highlight></codeline>
<codeline><highlight class="normal">can<sp/>use<sp/>the<sp/>macro:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">MATCHER_P(name,<sp/>param_name,<sp/>description_string)<sp/>{<sp/>statements;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">where<sp/>the<sp/>description<sp/>string<sp/>can<sp/>be<sp/>either<sp/>`&quot;&quot;`<sp/>or<sp/>a<sp/>string<sp/>expression</highlight></codeline>
<codeline><highlight class="normal">that<sp/>references<sp/>`negation`<sp/>and<sp/>`param_name`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>example:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">MATCHER_P(HasAbsoluteValue,<sp/>value,<sp/>&quot;&quot;)<sp/>{<sp/>return<sp/>abs(arg)<sp/>==<sp/>value;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">will<sp/>allow<sp/>you<sp/>to<sp/>write:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(Blah(&quot;a&quot;),<sp/>HasAbsoluteValue(n));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">which<sp/>may<sp/>lead<sp/>to<sp/>this<sp/>message<sp/>(assuming<sp/>`n`<sp/>is<sp/>10):</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Value<sp/>of:<sp/>Blah(&quot;a&quot;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Expected:<sp/>has<sp/>absolute<sp/>value<sp/>10</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Actual:<sp/>-9</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>both<sp/>the<sp/>matcher<sp/>description<sp/>and<sp/>its<sp/>parameter<sp/>are</highlight></codeline>
<codeline><highlight class="normal">printed,<sp/>making<sp/>the<sp/>message<sp/>human-friendly.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">In<sp/>the<sp/>matcher<sp/>definition<sp/>body,<sp/>you<sp/>can<sp/>write<sp/>`foo_type`<sp/>to</highlight></codeline>
<codeline><highlight class="normal">reference<sp/>the<sp/>type<sp/>of<sp/>a<sp/>parameter<sp/>named<sp/>`foo`.<sp/><sp/>For<sp/>example,<sp/>in<sp/>the</highlight></codeline>
<codeline><highlight class="normal">body<sp/>of<sp/>`MATCHER_P(HasAbsoluteValue,<sp/>value)`<sp/>above,<sp/>you<sp/>can<sp/>write</highlight></codeline>
<codeline><highlight class="normal">`value_type`<sp/>to<sp/>refer<sp/>to<sp/>the<sp/>type<sp/>of<sp/>`value`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Google<sp/>Mock<sp/>also<sp/>provides<sp/>`MATCHER_P2`,<sp/>`MATCHER_P3`,<sp/>...,<sp/>up<sp/>to</highlight></codeline>
<codeline><highlight class="normal">`MATCHER_P10`<sp/>to<sp/>support<sp/>multi-parameter<sp/>matchers:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">MATCHER_Pk(name,<sp/>param_1,<sp/>...,<sp/>param_k,<sp/>description_string)<sp/>{<sp/>statements;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Please<sp/>note<sp/>that<sp/>the<sp/>custom<sp/>description<sp/>string<sp/>is<sp/>for<sp/>a<sp/>particular</highlight></codeline>
<codeline><highlight class="normal">**instance**<sp/>of<sp/>the<sp/>matcher,<sp/>where<sp/>the<sp/>parameters<sp/>have<sp/>been<sp/>bound<sp/>to</highlight></codeline>
<codeline><highlight class="normal">actual<sp/>values.<sp/><sp/>Therefore<sp/>usually<sp/>you&apos;ll<sp/>want<sp/>the<sp/>parameter<sp/>values<sp/>to</highlight></codeline>
<codeline><highlight class="normal">be<sp/>part<sp/>of<sp/>the<sp/>description.<sp/><sp/>Google<sp/>Mock<sp/>lets<sp/>you<sp/>do<sp/>that<sp/>by</highlight></codeline>
<codeline><highlight class="normal">referencing<sp/>the<sp/>matcher<sp/>parameters<sp/>in<sp/>the<sp/>description<sp/>string</highlight></codeline>
<codeline><highlight class="normal">expression.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>example,</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>::testing::PrintToString;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATCHER_P2(InClosedRange,<sp/>low,<sp/>hi,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::string(negation<sp/>?<sp/>&quot;isn&apos;t&quot;<sp/>:<sp/>&quot;is&quot;)<sp/>+<sp/>&quot;<sp/>in<sp/>range<sp/>[&quot;<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintToString(low)<sp/>+<sp/>&quot;,<sp/>&quot;<sp/>+<sp/>PrintToString(hi)<sp/>+<sp/>&quot;]&quot;)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>low<sp/>&lt;=<sp/>arg<sp/>&amp;&amp;<sp/>arg<sp/>&lt;=<sp/>hi;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(3,<sp/>InClosedRange(4,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">would<sp/>generate<sp/>a<sp/>failure<sp/>that<sp/>contains<sp/>the<sp/>message:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Expected:<sp/>is<sp/>in<sp/>range<sp/>[4,<sp/>6]</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>specify<sp/>`&quot;&quot;`<sp/>as<sp/>the<sp/>description,<sp/>the<sp/>failure<sp/>message<sp/>will</highlight></codeline>
<codeline><highlight class="normal">contain<sp/>the<sp/>sequence<sp/>of<sp/>words<sp/>in<sp/>the<sp/>matcher<sp/>name<sp/>followed<sp/>by<sp/>the</highlight></codeline>
<codeline><highlight class="normal">parameter<sp/>values<sp/>printed<sp/>as<sp/>a<sp/>tuple.<sp/><sp/>For<sp/>example,</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATCHER_P2(InClosedRange,<sp/>low,<sp/>hi,<sp/>&quot;&quot;)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(3,<sp/>InClosedRange(4,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">would<sp/>generate<sp/>a<sp/>failure<sp/>that<sp/>contains<sp/>the<sp/>text:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Expected:<sp/>in<sp/>closed<sp/>range<sp/>(4,<sp/>6)</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>the<sp/>purpose<sp/>of<sp/>typing,<sp/>you<sp/>can<sp/>view</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">MATCHER_Pk(Foo,<sp/>p1,<sp/>...,<sp/>pk,<sp/>description_string)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">as<sp/>shorthand<sp/>for</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>p1_type,<sp/>...,<sp/>typename<sp/>pk_type&gt;</highlight></codeline>
<codeline><highlight class="normal">FooMatcherPk&lt;p1_type,<sp/>...,<sp/>pk_type&gt;</highlight></codeline>
<codeline><highlight class="normal">Foo(p1_type<sp/>p1,<sp/>...,<sp/>pk_type<sp/>pk)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>you<sp/>write<sp/>`Foo(v1,<sp/>...,<sp/>vk)`,<sp/>the<sp/>compiler<sp/>infers<sp/>the<sp/>types<sp/>of</highlight></codeline>
<codeline><highlight class="normal">the<sp/>parameters<sp/>`v1`,<sp/>...,<sp/>and<sp/>`vk`<sp/>for<sp/>you.<sp/><sp/>If<sp/>you<sp/>are<sp/>not<sp/>happy<sp/>with</highlight></codeline>
<codeline><highlight class="normal">the<sp/>result<sp/>of<sp/>the<sp/>type<sp/>inference,<sp/>you<sp/>can<sp/>specify<sp/>the<sp/>types<sp/>by</highlight></codeline>
<codeline><highlight class="normal">explicitly<sp/>instantiating<sp/>the<sp/>template,<sp/>as<sp/>in<sp/>`Foo&lt;long,<sp/>bool&gt;(5,<sp/>false)`.</highlight></codeline>
<codeline><highlight class="normal">As<sp/>said<sp/>earlier,<sp/>you<sp/>don&apos;t<sp/>get<sp/>to<sp/>(or<sp/>need<sp/>to)<sp/>specify</highlight></codeline>
<codeline><highlight class="normal">`arg_type`<sp/>as<sp/>that&apos;s<sp/>determined<sp/>by<sp/>the<sp/>context<sp/>in<sp/>which<sp/>the<sp/>matcher</highlight></codeline>
<codeline><highlight class="normal">is<sp/>used.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>assign<sp/>the<sp/>result<sp/>of<sp/>expression<sp/>`Foo(p1,<sp/>...,<sp/>pk)`<sp/>to<sp/>a</highlight></codeline>
<codeline><highlight class="normal">variable<sp/>of<sp/>type<sp/>`FooMatcherPk&lt;p1_type,<sp/>...,<sp/>pk_type&gt;`.<sp/><sp/>This<sp/>can<sp/>be</highlight></codeline>
<codeline><highlight class="normal">useful<sp/>when<sp/>composing<sp/>matchers.<sp/><sp/>Matchers<sp/>that<sp/>don&apos;t<sp/>have<sp/>a<sp/>parameter</highlight></codeline>
<codeline><highlight class="normal">or<sp/>have<sp/>only<sp/>one<sp/>parameter<sp/>have<sp/>special<sp/>types:<sp/>you<sp/>can<sp/>assign<sp/>`Foo()`</highlight></codeline>
<codeline><highlight class="normal">to<sp/>a<sp/>`FooMatcher`-typed<sp/>variable,<sp/>and<sp/>assign<sp/>`Foo(p)`<sp/>to<sp/>a</highlight></codeline>
<codeline><highlight class="normal">`FooMatcherP&lt;p_type&gt;`-typed<sp/>variable.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">While<sp/>you<sp/>can<sp/>instantiate<sp/>a<sp/>matcher<sp/>template<sp/>with<sp/>reference<sp/>types,</highlight></codeline>
<codeline><highlight class="normal">passing<sp/>the<sp/>parameters<sp/>by<sp/>pointer<sp/>usually<sp/>makes<sp/>your<sp/>code<sp/>more</highlight></codeline>
<codeline><highlight class="normal">readable.<sp/><sp/>If,<sp/>however,<sp/>you<sp/>still<sp/>want<sp/>to<sp/>pass<sp/>a<sp/>parameter<sp/>by</highlight></codeline>
<codeline><highlight class="normal">reference,<sp/>be<sp/>aware<sp/>that<sp/>in<sp/>the<sp/>failure<sp/>message<sp/>generated<sp/>by<sp/>the</highlight></codeline>
<codeline><highlight class="normal">matcher<sp/>you<sp/>will<sp/>see<sp/>the<sp/>value<sp/>of<sp/>the<sp/>referenced<sp/>object<sp/>but<sp/>not<sp/>its</highlight></codeline>
<codeline><highlight class="normal">address.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>overload<sp/>matchers<sp/>with<sp/>different<sp/>numbers<sp/>of<sp/>parameters:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">MATCHER_P(Blah,<sp/>a,<sp/>description_string_1)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">MATCHER_P2(Blah,<sp/>a,<sp/>b,<sp/>description_string_2)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">While<sp/>it&apos;s<sp/>tempting<sp/>to<sp/>always<sp/>use<sp/>the<sp/>`MATCHER*`<sp/>macros<sp/>when<sp/>defining</highlight></codeline>
<codeline><highlight class="normal">a<sp/>new<sp/>matcher,<sp/>you<sp/>should<sp/>also<sp/>consider<sp/>implementing</highlight></codeline>
<codeline><highlight class="normal">`MatcherInterface`<sp/>or<sp/>using<sp/>`MakePolymorphicMatcher()`<sp/>instead<sp/>(see</highlight></codeline>
<codeline><highlight class="normal">the<sp/>recipes<sp/>that<sp/>follow),<sp/>especially<sp/>if<sp/>you<sp/>need<sp/>to<sp/>use<sp/>the<sp/>matcher<sp/>a</highlight></codeline>
<codeline><highlight class="normal">lot.<sp/><sp/>While<sp/>these<sp/>approaches<sp/>require<sp/>more<sp/>work,<sp/>they<sp/>give<sp/>you<sp/>more</highlight></codeline>
<codeline><highlight class="normal">control<sp/>on<sp/>the<sp/>types<sp/>of<sp/>the<sp/>value<sp/>being<sp/>matched<sp/>and<sp/>the<sp/>matcher</highlight></codeline>
<codeline><highlight class="normal">parameters,<sp/>which<sp/>in<sp/>general<sp/>leads<sp/>to<sp/>better<sp/>compiler<sp/>error<sp/>messages</highlight></codeline>
<codeline><highlight class="normal">that<sp/>pay<sp/>off<sp/>in<sp/>the<sp/>long<sp/>run.<sp/><sp/>They<sp/>also<sp/>allow<sp/>overloading<sp/>matchers</highlight></codeline>
<codeline><highlight class="normal">based<sp/>on<sp/>parameter<sp/>types<sp/>(as<sp/>opposed<sp/>to<sp/>just<sp/>based<sp/>on<sp/>the<sp/>number<sp/>of</highlight></codeline>
<codeline><highlight class="normal">parameters).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Writing<sp/>New<sp/>Monomorphic<sp/>Matchers<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>matcher<sp/>of<sp/>argument<sp/>type<sp/>`T`<sp/>implements</highlight></codeline>
<codeline><highlight class="normal">`::testing::MatcherInterface&lt;T&gt;`<sp/>and<sp/>does<sp/>two<sp/>things:<sp/>it<sp/>tests<sp/>whether<sp/>a</highlight></codeline>
<codeline><highlight class="normal">value<sp/>of<sp/>type<sp/>`T`<sp/>matches<sp/>the<sp/>matcher,<sp/>and<sp/>can<sp/>describe<sp/>what<sp/>kind<sp/>of</highlight></codeline>
<codeline><highlight class="normal">values<sp/>it<sp/>matches.<sp/>The<sp/>latter<sp/>ability<sp/>is<sp/>used<sp/>for<sp/>generating<sp/>readable</highlight></codeline>
<codeline><highlight class="normal">error<sp/>messages<sp/>when<sp/>expectations<sp/>are<sp/>violated.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>interface<sp/>looks<sp/>like<sp/>this:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MatchResultListener<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Streams<sp/>x<sp/>to<sp/>the<sp/>underlying<sp/>ostream;<sp/>does<sp/>nothing<sp/>if<sp/>the<sp/>ostream</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>is<sp/>NULL.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template<sp/>&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MatchResultListener&amp;<sp/>operator&lt;&lt;(const<sp/>T&amp;<sp/>x);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Returns<sp/>the<sp/>underlying<sp/>ostream.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>::std::ostream*<sp/>stream();</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MatcherInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~MatcherInterface();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Returns<sp/>true<sp/>iff<sp/>the<sp/>matcher<sp/>matches<sp/>x;<sp/>also<sp/>explains<sp/>the<sp/>match</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>result<sp/>to<sp/>&apos;listener&apos;.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>bool<sp/>MatchAndExplain(T<sp/>x,<sp/>MatchResultListener*<sp/>listener)<sp/>const<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Describes<sp/>this<sp/>matcher<sp/>to<sp/>an<sp/>ostream.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>DescribeTo(::std::ostream*<sp/>os)<sp/>const<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Describes<sp/>the<sp/>negation<sp/>of<sp/>this<sp/>matcher<sp/>to<sp/>an<sp/>ostream.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>DescribeNegationTo(::std::ostream*<sp/>os)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>need<sp/>a<sp/>custom<sp/>matcher<sp/>but<sp/>`Truly()`<sp/>is<sp/>not<sp/>a<sp/>good<sp/>option<sp/>(for</highlight></codeline>
<codeline><highlight class="normal">example,<sp/>you<sp/>may<sp/>not<sp/>be<sp/>happy<sp/>with<sp/>the<sp/>way<sp/>`Truly(predicate)`</highlight></codeline>
<codeline><highlight class="normal">describes<sp/>itself,<sp/>or<sp/>you<sp/>may<sp/>want<sp/>your<sp/>matcher<sp/>to<sp/>be<sp/>polymorphic<sp/>as</highlight></codeline>
<codeline><highlight class="normal">`Eq(value)`<sp/>is),<sp/>you<sp/>can<sp/>define<sp/>a<sp/>matcher<sp/>to<sp/>do<sp/>whatever<sp/>you<sp/>want<sp/>in</highlight></codeline>
<codeline><highlight class="normal">two<sp/>steps:<sp/>first<sp/>implement<sp/>the<sp/>matcher<sp/>interface,<sp/>and<sp/>then<sp/>define<sp/>a</highlight></codeline>
<codeline><highlight class="normal">factory<sp/>function<sp/>to<sp/>create<sp/>a<sp/>matcher<sp/>instance.<sp/>The<sp/>second<sp/>step<sp/>is<sp/>not</highlight></codeline>
<codeline><highlight class="normal">strictly<sp/>needed<sp/>but<sp/>it<sp/>makes<sp/>the<sp/>syntax<sp/>of<sp/>using<sp/>the<sp/>matcher<sp/>nicer.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>example,<sp/>you<sp/>can<sp/>define<sp/>a<sp/>matcher<sp/>to<sp/>test<sp/>whether<sp/>an<sp/>`int`<sp/>is</highlight></codeline>
<codeline><highlight class="normal">divisible<sp/>by<sp/>7<sp/>and<sp/>then<sp/>use<sp/>it<sp/>like<sp/>this:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MakeMatcher;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Matcher;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MatcherInterface;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MatchResultListener;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>DivisibleBy7Matcher<sp/>:<sp/>public<sp/>MatcherInterface&lt;int&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>bool<sp/>MatchAndExplain(int<sp/>n,<sp/>MatchResultListener*<sp/>listener)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(n<sp/>%<sp/>7)<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>DescribeTo(::std::ostream*<sp/>os)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*os<sp/>&lt;&lt;<sp/>&quot;is<sp/>divisible<sp/>by<sp/>7&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>DescribeNegationTo(::std::ostream*<sp/>os)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*os<sp/>&lt;&lt;<sp/>&quot;is<sp/>not<sp/>divisible<sp/>by<sp/>7&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">inline<sp/>Matcher&lt;int&gt;<sp/>DivisibleBy7()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>MakeMatcher(new<sp/>DivisibleBy7Matcher);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(DivisibleBy7()));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>may<sp/>improve<sp/>the<sp/>matcher<sp/>message<sp/>by<sp/>streaming<sp/>additional</highlight></codeline>
<codeline><highlight class="normal">information<sp/>to<sp/>the<sp/>`listener`<sp/>argument<sp/>in<sp/>`MatchAndExplain()`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">class<sp/>DivisibleBy7Matcher<sp/>:<sp/>public<sp/>MatcherInterface&lt;int&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>bool<sp/>MatchAndExplain(int<sp/>n,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MatchResultListener*<sp/>listener)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>int<sp/>remainder<sp/>=<sp/>n<sp/>%<sp/>7;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(remainder<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>*listener<sp/>&lt;&lt;<sp/>&quot;the<sp/>remainder<sp/>is<sp/>&quot;<sp/>&lt;&lt;<sp/>remainder;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>remainder<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Then,<sp/>`EXPECT_THAT(x,<sp/>DivisibleBy7());`<sp/>may<sp/>general<sp/>a<sp/>message<sp/>like<sp/>this:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>of:<sp/>x</highlight></codeline>
<codeline><highlight class="normal">Expected:<sp/>is<sp/>divisible<sp/>by<sp/>7</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Actual:<sp/>23<sp/>(the<sp/>remainder<sp/>is<sp/>2)</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Writing<sp/>New<sp/>Polymorphic<sp/>Matchers<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You&apos;ve<sp/>learned<sp/>how<sp/>to<sp/>write<sp/>your<sp/>own<sp/>matchers<sp/>in<sp/>the<sp/>previous</highlight></codeline>
<codeline><highlight class="normal">recipe.<sp/>Just<sp/>one<sp/>problem:<sp/>a<sp/>matcher<sp/>created<sp/>using<sp/>`MakeMatcher()`<sp/>only</highlight></codeline>
<codeline><highlight class="normal">works<sp/>for<sp/>one<sp/>particular<sp/>type<sp/>of<sp/>arguments.<sp/>If<sp/>you<sp/>want<sp/>a</highlight></codeline>
<codeline><highlight class="normal">_polymorphic_<sp/>matcher<sp/>that<sp/>works<sp/>with<sp/>arguments<sp/>of<sp/>several<sp/>types<sp/>(for</highlight></codeline>
<codeline><highlight class="normal">instance,<sp/>`Eq(x)`<sp/>can<sp/>be<sp/>used<sp/>to<sp/>match<sp/>a<sp/>`value`<sp/>as<sp/>long<sp/>as<sp/>`value`<sp/>==</highlight></codeline>
<codeline><highlight class="normal">`x`<sp/>compiles<sp/>--<sp/>`value`<sp/>and<sp/>`x`<sp/>don&apos;t<sp/>have<sp/>to<sp/>share<sp/>the<sp/>same<sp/>type),</highlight></codeline>
<codeline><highlight class="normal">you<sp/>can<sp/>learn<sp/>the<sp/>trick<sp/>from<sp/>`&quot;gmock/gmock-matchers.h&quot;`<sp/>but<sp/>it&apos;s<sp/>a<sp/>bit</highlight></codeline>
<codeline><highlight class="normal">involved.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Fortunately,<sp/>most<sp/>of<sp/>the<sp/>time<sp/>you<sp/>can<sp/>define<sp/>a<sp/>polymorphic<sp/>matcher</highlight></codeline>
<codeline><highlight class="normal">easily<sp/>with<sp/>the<sp/>help<sp/>of<sp/>`MakePolymorphicMatcher()`.<sp/>Here&apos;s<sp/>how<sp/>you<sp/>can</highlight></codeline>
<codeline><highlight class="normal">define<sp/>`NotNull()`<sp/>as<sp/>an<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MakePolymorphicMatcher;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MatchResultListener;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::NotNull;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::PolymorphicMatcher;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>NotNullMatcher<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>To<sp/>implement<sp/>a<sp/>polymorphic<sp/>matcher,<sp/>first<sp/>define<sp/>a<sp/>COPYABLE<sp/>class</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>that<sp/>has<sp/>three<sp/>members<sp/>MatchAndExplain(),<sp/>DescribeTo(),<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>DescribeNegationTo(),<sp/>like<sp/>the<sp/>following.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>In<sp/>this<sp/>example,<sp/>we<sp/>want<sp/>to<sp/>use<sp/>NotNull()<sp/>with<sp/>any<sp/>pointer,<sp/>so</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>MatchAndExplain()<sp/>accepts<sp/>a<sp/>pointer<sp/>of<sp/>any<sp/>type<sp/>as<sp/>its<sp/>first<sp/>argument.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>In<sp/>general,<sp/>you<sp/>can<sp/>define<sp/>MatchAndExplain()<sp/>as<sp/>an<sp/>ordinary<sp/>method<sp/>or</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>a<sp/>method<sp/>template,<sp/>or<sp/>even<sp/>overload<sp/>it.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template<sp/>&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>MatchAndExplain(T*<sp/>p,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MatchResultListener*<sp/>/*<sp/>listener<sp/>*/)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>p<sp/>!=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Describes<sp/>the<sp/>property<sp/>of<sp/>a<sp/>value<sp/>matching<sp/>this<sp/>matcher.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>DescribeTo(::std::ostream*<sp/>os)<sp/>const<sp/>{<sp/>*os<sp/>&lt;&lt;<sp/>&quot;is<sp/>not<sp/>NULL&quot;;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Describes<sp/>the<sp/>property<sp/>of<sp/>a<sp/>value<sp/>NOT<sp/>matching<sp/>this<sp/>matcher.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>DescribeNegationTo(::std::ostream*<sp/>os)<sp/>const<sp/>{<sp/>*os<sp/>&lt;&lt;<sp/>&quot;is<sp/>NULL&quot;;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>To<sp/>construct<sp/>a<sp/>polymorphic<sp/>matcher,<sp/>pass<sp/>an<sp/>instance<sp/>of<sp/>the<sp/>class</highlight></codeline>
<codeline><highlight class="normal">//<sp/>to<sp/>MakePolymorphicMatcher().<sp/><sp/>Note<sp/>the<sp/>return<sp/>type.</highlight></codeline>
<codeline><highlight class="normal">inline<sp/>PolymorphicMatcher&lt;NotNullMatcher&gt;<sp/>NotNull()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>MakePolymorphicMatcher(NotNullMatcher());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(NotNull()));<sp/><sp/>//<sp/>The<sp/>argument<sp/>must<sp/>be<sp/>a<sp/>non-NULL<sp/>pointer.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**Note:**<sp/>Your<sp/>polymorphic<sp/>matcher<sp/>class<sp/>does<sp/>**not**<sp/>need<sp/>to<sp/>inherit<sp/>from</highlight></codeline>
<codeline><highlight class="normal">`MatcherInterface`<sp/>or<sp/>any<sp/>other<sp/>class,<sp/>and<sp/>its<sp/>methods<sp/>do<sp/>**not**<sp/>need</highlight></codeline>
<codeline><highlight class="normal">to<sp/>be<sp/>virtual.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Like<sp/>in<sp/>a<sp/>monomorphic<sp/>matcher,<sp/>you<sp/>may<sp/>explain<sp/>the<sp/>match<sp/>result<sp/>by</highlight></codeline>
<codeline><highlight class="normal">streaming<sp/>additional<sp/>information<sp/>to<sp/>the<sp/>`listener`<sp/>argument<sp/>in</highlight></codeline>
<codeline><highlight class="normal">`MatchAndExplain()`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Writing<sp/>New<sp/>Cardinalities<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>cardinality<sp/>is<sp/>used<sp/>in<sp/>`Times()`<sp/>to<sp/>tell<sp/>Google<sp/>Mock<sp/>how<sp/>many<sp/>times</highlight></codeline>
<codeline><highlight class="normal">you<sp/>expect<sp/>a<sp/>call<sp/>to<sp/>occur.<sp/>It<sp/>doesn&apos;t<sp/>have<sp/>to<sp/>be<sp/>exact.<sp/>For<sp/>example,</highlight></codeline>
<codeline><highlight class="normal">you<sp/>can<sp/>say<sp/>`AtLeast(5)`<sp/>or<sp/>`Between(2,<sp/>4)`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>the<sp/>built-in<sp/>set<sp/>of<sp/>cardinalities<sp/>doesn&apos;t<sp/>suit<sp/>you,<sp/>you<sp/>are<sp/>free<sp/>to</highlight></codeline>
<codeline><highlight class="normal">define<sp/>your<sp/>own<sp/>by<sp/>implementing<sp/>the<sp/>following<sp/>interface<sp/>(in<sp/>namespace</highlight></codeline>
<codeline><highlight class="normal">`testing`):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">class<sp/>CardinalityInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~CardinalityInterface();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Returns<sp/>true<sp/>iff<sp/>call_count<sp/>calls<sp/>will<sp/>satisfy<sp/>this<sp/>cardinality.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>bool<sp/>IsSatisfiedByCallCount(int<sp/>call_count)<sp/>const<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Returns<sp/>true<sp/>iff<sp/>call_count<sp/>calls<sp/>will<sp/>saturate<sp/>this<sp/>cardinality.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>bool<sp/>IsSaturatedByCallCount(int<sp/>call_count)<sp/>const<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Describes<sp/>self<sp/>to<sp/>an<sp/>ostream.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>DescribeTo(::std::ostream*<sp/>os)<sp/>const<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>example,<sp/>to<sp/>specify<sp/>that<sp/>a<sp/>call<sp/>must<sp/>occur<sp/>even<sp/>number<sp/>of<sp/>times,</highlight></codeline>
<codeline><highlight class="normal">you<sp/>can<sp/>write</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Cardinality;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::CardinalityInterface;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MakeCardinality;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>EvenNumberCardinality<sp/>:<sp/>public<sp/>CardinalityInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>bool<sp/>IsSatisfiedByCallCount(int<sp/>call_count)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(call_count<sp/>%<sp/>2)<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>bool<sp/>IsSaturatedByCallCount(int<sp/>call_count)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>DescribeTo(::std::ostream*<sp/>os)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*os<sp/>&lt;&lt;<sp/>&quot;called<sp/>even<sp/>number<sp/>of<sp/>times&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Cardinality<sp/>EvenNumber()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>MakeCardinality(new<sp/>EvenNumberCardinality);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(3))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(EvenNumber());</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Writing<sp/>New<sp/>Actions<sp/>Quickly<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>the<sp/>built-in<sp/>actions<sp/>don&apos;t<sp/>work<sp/>for<sp/>you,<sp/>and<sp/>you<sp/>find<sp/>it</highlight></codeline>
<codeline><highlight class="normal">inconvenient<sp/>to<sp/>use<sp/>`Invoke()`,<sp/>you<sp/>can<sp/>use<sp/>a<sp/>macro<sp/>from<sp/>the<sp/>`ACTION*`</highlight></codeline>
<codeline><highlight class="normal">family<sp/>to<sp/>quickly<sp/>define<sp/>a<sp/>new<sp/>action<sp/>that<sp/>can<sp/>be<sp/>used<sp/>in<sp/>your<sp/>code<sp/>as</highlight></codeline>
<codeline><highlight class="normal">if<sp/>it&apos;s<sp/>a<sp/>built-in<sp/>action.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">By<sp/>writing</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">ACTION(name)<sp/>{<sp/>statements;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">in<sp/>a<sp/>namespace<sp/>scope<sp/>(i.e.<sp/>not<sp/>inside<sp/>a<sp/>class<sp/>or<sp/>function),<sp/>you<sp/>will</highlight></codeline>
<codeline><highlight class="normal">define<sp/>an<sp/>action<sp/>with<sp/>the<sp/>given<sp/>name<sp/>that<sp/>executes<sp/>the<sp/>statements.</highlight></codeline>
<codeline><highlight class="normal">The<sp/>value<sp/>returned<sp/>by<sp/>`statements`<sp/>will<sp/>be<sp/>used<sp/>as<sp/>the<sp/>return<sp/>value<sp/>of</highlight></codeline>
<codeline><highlight class="normal">the<sp/>action.<sp/><sp/>Inside<sp/>the<sp/>statements,<sp/>you<sp/>can<sp/>refer<sp/>to<sp/>the<sp/>K-th</highlight></codeline>
<codeline><highlight class="normal">(0-based)<sp/>argument<sp/>of<sp/>the<sp/>mock<sp/>function<sp/>as<sp/>`argK`.<sp/><sp/>For<sp/>example:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">ACTION(IncrementArg1)<sp/>{<sp/>return<sp/>++(*arg1);<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">allows<sp/>you<sp/>to<sp/>write</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">...<sp/>WillOnce(IncrementArg1());</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>you<sp/>don&apos;t<sp/>need<sp/>to<sp/>specify<sp/>the<sp/>types<sp/>of<sp/>the<sp/>mock<sp/>function</highlight></codeline>
<codeline><highlight class="normal">arguments.<sp/><sp/>Rest<sp/>assured<sp/>that<sp/>your<sp/>code<sp/>is<sp/>type-safe<sp/>though:</highlight></codeline>
<codeline><highlight class="normal">you&apos;ll<sp/>get<sp/>a<sp/>compiler<sp/>error<sp/>if<sp/>`*arg1`<sp/>doesn&apos;t<sp/>support<sp/>the<sp/>`++`</highlight></codeline>
<codeline><highlight class="normal">operator,<sp/>or<sp/>if<sp/>the<sp/>type<sp/>of<sp/>`++(*arg1)`<sp/>isn&apos;t<sp/>compatible<sp/>with<sp/>the<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">function&apos;s<sp/>return<sp/>type.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Another<sp/>example:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">ACTION(Foo)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>(*arg2)(5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Blah();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*arg1<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>arg0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">defines<sp/>an<sp/>action<sp/>`Foo()`<sp/>that<sp/>invokes<sp/>argument<sp/>#2<sp/>(a<sp/>function<sp/>pointer)</highlight></codeline>
<codeline><highlight class="normal">with<sp/>5,<sp/>calls<sp/>function<sp/>`Blah()`,<sp/>sets<sp/>the<sp/>value<sp/>pointed<sp/>to<sp/>by<sp/>argument</highlight></codeline>
<codeline><highlight class="normal">#1<sp/>to<sp/>0,<sp/>and<sp/>returns<sp/>argument<sp/>#0.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>more<sp/>convenience<sp/>and<sp/>flexibility,<sp/>you<sp/>can<sp/>also<sp/>use<sp/>the<sp/>following</highlight></codeline>
<codeline><highlight class="normal">pre-defined<sp/>symbols<sp/>in<sp/>the<sp/>body<sp/>of<sp/>`ACTION`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">|<sp/>`argK_type`<sp/>|<sp/>The<sp/>type<sp/>of<sp/>the<sp/>K-th<sp/>(0-based)<sp/>argument<sp/>of<sp/>the<sp/>mock<sp/>function<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|:------------|:-------------------------------------------------------------|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`args`<sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>All<sp/>arguments<sp/>of<sp/>the<sp/>mock<sp/>function<sp/>as<sp/>a<sp/>tuple<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`args_type`<sp/>|<sp/>The<sp/>type<sp/>of<sp/>all<sp/>arguments<sp/>of<sp/>the<sp/>mock<sp/>function<sp/>as<sp/>a<sp/>tuple<sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`return_type`<sp/>|<sp/>The<sp/>return<sp/>type<sp/>of<sp/>the<sp/>mock<sp/>function<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`function_type`<sp/>|<sp/>The<sp/>type<sp/>of<sp/>the<sp/>mock<sp/>function<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>example,<sp/>when<sp/>using<sp/>an<sp/>`ACTION`<sp/>as<sp/>a<sp/>stub<sp/>action<sp/>for<sp/>mock<sp/>function:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">int<sp/>DoSomething(bool<sp/>flag,<sp/>int*<sp/>ptr);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">we<sp/>have:</highlight></codeline>
<codeline><highlight class="normal">|<sp/>**Pre-defined<sp/>Symbol**<sp/>|<sp/>**Is<sp/>Bound<sp/>To**<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|:-----------------------|:----------------|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`arg0`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>the<sp/>value<sp/>of<sp/>`flag`<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`arg0_type`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>the<sp/>type<sp/>`bool`<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`arg1`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>the<sp/>value<sp/>of<sp/>`ptr`<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`arg1_type`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>the<sp/>type<sp/>`int*`<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`args`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>the<sp/>tuple<sp/>`(flag,<sp/>ptr)`<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`args_type`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>the<sp/>type<sp/>`::testing::tuple&lt;bool,<sp/>int*&gt;`<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`return_type`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>the<sp/>type<sp/>`int`<sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`function_type`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>the<sp/>type<sp/>`int(bool,<sp/>int*)`<sp/>|</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Writing<sp/>New<sp/>Parameterized<sp/>Actions<sp/>Quickly<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>you&apos;ll<sp/>want<sp/>to<sp/>parameterize<sp/>an<sp/>action<sp/>you<sp/>define.<sp/><sp/>For<sp/>that</highlight></codeline>
<codeline><highlight class="normal">we<sp/>have<sp/>another<sp/>macro</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">ACTION_P(name,<sp/>param)<sp/>{<sp/>statements;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>example,</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">ACTION_P(Add,<sp/>n)<sp/>{<sp/>return<sp/>arg0<sp/>+<sp/>n;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">will<sp/>allow<sp/>you<sp/>to<sp/>write</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Returns<sp/>argument<sp/>#0<sp/>+<sp/>5.</highlight></codeline>
<codeline><highlight class="normal">...<sp/>WillOnce(Add(5));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>convenience,<sp/>we<sp/>use<sp/>the<sp/>term<sp/>_arguments_<sp/>for<sp/>the<sp/>values<sp/>used<sp/>to</highlight></codeline>
<codeline><highlight class="normal">invoke<sp/>the<sp/>mock<sp/>function,<sp/>and<sp/>the<sp/>term<sp/>_parameters_<sp/>for<sp/>the<sp/>values</highlight></codeline>
<codeline><highlight class="normal">used<sp/>to<sp/>instantiate<sp/>an<sp/>action.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>you<sp/>don&apos;t<sp/>need<sp/>to<sp/>provide<sp/>the<sp/>type<sp/>of<sp/>the<sp/>parameter<sp/>either.</highlight></codeline>
<codeline><highlight class="normal">Suppose<sp/>the<sp/>parameter<sp/>is<sp/>named<sp/>`param`,<sp/>you<sp/>can<sp/>also<sp/>use<sp/>the</highlight></codeline>
<codeline><highlight class="normal">Google-Mock-defined<sp/>symbol<sp/>`param_type`<sp/>to<sp/>refer<sp/>to<sp/>the<sp/>type<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal">parameter<sp/>as<sp/>inferred<sp/>by<sp/>the<sp/>compiler.<sp/><sp/>For<sp/>example,<sp/>in<sp/>the<sp/>body<sp/>of</highlight></codeline>
<codeline><highlight class="normal">`ACTION_P(Add,<sp/>n)`<sp/>above,<sp/>you<sp/>can<sp/>write<sp/>`n_type`<sp/>for<sp/>the<sp/>type<sp/>of<sp/>`n`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Google<sp/>Mock<sp/>also<sp/>provides<sp/>`ACTION_P2`,<sp/>`ACTION_P3`,<sp/>and<sp/>etc<sp/>to<sp/>support</highlight></codeline>
<codeline><highlight class="normal">multi-parameter<sp/>actions.<sp/><sp/>For<sp/>example,</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">ACTION_P2(ReturnDistanceTo,<sp/>x,<sp/>y)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double<sp/>dx<sp/>=<sp/>arg0<sp/>-<sp/>x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double<sp/>dy<sp/>=<sp/>arg1<sp/>-<sp/>y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>sqrt(dx*dx<sp/>+<sp/>dy*dy);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">lets<sp/>you<sp/>write</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">...<sp/>WillOnce(ReturnDistanceTo(5.0,<sp/>26.5));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>view<sp/>`ACTION`<sp/>as<sp/>a<sp/>degenerated<sp/>parameterized<sp/>action<sp/>where<sp/>the</highlight></codeline>
<codeline><highlight class="normal">number<sp/>of<sp/>parameters<sp/>is<sp/>0.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>also<sp/>easily<sp/>define<sp/>actions<sp/>overloaded<sp/>on<sp/>the<sp/>number<sp/>of<sp/>parameters:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">ACTION_P(Plus,<sp/>a)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">ACTION_P2(Plus,<sp/>a,<sp/>b)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Restricting<sp/>the<sp/>Type<sp/>of<sp/>an<sp/>Argument<sp/>or<sp/>Parameter<sp/>in<sp/>an<sp/>ACTION<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>maximum<sp/>brevity<sp/>and<sp/>reusability,<sp/>the<sp/>`ACTION*`<sp/>macros<sp/>don&apos;t<sp/>ask</highlight></codeline>
<codeline><highlight class="normal">you<sp/>to<sp/>provide<sp/>the<sp/>types<sp/>of<sp/>the<sp/>mock<sp/>function<sp/>arguments<sp/>and<sp/>the<sp/>action</highlight></codeline>
<codeline><highlight class="normal">parameters.<sp/><sp/>Instead,<sp/>we<sp/>let<sp/>the<sp/>compiler<sp/>infer<sp/>the<sp/>types<sp/>for<sp/>us.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes,<sp/>however,<sp/>we<sp/>may<sp/>want<sp/>to<sp/>be<sp/>more<sp/>explicit<sp/>about<sp/>the<sp/>types.</highlight></codeline>
<codeline><highlight class="normal">There<sp/>are<sp/>several<sp/>tricks<sp/>to<sp/>do<sp/>that.<sp/><sp/>For<sp/>example:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">ACTION(Foo)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Makes<sp/>sure<sp/>arg0<sp/>can<sp/>be<sp/>converted<sp/>to<sp/>int.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>n<sp/>=<sp/>arg0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>use<sp/>n<sp/>instead<sp/>of<sp/>arg0<sp/>here<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">ACTION_P(Bar,<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Makes<sp/>sure<sp/>the<sp/>type<sp/>of<sp/>arg1<sp/>is<sp/>const<sp/>char*.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>::testing::StaticAssertTypeEq&lt;const<sp/>char*,<sp/>arg1_type&gt;();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Makes<sp/>sure<sp/>param<sp/>can<sp/>be<sp/>converted<sp/>to<sp/>bool.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>flag<sp/>=<sp/>param;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">where<sp/>`StaticAssertTypeEq`<sp/>is<sp/>a<sp/>compile-time<sp/>assertion<sp/>in<sp/>Google<sp/>Test</highlight></codeline>
<codeline><highlight class="normal">that<sp/>verifies<sp/>two<sp/>types<sp/>are<sp/>the<sp/>same.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Writing<sp/>New<sp/>Action<sp/>Templates<sp/>Quickly<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>you<sp/>want<sp/>to<sp/>give<sp/>an<sp/>action<sp/>explicit<sp/>template<sp/>parameters<sp/>that</highlight></codeline>
<codeline><highlight class="normal">cannot<sp/>be<sp/>inferred<sp/>from<sp/>its<sp/>value<sp/>parameters.<sp/><sp/>`ACTION_TEMPLATE()`</highlight></codeline>
<codeline><highlight class="normal">supports<sp/>that<sp/>and<sp/>can<sp/>be<sp/>viewed<sp/>as<sp/>an<sp/>extension<sp/>to<sp/>`ACTION()`<sp/>and</highlight></codeline>
<codeline><highlight class="normal">`ACTION_P*()`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>syntax:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">ACTION_TEMPLATE(ActionName,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HAS_m_TEMPLATE_PARAMS(kind1,<sp/>name1,<sp/>...,<sp/>kind_m,<sp/>name_m),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AND_n_VALUE_PARAMS(p1,<sp/>...,<sp/>p_n))<sp/>{<sp/>statements;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">defines<sp/>an<sp/>action<sp/>template<sp/>that<sp/>takes<sp/>_m_<sp/>explicit<sp/>template<sp/>parameters</highlight></codeline>
<codeline><highlight class="normal">and<sp/>_n_<sp/>value<sp/>parameters,<sp/>where<sp/>_m_<sp/>is<sp/>between<sp/>1<sp/>and<sp/>10,<sp/>and<sp/>_n_<sp/>is</highlight></codeline>
<codeline><highlight class="normal">between<sp/>0<sp/>and<sp/>10.<sp/><sp/>`name_i`<sp/>is<sp/>the<sp/>name<sp/>of<sp/>the<sp/>i-th<sp/>template</highlight></codeline>
<codeline><highlight class="normal">parameter,<sp/>and<sp/>`kind_i`<sp/>specifies<sp/>whether<sp/>it&apos;s<sp/>a<sp/>`typename`,<sp/>an</highlight></codeline>
<codeline><highlight class="normal">integral<sp/>constant,<sp/>or<sp/>a<sp/>template.<sp/><sp/>`p_i`<sp/>is<sp/>the<sp/>name<sp/>of<sp/>the<sp/>i-th<sp/>value</highlight></codeline>
<codeline><highlight class="normal">parameter.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Example:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">//<sp/>DuplicateArg&lt;k,<sp/>T&gt;(output)<sp/>converts<sp/>the<sp/>k-th<sp/>argument<sp/>of<sp/>the<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">//<sp/>function<sp/>to<sp/>type<sp/>T<sp/>and<sp/>copies<sp/>it<sp/>to<sp/>*output.</highlight></codeline>
<codeline><highlight class="normal">ACTION_TEMPLATE(DuplicateArg,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Note<sp/>the<sp/>comma<sp/>between<sp/>int<sp/>and<sp/>k:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HAS_2_TEMPLATE_PARAMS(int,<sp/>k,<sp/>typename,<sp/>T),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AND_1_VALUE_PARAMS(output))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*output<sp/>=<sp/>T(::testing::get&lt;k&gt;(args));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">To<sp/>create<sp/>an<sp/>instance<sp/>of<sp/>an<sp/>action<sp/>template,<sp/>write:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ActionName&lt;t1,<sp/>...,<sp/>t_m&gt;(v1,<sp/>...,<sp/>v_n)</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">where<sp/>the<sp/>`t`s<sp/>are<sp/>the<sp/>template<sp/>arguments<sp/>and<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`v`s<sp/>are<sp/>the<sp/>value<sp/>arguments.<sp/><sp/>The<sp/>value<sp/>argument</highlight></codeline>
<codeline><highlight class="normal">types<sp/>are<sp/>inferred<sp/>by<sp/>the<sp/>compiler.<sp/><sp/>For<sp/>example:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(DuplicateArg&lt;1,<sp/>unsigned<sp/>char&gt;(&amp;n));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>want<sp/>to<sp/>explicitly<sp/>specify<sp/>the<sp/>value<sp/>argument<sp/>types,<sp/>you<sp/>can</highlight></codeline>
<codeline><highlight class="normal">provide<sp/>additional<sp/>template<sp/>arguments:</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ActionName&lt;t1,<sp/>...,<sp/>t_m,<sp/>u1,<sp/>...,<sp/>u_k&gt;(v1,<sp/>...,<sp/>v_n)</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">where<sp/>`u_i`<sp/>is<sp/>the<sp/>desired<sp/>type<sp/>of<sp/>`v_i`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`ACTION_TEMPLATE`<sp/>and<sp/>`ACTION`/`ACTION_P*`<sp/>can<sp/>be<sp/>overloaded<sp/>on<sp/>the</highlight></codeline>
<codeline><highlight class="normal">number<sp/>of<sp/>value<sp/>parameters,<sp/>but<sp/>not<sp/>on<sp/>the<sp/>number<sp/>of<sp/>template</highlight></codeline>
<codeline><highlight class="normal">parameters.<sp/><sp/>Without<sp/>the<sp/>restriction,<sp/>the<sp/>meaning<sp/>of<sp/>the<sp/>following<sp/>is</highlight></codeline>
<codeline><highlight class="normal">unclear:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OverloadedAction&lt;int,<sp/>bool&gt;(x);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Are<sp/>we<sp/>using<sp/>a<sp/>single-template-parameter<sp/>action<sp/>where<sp/>`bool`<sp/>refers<sp/>to</highlight></codeline>
<codeline><highlight class="normal">the<sp/>type<sp/>of<sp/>`x`,<sp/>or<sp/>a<sp/>two-template-parameter<sp/>action<sp/>where<sp/>the<sp/>compiler</highlight></codeline>
<codeline><highlight class="normal">is<sp/>asked<sp/>to<sp/>infer<sp/>the<sp/>type<sp/>of<sp/>`x`?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Using<sp/>the<sp/>ACTION<sp/>Object&apos;s<sp/>Type<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>are<sp/>writing<sp/>a<sp/>function<sp/>that<sp/>returns<sp/>an<sp/>`ACTION`<sp/>object,<sp/>you&apos;ll</highlight></codeline>
<codeline><highlight class="normal">need<sp/>to<sp/>know<sp/>its<sp/>type.<sp/><sp/>The<sp/>type<sp/>depends<sp/>on<sp/>the<sp/>macro<sp/>used<sp/>to<sp/>define</highlight></codeline>
<codeline><highlight class="normal">the<sp/>action<sp/>and<sp/>the<sp/>parameter<sp/>types.<sp/><sp/>The<sp/>rule<sp/>is<sp/>relatively<sp/>simple:</highlight></codeline>
<codeline><highlight class="normal">|<sp/>**Given<sp/>Definition**<sp/>|<sp/>**Expression**<sp/>|<sp/>**Has<sp/>Type**<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|:---------------------|:---------------|:-------------|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`ACTION(Foo)`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>`Foo()`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>`FooAction`<sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`ACTION_TEMPLATE(Foo,<sp/>HAS_m_TEMPLATE_PARAMS(...),<sp/>AND_0_VALUE_PARAMS())`<sp/>|<sp/><sp/><sp/><sp/>`Foo&lt;t1,<sp/>...,<sp/>t_m&gt;()`<sp/>|<sp/>`FooAction&lt;t1,<sp/>...,<sp/>t_m&gt;`<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`ACTION_P(Bar,<sp/>param)`<sp/>|<sp/>`Bar(int_value)`<sp/>|<sp/>`BarActionP&lt;int&gt;`<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`ACTION_TEMPLATE(Bar,<sp/>HAS_m_TEMPLATE_PARAMS(...),<sp/>AND_1_VALUE_PARAMS(p1))`<sp/>|<sp/>`Bar&lt;t1,<sp/>...,<sp/>t_m&gt;(int_value)`<sp/>|<sp/>`FooActionP&lt;t1,<sp/>...,<sp/>t_m,<sp/>int&gt;`<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`ACTION_P2(Baz,<sp/>p1,<sp/>p2)`<sp/>|<sp/>`Baz(bool_value,<sp/>int_value)`<sp/>|<sp/>`BazActionP2&lt;bool,<sp/>int&gt;`<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`ACTION_TEMPLATE(Baz,<sp/>HAS_m_TEMPLATE_PARAMS(...),<sp/>AND_2_VALUE_PARAMS(p1,<sp/>p2))`<sp/>|<sp/>`Baz&lt;t1,<sp/>...,<sp/>t_m&gt;(bool_value,<sp/>int_value)`<sp/>|<sp/>`FooActionP2&lt;t1,<sp/>...,<sp/>t_m,<sp/>bool,<sp/>int&gt;`<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>...<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>...<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>...<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>we<sp/>have<sp/>to<sp/>pick<sp/>different<sp/>suffixes<sp/>(`Action`,<sp/>`ActionP`,</highlight></codeline>
<codeline><highlight class="normal">`ActionP2`,<sp/>and<sp/>etc)<sp/>for<sp/>actions<sp/>with<sp/>different<sp/>numbers<sp/>of<sp/>value</highlight></codeline>
<codeline><highlight class="normal">parameters,<sp/>or<sp/>the<sp/>action<sp/>definitions<sp/>cannot<sp/>be<sp/>overloaded<sp/>on<sp/>the</highlight></codeline>
<codeline><highlight class="normal">number<sp/>of<sp/>them.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Writing<sp/>New<sp/>Monomorphic<sp/>Actions<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">While<sp/>the<sp/>`ACTION*`<sp/>macros<sp/>are<sp/>very<sp/>convenient,<sp/>sometimes<sp/>they<sp/>are</highlight></codeline>
<codeline><highlight class="normal">inappropriate.<sp/><sp/>For<sp/>example,<sp/>despite<sp/>the<sp/>tricks<sp/>shown<sp/>in<sp/>the<sp/>previous</highlight></codeline>
<codeline><highlight class="normal">recipes,<sp/>they<sp/>don&apos;t<sp/>let<sp/>you<sp/>directly<sp/>specify<sp/>the<sp/>types<sp/>of<sp/>the<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">function<sp/>arguments<sp/>and<sp/>the<sp/>action<sp/>parameters,<sp/>which<sp/>in<sp/>general<sp/>leads</highlight></codeline>
<codeline><highlight class="normal">to<sp/>unoptimized<sp/>compiler<sp/>error<sp/>messages<sp/>that<sp/>can<sp/>baffle<sp/>unfamiliar</highlight></codeline>
<codeline><highlight class="normal">users.<sp/><sp/>They<sp/>also<sp/>don&apos;t<sp/>allow<sp/>overloading<sp/>actions<sp/>based<sp/>on<sp/>parameter</highlight></codeline>
<codeline><highlight class="normal">types<sp/>without<sp/>jumping<sp/>through<sp/>some<sp/>hoops.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">An<sp/>alternative<sp/>to<sp/>the<sp/>`ACTION*`<sp/>macros<sp/>is<sp/>to<sp/>implement</highlight></codeline>
<codeline><highlight class="normal">`::testing::ActionInterface&lt;F&gt;`,<sp/>where<sp/>`F`<sp/>is<sp/>the<sp/>type<sp/>of<sp/>the<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">function<sp/>in<sp/>which<sp/>the<sp/>action<sp/>will<sp/>be<sp/>used.<sp/>For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>F&gt;class<sp/>ActionInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~ActionInterface();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Performs<sp/>the<sp/>action.<sp/><sp/>Result<sp/>is<sp/>the<sp/>return<sp/>type<sp/>of<sp/>function<sp/>type</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>F,<sp/>and<sp/>ArgumentTuple<sp/>is<sp/>the<sp/>tuple<sp/>of<sp/>arguments<sp/>of<sp/>F.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>For<sp/>example,<sp/>if<sp/>F<sp/>is<sp/>int(bool,<sp/>const<sp/>string&amp;),<sp/>then<sp/>Result<sp/>would</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>be<sp/>int,<sp/>and<sp/>ArgumentTuple<sp/>would<sp/>be<sp/>::testing::tuple&lt;bool,<sp/>const<sp/>string&amp;&gt;.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>Result<sp/>Perform(const<sp/>ArgumentTuple&amp;<sp/>args)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Action;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::ActionInterface;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MakeAction;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">typedef<sp/>int<sp/>IncrementMethod(int*);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>IncrementArgumentAction<sp/>:<sp/>public<sp/>ActionInterface&lt;IncrementMethod&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>int<sp/>Perform(const<sp/>::testing::tuple&lt;int*&gt;&amp;<sp/>args)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int*<sp/>p<sp/>=<sp/>::testing::get&lt;0&gt;(args);<sp/><sp/>//<sp/>Grabs<sp/>the<sp/>first<sp/>argument.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>*p++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Action&lt;IncrementMethod&gt;<sp/>IncrementArgument()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>MakeAction(new<sp/>IncrementArgumentAction);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Baz(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(IncrementArgument());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>n<sp/>=<sp/>5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.Baz(&amp;n);<sp/><sp/>//<sp/>Should<sp/>return<sp/>5<sp/>and<sp/>change<sp/>n<sp/>to<sp/>6.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Writing<sp/>New<sp/>Polymorphic<sp/>Actions<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>previous<sp/>recipe<sp/>showed<sp/>you<sp/>how<sp/>to<sp/>define<sp/>your<sp/>own<sp/>action.<sp/>This<sp/>is</highlight></codeline>
<codeline><highlight class="normal">all<sp/>good,<sp/>except<sp/>that<sp/>you<sp/>need<sp/>to<sp/>know<sp/>the<sp/>type<sp/>of<sp/>the<sp/>function<sp/>in</highlight></codeline>
<codeline><highlight class="normal">which<sp/>the<sp/>action<sp/>will<sp/>be<sp/>used.<sp/>Sometimes<sp/>that<sp/>can<sp/>be<sp/>a<sp/>problem.<sp/>For</highlight></codeline>
<codeline><highlight class="normal">example,<sp/>if<sp/>you<sp/>want<sp/>to<sp/>use<sp/>the<sp/>action<sp/>in<sp/>functions<sp/>with<sp/>_different_</highlight></codeline>
<codeline><highlight class="normal">types<sp/>(e.g.<sp/>like<sp/>`Return()`<sp/>and<sp/>`SetArgPointee()`).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>an<sp/>action<sp/>can<sp/>be<sp/>used<sp/>in<sp/>several<sp/>types<sp/>of<sp/>mock<sp/>functions,<sp/>we<sp/>say</highlight></codeline>
<codeline><highlight class="normal">it&apos;s<sp/>_polymorphic_.<sp/>The<sp/>`MakePolymorphicAction()`<sp/>function<sp/>template</highlight></codeline>
<codeline><highlight class="normal">makes<sp/>it<sp/>easy<sp/>to<sp/>define<sp/>such<sp/>an<sp/>action:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">namespace<sp/>testing<sp/>{</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>Impl&gt;</highlight></codeline>
<codeline><highlight class="normal">PolymorphicAction&lt;Impl&gt;<sp/>MakePolymorphicAction(const<sp/>Impl&amp;<sp/>impl);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">}<sp/><sp/>//<sp/>namespace<sp/>testing</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">As<sp/>an<sp/>example,<sp/>let&apos;s<sp/>define<sp/>an<sp/>action<sp/>that<sp/>returns<sp/>the<sp/>second<sp/>argument</highlight></codeline>
<codeline><highlight class="normal">in<sp/>the<sp/>mock<sp/>function&apos;s<sp/>argument<sp/>list.<sp/>The<sp/>first<sp/>step<sp/>is<sp/>to<sp/>define<sp/>an</highlight></codeline>
<codeline><highlight class="normal">implementation<sp/>class:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">class<sp/>ReturnSecondArgumentAction<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template<sp/>&lt;typename<sp/>Result,<sp/>typename<sp/>ArgumentTuple&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Result<sp/>Perform(const<sp/>ArgumentTuple&amp;<sp/>args)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>To<sp/>get<sp/>the<sp/>i-th<sp/>(0-based)<sp/>argument,<sp/>use<sp/>::testing::get&lt;i&gt;(args).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>::testing::get&lt;1&gt;(args);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>implementation<sp/>class<sp/>does<sp/>_not_<sp/>need<sp/>to<sp/>inherit<sp/>from<sp/>any</highlight></codeline>
<codeline><highlight class="normal">particular<sp/>class.<sp/>What<sp/>matters<sp/>is<sp/>that<sp/>it<sp/>must<sp/>have<sp/>a<sp/>`Perform()`</highlight></codeline>
<codeline><highlight class="normal">method<sp/>template.<sp/>This<sp/>method<sp/>template<sp/>takes<sp/>the<sp/>mock<sp/>function&apos;s</highlight></codeline>
<codeline><highlight class="normal">arguments<sp/>as<sp/>a<sp/>tuple<sp/>in<sp/>a<sp/>**single**<sp/>argument,<sp/>and<sp/>returns<sp/>the<sp/>result<sp/>of</highlight></codeline>
<codeline><highlight class="normal">the<sp/>action.<sp/>It<sp/>can<sp/>be<sp/>either<sp/>`const`<sp/>or<sp/>not,<sp/>but<sp/>must<sp/>be<sp/>invokable</highlight></codeline>
<codeline><highlight class="normal">with<sp/>exactly<sp/>one<sp/>template<sp/>argument,<sp/>which<sp/>is<sp/>the<sp/>result<sp/>type.<sp/>In<sp/>other</highlight></codeline>
<codeline><highlight class="normal">words,<sp/>you<sp/>must<sp/>be<sp/>able<sp/>to<sp/>call<sp/>`Perform&lt;R&gt;(args)`<sp/>where<sp/>`R`<sp/>is<sp/>the</highlight></codeline>
<codeline><highlight class="normal">mock<sp/>function&apos;s<sp/>return<sp/>type<sp/>and<sp/>`args`<sp/>is<sp/>its<sp/>arguments<sp/>in<sp/>a<sp/>tuple.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Next,<sp/>we<sp/>use<sp/>`MakePolymorphicAction()`<sp/>to<sp/>turn<sp/>an<sp/>instance<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal">implementation<sp/>class<sp/>into<sp/>the<sp/>polymorphic<sp/>action<sp/>we<sp/>need.<sp/>It<sp/>will<sp/>be</highlight></codeline>
<codeline><highlight class="normal">convenient<sp/>to<sp/>have<sp/>a<sp/>wrapper<sp/>for<sp/>this:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MakePolymorphicAction;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::PolymorphicAction;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">PolymorphicAction&lt;ReturnSecondArgumentAction&gt;<sp/>ReturnSecondArgument()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>MakePolymorphicAction(ReturnSecondArgumentAction());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Now,<sp/>you<sp/>can<sp/>use<sp/>this<sp/>polymorphic<sp/>action<sp/>the<sp/>same<sp/>way<sp/>you<sp/>use<sp/>the</highlight></codeline>
<codeline><highlight class="normal">built-in<sp/>ones:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD2(DoThis,<sp/>int(bool<sp/>flag,<sp/>int<sp/>n));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD3(DoThat,<sp/>string(int<sp/>x,<sp/>const<sp/>char*<sp/>str1,<sp/>const<sp/>char*<sp/>str2));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(ReturnSecondArgument());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat(_,<sp/>_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(ReturnSecondArgument());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThis(true,<sp/>5);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Will<sp/>return<sp/>5.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThat(1,<sp/>&quot;Hi&quot;,<sp/>&quot;Bye&quot;);<sp/><sp/>//<sp/>Will<sp/>return<sp/>&quot;Hi&quot;.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Teaching<sp/>Google<sp/>Mock<sp/>How<sp/>to<sp/>Print<sp/>Your<sp/>Values<sp/>##</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>an<sp/>uninteresting<sp/>or<sp/>unexpected<sp/>call<sp/>occurs,<sp/>Google<sp/>Mock<sp/>prints<sp/>the</highlight></codeline>
<codeline><highlight class="normal">argument<sp/>values<sp/>and<sp/>the<sp/>stack<sp/>trace<sp/>to<sp/>help<sp/>you<sp/>debug.<sp/><sp/>Assertion</highlight></codeline>
<codeline><highlight class="normal">macros<sp/>like<sp/>`EXPECT_THAT`<sp/>and<sp/>`EXPECT_EQ`<sp/>also<sp/>print<sp/>the<sp/>values<sp/>in</highlight></codeline>
<codeline><highlight class="normal">question<sp/>when<sp/>the<sp/>assertion<sp/>fails.<sp/><sp/>Google<sp/>Mock<sp/>and<sp/>Google<sp/>Test<sp/>do<sp/>this<sp/>using</highlight></codeline>
<codeline><highlight class="normal">Google<sp/>Test&apos;s<sp/>user-extensible<sp/>value<sp/>printer.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>printer<sp/>knows<sp/>how<sp/>to<sp/>print<sp/>built-in<sp/>C++<sp/>types,<sp/>native<sp/>arrays,<sp/>STL</highlight></codeline>
<codeline><highlight class="normal">containers,<sp/>and<sp/>any<sp/>type<sp/>that<sp/>supports<sp/>the<sp/>`&lt;&lt;`<sp/>operator.<sp/><sp/>For<sp/>other</highlight></codeline>
<codeline><highlight class="normal">types,<sp/>it<sp/>prints<sp/>the<sp/>raw<sp/>bytes<sp/>in<sp/>the<sp/>value<sp/>and<sp/>hopes<sp/>that<sp/>you<sp/>the</highlight></codeline>
<codeline><highlight class="normal">user<sp/>can<sp/>figure<sp/>it<sp/>out.</highlight></codeline>
<codeline><highlight class="normal">[Google<sp/>Test&apos;s<sp/>advanced<sp/>guide](../../googletest/docs/AdvancedGuide.md#teaching-google-test-how-to-print-your-values)</highlight></codeline>
<codeline><highlight class="normal">explains<sp/>how<sp/>to<sp/>extend<sp/>the<sp/>printer<sp/>to<sp/>do<sp/>a<sp/>better<sp/>job<sp/>at</highlight></codeline>
<codeline><highlight class="normal">printing<sp/>your<sp/>particular<sp/>type<sp/>than<sp/>to<sp/>dump<sp/>the<sp/>bytes.</highlight></codeline>
    </programlisting>
    <location file="vendor/googletest/googlemock/docs/CookBook.md"/>
  </compounddef>
</doxygen>
